# MCP Guard Configuration Template
# Copy this file to your project root and customize

[server]
host = "127.0.0.1"
port = 3000
# TLS Configuration (optional)
# tls = { cert_path = "cert.pem", key_path = "key.pem" }
# mTLS: Add client_ca_path to require and validate client certificates
# tls = { cert_path = "cert.pem", key_path = "key.pem", client_ca_path = "client-ca.pem" }

[auth]
# API Key Authentication
# Generate keys with: mcp-guard keygen --user-id <name>
# api_keys = [
#   { id = "service1", key_hash = "<hash>", allowed_tools = ["read", "list"] },
#   { id = "admin", key_hash = "<hash>", rate_limit = 1000 },
# ]

# =============================================================================
# JWT Authentication (optional) - Choose ONE mode below
# =============================================================================

# -----------------------------------------------------------------------------
# Simple Mode (HS256) - Good for development/single-tenant
# -----------------------------------------------------------------------------
# [auth.jwt]
# mode = "simple"
# secret = "your-256-bit-secret-key-here-min-32-chars"
# issuer = "https://your-app.com"
# audience = "mcp-guard"
# user_id_claim = "sub"          # default: extract user ID from 'sub' claim
# scopes_claim = "scope"         # default: extract scopes from 'scope' claim
# leeway_secs = 60               # optional: clock skew tolerance

# -----------------------------------------------------------------------------
# JWKS Mode (RS256/ES256) - Production with IdP
# -----------------------------------------------------------------------------
# [auth.jwt]
# mode = "jwks"
# jwks_url = "https://your-idp.com/.well-known/jwks.json"
# algorithms = ["RS256", "ES256"]  # allowed algorithms
# cache_duration_secs = 3600       # default: 1 hour
# issuer = "https://your-idp.com/"
# audience = "mcp-guard"
# user_id_claim = "sub"
# scopes_claim = "scope"

# Scope-to-tool mapping (optional) - maps JWT scopes to allowed MCP tools
# [auth.jwt.scope_tool_mapping]
# "read:files" = ["read_file", "list_directory"]
# "write:files" = ["write_file", "delete_file"]
# "admin" = ["*"]  # wildcard = all tools allowed

# -----------------------------------------------------------------------------
# Auth0 Example
# -----------------------------------------------------------------------------
# [auth.jwt]
# mode = "jwks"
# jwks_url = "https://YOUR_DOMAIN.auth0.com/.well-known/jwks.json"
# algorithms = ["RS256"]
# issuer = "https://YOUR_DOMAIN.auth0.com/"
# audience = "mcp-guard"
# scopes_claim = "permissions"  # Auth0 uses 'permissions' for RBAC

# -----------------------------------------------------------------------------
# Keycloak Example
# -----------------------------------------------------------------------------
# [auth.jwt]
# mode = "jwks"
# jwks_url = "https://keycloak.example.com/realms/YOUR_REALM/protocol/openid-connect/certs"
# algorithms = ["RS256"]
# issuer = "https://keycloak.example.com/realms/YOUR_REALM"
# audience = "mcp-guard"
# user_id_claim = "preferred_username"

# =============================================================================
# OAuth 2.1 Authentication (optional)
# Supports authorization code flow with PKCE (FR-AUTH-05)
# =============================================================================

# -----------------------------------------------------------------------------
# GitHub OAuth Example
# SECURITY: Use HTTPS for redirect_uri in production to prevent code interception
# -----------------------------------------------------------------------------
# [auth.oauth]
# provider = "github"
# client_id = "your-github-client-id"
# client_secret = "your-github-client-secret"  # Get from GitHub OAuth App settings
# redirect_uri = "https://your-domain.com/oauth/callback"  # Use HTTPS in production!
# scopes = ["read:user", "repo"]
# user_id_claim = "id"  # GitHub returns numeric user ID

# Scope-to-tool mapping (optional)
# [auth.oauth.scope_tool_mapping]
# "read:user" = ["read_file", "list_directory"]
# "repo" = ["write_file", "read_file", "list_directory"]

# -----------------------------------------------------------------------------
# Google OAuth Example
# SECURITY: Use HTTPS for redirect_uri in production
# -----------------------------------------------------------------------------
# [auth.oauth]
# provider = "google"
# client_id = "your-google-client-id.apps.googleusercontent.com"
# client_secret = "your-google-client-secret"
# redirect_uri = "https://your-domain.com/oauth/callback"  # Use HTTPS in production!
# scopes = ["openid", "profile", "email"]
# user_id_claim = "sub"

# -----------------------------------------------------------------------------
# Custom OAuth Provider Example (e.g., Okta, Azure AD)
# SECURITY: Use HTTPS for redirect_uri in production
# -----------------------------------------------------------------------------
# [auth.oauth]
# provider = "custom"
# client_id = "your-client-id"
# client_secret = "your-client-secret"
# authorization_url = "https://your-idp.com/oauth/authorize"
# token_url = "https://your-idp.com/oauth/token"
# introspection_url = "https://your-idp.com/oauth/introspect"  # For opaque token validation
# userinfo_url = "https://your-idp.com/userinfo"               # Fallback for token info
# redirect_uri = "https://your-domain.com/oauth/callback"  # Use HTTPS in production!
# scopes = ["openid", "profile"]
# user_id_claim = "sub"

# OAuth Flow:
# 1. User visits /oauth/authorize -> redirects to OAuth provider
# 2. User authenticates with provider
# 3. Provider redirects to /oauth/callback with authorization code
# 4. MCP Guard exchanges code for access token (with PKCE)
# 5. User receives access token for API calls

# =============================================================================
# mTLS Client Certificate Authentication (optional)
# Enterprise feature for service-to-service authentication
# =============================================================================

# mTLS can be used two ways:
# 1. Native: Configure server.tls.client_ca_path (requires axum-server with rustls)
# 2. Proxy: Use a reverse proxy (nginx, HAProxy) that validates certs and forwards
#           certificate info in headers (X-Client-Cert-CN, X-Client-Cert-Verified)

# -----------------------------------------------------------------------------
# mTLS via Reverse Proxy (recommended for most deployments)
# Configure your proxy to forward client cert info in headers
# SECURITY: trusted_proxy_ips MUST be configured to prevent header spoofing
# -----------------------------------------------------------------------------
# [auth.mtls]
# enabled = true
# identity_source = "cn"                 # Extract identity from: cn, san_dns, san_email
# allowed_tools = ["read_file", "write_file"]  # Optional: restrict tools (empty = all)
# rate_limit = 1000                      # Optional: custom rate limit
# trusted_proxy_ips = ["10.0.0.0/8", "172.16.0.0/12"]  # REQUIRED: IPs allowed to set cert headers

# -----------------------------------------------------------------------------
# Example: nginx mTLS termination
# -----------------------------------------------------------------------------
# nginx config:
#   ssl_client_certificate /etc/nginx/client-ca.pem;
#   ssl_verify_client on;
#   proxy_set_header X-Client-Cert-CN $ssl_client_s_dn_cn;
#   proxy_set_header X-Client-Cert-Verified $ssl_client_verify;
#
# mcp-guard config:
# [auth.mtls]
# enabled = true
# identity_source = "cn"

[rate_limit]
enabled = true
requests_per_second = 100
burst_size = 50

[audit]
enabled = true
# SECURITY: stdout defaults to false to prevent accidental PII exposure.
# Explicitly enable stdout logging or configure a file path.
stdout = false
# file = "/var/log/mcp-guard/audit.log"

# -----------------------------------------------------------------------------
# HTTP Export for SIEM Integration (optional)
# Batch and ship audit logs to an HTTP endpoint
# -----------------------------------------------------------------------------
# export_url = "https://siem.example.com/api/logs"
# export_batch_size = 100           # Number of logs to batch before sending
# export_interval_secs = 30         # Flush interval even if batch not full
# export_headers = { "Authorization" = "Bearer your-api-key", "X-Source" = "mcp-guard" }

# Example: Ship to Datadog
# export_url = "https://http-intake.logs.datadoghq.com/api/v2/logs"
# export_headers = { "DD-API-KEY" = "your-datadog-api-key" }
# export_batch_size = 50
# export_interval_secs = 10

# Example: Ship to Splunk HEC
# export_url = "https://splunk.example.com:8088/services/collector/event"
# export_headers = { "Authorization" = "Splunk your-hec-token" }
# export_batch_size = 100
# export_interval_secs = 15

# =============================================================================
# OpenTelemetry Tracing (optional) - FR-OBS-03
# Distributed tracing with W3C trace context propagation
# =============================================================================

[tracing]
enabled = false                    # Enable OpenTelemetry tracing
service_name = "mcp-guard"         # Service name in traces
# otlp_endpoint = "http://localhost:4317"  # OTLP gRPC endpoint (Jaeger, Tempo, etc.)
# SECURITY: Default is 0.1 (10%) to minimize performance impact in production.
# Increase to 1.0 for development/debugging.
sample_rate = 0.1                  # Sample rate: 0.0 (none) to 1.0 (all)
propagate_context = true           # Extract/inject W3C traceparent headers

# Example: Send traces to Jaeger (running locally)
# [tracing]
# enabled = true
# service_name = "mcp-guard"
# otlp_endpoint = "http://localhost:4317"
# sample_rate = 1.0
# propagate_context = true

# Example: Send traces to Grafana Tempo
# [tracing]
# enabled = true
# service_name = "mcp-guard"
# otlp_endpoint = "http://tempo.monitoring.svc:4317"
# sample_rate = 0.1  # Sample 10% of requests in production

# =============================================================================
# Upstream MCP Server Configuration
# Supported transports: stdio, http, sse
# =============================================================================

[upstream]
transport = "stdio"
command = "npx"
args = ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"]

# -----------------------------------------------------------------------------
# Stdio Transport (default) - Spawn a local MCP server process
# -----------------------------------------------------------------------------
# [upstream]
# transport = "stdio"
# command = "npx"
# args = ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"]

# Python MCP server example:
# [upstream]
# transport = "stdio"
# command = "python"
# args = ["-m", "mcp_server", "--port", "0"]

# -----------------------------------------------------------------------------
# HTTP Transport - Connect to HTTP-based MCP server
# Sends JSON-RPC requests via HTTP POST, receives JSON responses
# -----------------------------------------------------------------------------
# [upstream]
# transport = "http"
# url = "http://localhost:8080/mcp"

# Remote MCP server with authentication:
# [upstream]
# transport = "http"
# url = "https://mcp.example.com/api/v1/rpc"

# -----------------------------------------------------------------------------
# SSE Transport - Server-Sent Events for streaming responses
# Sends JSON-RPC via HTTP POST, receives SSE stream for streaming results
# Best for long-running tool calls that stream output
# -----------------------------------------------------------------------------
# [upstream]
# transport = "sse"
# url = "http://localhost:8080/mcp/stream"

# Production SSE example:
# [upstream]
# transport = "sse"
# url = "https://mcp.example.com/api/v1/stream"

# =============================================================================
# Multi-Server Routing (optional)
# Route requests to different upstream MCP servers based on path prefix
# =============================================================================

# When servers array is configured, requests are routed by path:
#   POST /mcp/github  -> routes to "github" server
#   POST /mcp/filesystem -> routes to "filesystem" server
#
# Use GET /routes to list all available server routes

# Example: Multiple MCP servers behind single gateway
# [upstream]
# transport = "stdio"  # Default transport (ignored when servers configured)
# command = "echo"     # Default command (ignored when servers configured)
#
# [[upstream.servers]]
# name = "github"
# path_prefix = "/github"
# transport = "http"
# url = "https://github-mcp.example.com/api"
# strip_prefix = false  # Keep /github in forwarded path
#
# [[upstream.servers]]
# name = "filesystem"
# path_prefix = "/filesystem"
# transport = "stdio"
# command = "npx"
# args = ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"]
#
# [[upstream.servers]]
# name = "database"
# path_prefix = "/database"
# transport = "http"
# url = "http://localhost:8081/mcp"

# Example: Microservices architecture
# [[upstream.servers]]
# name = "users"
# path_prefix = "/users"
# transport = "http"
# url = "http://user-service:8080/mcp"
#
# [[upstream.servers]]
# name = "orders"
# path_prefix = "/orders"
# transport = "http"
# url = "http://order-service:8080/mcp"
#
# [[upstream.servers]]
# name = "inventory"
# path_prefix = "/inventory"
# transport = "sse"
# url = "http://inventory-service:8080/mcp/stream"
